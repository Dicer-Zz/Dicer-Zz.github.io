{"pages":[{"title":"about","text":"Welcome!Hello, I’m Dicer. 欢迎来到我的小站，本站点仅用于存放个人blog和日记，所有内容由本人编撰或来自网络，如有侵权请联系我，Contact Me On Email：dicer0615@outlook.com。 本站超酷的图片来自俄罗斯画师：Anton Fadeev，Ta的主页","link":"/about/index.html"}],"posts":[{"title":"2017浙江省赛","text":"碎碎念明天就又去郑轻了（噫，我为什么要说又，哦，上次天梯就是在郑轻），希望这次能取得一个好成绩！不能再这么菜下去了。 老毕再次KILL一道数位DP，这也太强了。我贡献一发构造题。 复盘早上起晚了，迟到30min，AB两题我到的时候已经Ａ掉了，然后mengshen在上机写Ｃ，然后我看Ｄ，老毕再看Ｇ，说是博弈，然而我根本不会博弈，于是继续看我的Ｄ，看完发现是一个普通的线段合并，觉得可写，此时mengshen还在改Ｃ，于是我给老毕讲了一下题意想让他写，但是讲着讲着发下原来的思路复杂了，其实直接两个人的线段全部丢在一起，直接判断重复区间就可以了，就把mengshen赶下来写Ｄ，写完测样例通过直接就交上去了，然后ＷＡ了，发现ＤＥＢＵＧ的输出没删除，删除掉ＡＣ。然后mengshen又上机写Ｃ，并改变了做法，３ＡＣ。然后Ｅ题数位ＤＰ丢给老毕没管过，看Ｆ，本来用的优先队列写了一个假算法，演了一发，然后找到了一组数据ｈａｃｋ了自己，发现是没有贪心，改用multiset贪心，写完测过样例交了，TLE，然后mengshen提议讲ＳＴＬ的lower_bound()换成multiset自带的，说是曾经在CF上看到过一个被lower_bound()卡时间的帖子，遂改，3ＡＣ。 总结最终６题，听说这套省赛题目难度挺大的，感觉打的还可以。 由于前天睡得太晚导致迟到实在不应该，老毕还是强啊，精通数位ＤＰ，还是要继续加油。","link":"/2019/04/12/2017-Zhejiang-provincial-competition/"},{"title":"2019CCPC河南省省赛","text":"碎碎念早上８点才出发，本来以为时间会很紧张，不过９点多一点就到了。不过没有参加开幕式。 复盘然后比赛开始，前两道水题签到很快就过了，然后发现有人在交A，但是都没过，mengshen猜了半天的假结论，直接被hack掉了，然后被通知A重判了，发现过了好几个队，然后仔细想了下，发现直接把每个行当做元素进行LIS就行了。然后我写了半天的LCS过了样例就交了一发，１WA，然后甚至还觉得自己写的很完美，演了半天，然后改抄白书模板自作聪明改了一点，过了样例，又交，２WA，演了大概30min，然后mengshen上机抄了一下模板，然后改了一下check两行之间关系的函数，成功３AC。 期间我看了F题，看了一下题面直接丢给了老毕，然后听他说好像有一个边界判错了浪费了好长时间DEBUG，不过最后还是过了，１A。 这个时候四题已经在金区了（好水），发现C，H都有人过，于是看C，H，以为Ｃ是跟前几天训练一样的multiset写法，然后发现不会两个multiset的合并，内存时间都可能爆炸。Ｈ是一个奇奇怪怪的搜索顺序，到最后都没弄明白。然后觉得可能还有其他题目能开，于是开始一道一道看，发现了Ｉ题是一个暴力剪枝很可行的题，而且很难造能卡主暴力的数据，于是我上机敲了一发暴力，1Ａ，之后一直在Ｃ，Ｈ两题之间倒腾但是并不会写。 结语最后５题水了个金，赞助商爸爸大气，每题一血还有５００现金，Ｉ题差４min一血，好可惜。 面包牛奶香蕉好评，就是面包有点油。上次天梯赛在郑轻的时候，键盘Ctrl特别硬，都摁不下去，这次好像机房升级了，全部ＨＰ的键盘鼠标，县显示器１０８０分辨率超级舒服，i7-8700的电脑用起来真的爽，郑州轻工业大学牛逼！体验极佳。","link":"/2019/04/13/2019-Henan-CCPC-provincial-competition/"},{"title":"2019-蓝桥杯国赛","text":"碎碎念 Day1第一年没比赛，本来以为是需要取报道的，结果不用。也没有其他的安排，就去故宫了。下午还去了北大，自己瞎逛没见到图书馆。 Day2上午在宾馆宅了一上午，下午比赛。 比赛题目突变，暴力能过杯变成了暴力骗分杯。 DP、搜索很多，甚至还有一道复杂的数据结构，蓝桥杯真的转型了。 写的很差，对答案的时候发现就没写对几道题，大概三四十分，心想凉凉。 Day3早上出了成绩发现竟然国一，激动得不行。也发现蓝桥杯还是那么水，这都能国一。 早上的招聘会约了但是没起来没去，只去了下午的颁奖，本来以后国一还能有个U盘，结果什么都没有。 颁奖典礼是真的体面，表白民族大学的小姐姐。魔术师贼帅。蓝桥大气，羡慕国特笔记本+手机。 因为是晚上十点的车，颁完奖才四点多，又去逛了逛圆明园，当天下了雨，圆明园是真的好看。 完。","link":"/2019/05/30/2019-lanqiao-guosai/"},{"title":"拉格朗日乘数法","text":"简单来说，拉格朗日乘子法可以解决$f(\\hat x)$在一些限制条件$g_k(\\hat x) = c_k$下的极值。 Mushroom ScientistsLink Prove本题题意就是给了一个函数$f(x,y,z) = x^a + y^b + z^c$，求这个函数在约束条件$g(x,y,z) = x + y + z - S$下的最大值。 首先，设拉格朗日函数： $$L(x,y,z,\\lambda) = f - \\lambda \\cdot g$$ 然后对各个变量求偏导数： $$\\frac{\\partial L}{\\partial x} = y^b\\cdot z^c \\cdot ax^{a-1} - \\lambda​$$ $$\\frac{\\partial L}{\\partial y} = x^a\\cdot z^c \\cdot by^{b-1} - \\lambda​$$ $$\\frac{\\partial L}{\\partial z} = x^a\\cdot y^b \\cdot cz^{c-1} - \\lambda​$$ $$\\frac{\\partial L}{\\partial \\lambda} = x + y + z - S​$$ 可以解出： $$\\frac{x}{a} = \\frac{y}{b} = \\frac{z}{c}$$ 所以： $$x = \\frac{S\\cdot a}{a+b+c}, y = \\frac{S\\cdot b}{a+b+c}, z = \\frac{S\\cdot c}{a+b+c}​$$ 代码12345678910111213141516171819202122#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;iomanip&gt;using namespace std; const int MAXN = 1e5 + 7;const int mod = 1e9 + 7;typedef long long ll; int main(){ cout &lt;&lt; fixed; int s; int a, b, c; cin &gt;&gt; s &gt;&gt; a &gt;&gt; b &gt;&gt; c; if(a + b + c == 0){ cout &lt;&lt; 0 &lt;&lt; ' ' &lt;&lt; 0 &lt;&lt; ' ' &lt;&lt; 0 &lt;&lt; endl; } else { cout &lt;&lt; setprecision(12) &lt;&lt; (1.0*s*a/(a+b+c)) &lt;&lt; ' ' &lt;&lt; (1.0*s*b/(a+b+c)) &lt;&lt; ' ' &lt;&lt; (1.0*s*c/(a+b+c)) &lt;&lt; endl; } return 0;} Samantha and Portfolio ManagementLink Prove约束条件下的极值问题，可以用拉格朗日乘子法解决。 约束条件：$$g(\\boldsymbol w) = \\sum_{i=1}^{n}{w_i} - 1$$ 极值方程： $$f(\\boldsymbol w) = \\sum_{i=1}^{n}{(w_i^2 \\cdot \\sigma_i^2)} = \\sum_{i=1}^{n}(w_i^2 \\cdot \\frac{1}{i})$$ 拉格朗日方程： $$L(\\boldsymbol w, \\lambda) = f(\\boldsymbol w) - \\lambda \\cdot g(\\boldsymbol w)​$$ 分别对 $\\boldsymbol w , \\lambda​$ 求导： $$\\frac{\\partial(L)}{\\partial(w_i)} = 2 \\frac{w_i}{i} - \\lambda$$ $$\\frac{\\partial(L)}{\\partial(\\lambda)} = g(\\boldsymbol{w}) = 1 - \\sum_{i=1}^{n}{w_i}​$$ 则有： $$w_i = \\frac{\\lambda \\cdot i}{2}$$ 移项： $$\\sum_{i=1}^{n}{w_i} = \\frac{\\lambda \\cdot \\sum_{i=1}^{n}(i)}{2} = \\frac{\\lambda \\cdot n(n+1)}{4} = 1$$ 则：$$\\lambda = \\frac{4}{n(n+1)}​$$ $$w_i = \\frac{\\lambda \\cdot i}{2} = \\frac{2\\cdot i}{n(n+1)}$$ 所以： $$V = \\sum_{i=1}^{n}{w_i^2\\times \\sigma_i^2 } = \\sum_{i=1}^{n}{\\frac{4\\cdot i}(n^2(n+1)^2)} = \\frac{1}{n(n+1)}$$ $$E = \\sum_{i=1}^{n}{w_i \\times \\bar r_i} = \\sum_{i=1}^{n}\\frac{(2\\cdot i \\cdot \\bar r_i)}{n(n+1)}$$ 然后就可以愉快的$O(n)​$解决了。 代码1234567891011121314151617181920212223#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXN = 1e5 + 7;int r[MAXN];void print(long long a, long long b) { long long g = __gcd(a, b); a /= g; b /= g; printf(\"%d %d\\n\", a, b);}int main(){ int n; scanf(\"%d\", &amp;n); long long sum = 0; for(int i = 1; i &lt;= n; ++i) { scanf(\"%d\", r+i); sum += 1LL * i * r[i]; } print(2 * sum, 1LL * n * (n+1)); print(2LL, n * (n+1)); return 0;} 参考1.Wikipedia-Lagrange-Multiplier2.http://jermmy.xyz/2017/07/27/2017-7-27-understand-lagrange-multiplier/","link":"/2019/07/19/Lagrange-Multiplier/"},{"title":"SCOI2005-骑士精神","text":"题目luoguP2324 题解首先很容易想到的是，应该用空格去跳，而不是用马，因为马的数量太多了。 第二，因为搜索状态太多，考虑用使用IDDFS + A*，有一个比较简单的估价函数就是当前状态和终态的不同元素的个数。 考虑到折返是没有任何价值的，因此在搜索过程中保留上一次搜索的方向，在本次搜索中如果是折返操作则跳过。 未跳过折返时时间：1509ms，跳过后：66ms。 可以看出来优化还是很巨大的。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566// luogu-judger-enable-o2#include&lt;bits/stdc++.h&gt;using namespace std;const int n = 5;string final = \"111110111100*110000100000\";int dx[] = {1, 1, 2, 2, -2, -2, -1, -1};int dy[] = {2, -2, 1, -1, 1, -1, 2, -2};int dif(string s){ int res = 0; for(int i = 0; i &lt; n*n; ++i){ if(s[i] != final[i]) res++; } return res;}string s;int lim;bool suc = 0;void dfs(int cur, int last){ if(cur == lim){ //是否搜索成功 if(dif(s) == 0){ suc = 1; } return; } if(suc) return; //最优解剪枝 if(cur + max(0, dif(s) - 1) &gt; lim) return; //当前值 + 最优值 &gt; 迭代深度 int f = s.find('*'); int x = f/n, y = f%n; int xx, yy; for(int i = 0; i &lt; 8; ++i){ if(i + last == 7) continue; //防止回头，优化了很多 xx = x + dx[i]; yy = y + dy[i]; if(xx &gt;= 0 &amp;&amp; xx &lt; n &amp;&amp; yy &gt;= 0 &amp;&amp; yy &lt; n){ swap(s[xx*n + yy], s[x*n + y]); dfs(cur+1, i); swap(s[xx*n + yy], s[x*n + y]); //回溯 } }}int main(){ int T; cin &gt;&gt; T; while(T--){ s = \"\"; string tmp; for(int i = 1; i &lt;= n; ++i){ cin &gt;&gt; tmp; s += tmp; } if(dif(s) == 0) cout &lt;&lt; 0 &lt;&lt; endl; else{ suc = 0; for(int i = 1; i &lt;= 15; ++i){ lim = i; dfs(0, 9); if(suc){ cout &lt;&lt; i &lt;&lt; endl; break; } } if(!suc) cout &lt;&lt; -1 &lt;&lt; endl; } } return 0;}","link":"/2019/06/11/SCOI2005/"},{"title":"ZJOI2008-骑士","text":"题目luoguP2607 bzoj1040 题解基环树就是一颗多了一条边的树，多了这条边，就会产生一个环。 考虑找到这个环上的任意一条边，断掉这条边，然后图形就又变回了树。（可以证明，断环上的哪条边对结果并没有影响） 然后分别都被断掉的这条边的两个端点u、v，做树形动规。 $dp[i][0/1]$表示取不取第$i$个点的最大值。 这和luoguP1352，没有上司的舞会一样。 则这颗基环树的最大值为$max(dp[u][0], dp[v][0])$，当然因为树形动规的特点，一次动规是不能同时求出这两个值的，因此要分别对u、v进行动规。 ==两个注意事项== 非常重要的一点是，两个骑士可能互相憎恨，因此会存在重边，需要特判。 记得开long long。 处理重边的方法： 按照我的建图方式，如果存在重边&lt;u，v&gt;，那么u的可到点集合中会出现两次v。 根据这个特点就可以进行特判了。 另外，这份代码在最后一个测试点TLE了。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273// luogu-judger-enable-o2#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef pair&lt;int, int &gt; pii;inline ll qpow(ll a,ll b,ll mod){ll res=1;while(b){if(b&amp;1)res = (res*a)%mod;a=(a*a)%mod;b&gt;&gt;=1;}return res;}const int mod = 1e9 + 7;const int MAXN = 1e6 + 7;int curx, cury;bool vis[MAXN];vector&lt;int&gt; G[MAXN];ll dp[MAXN][2];int val[MAXN];void dfs(int x, int fa){ if(vis[x]){ curx = x; cury = fa; return; } vis[x] = 1; for(int i = 0; i &lt; G[x].size(); ++i){ int u = G[x][i]; if(u == fa) continue; dfs(u, x); }}void go(int x, int fa){ dp[x][0] = 0; dp[x][1] = val[x]; for(int i = 0; i &lt; G[x].size(); ++i){ int u = G[x][i]; if(u == fa) continue; if(x == curx &amp;&amp; u == cury) continue; if(u == curx &amp;&amp; x == cury) continue; go(u, x); dp[x][0] += max(dp[u][0], dp[u][1]); dp[x][1] += dp[u][0]; }}int main(){ #ifndef ONLINE_JUDGE freopen(\"in.txt\", \"r\", stdin); freopen(\"out.txt\", \"w\", stdout); #endif int n, x; scanf(\"%d\", &amp;n); for(int i = 1; i &lt;= n; ++i){ scanf(\"%d %d\", &amp;val[i], &amp;x); G[x].push_back(i); G[i].push_back(x); } ll res = 0, tmp; for(int i = 1; i &lt;= n; ++i){ if(vis[i]) continue; dfs(i, 0); // cout &lt;&lt; curx &lt;&lt; ' ' &lt;&lt; cury &lt;&lt; endl; // cout &lt;&lt; count(G[curx].begin(), G[curx].end(), cury) &lt;&lt; endl; if(count(G[curx].begin(), G[curx].end(), cury) == 2){ go(curx, 0); go(cury, 0); res += max(dp[curx][0] + dp[cury][1], dp[curx][1] + dp[cury][0]); continue; } go(curx, 0); tmp = dp[curx][0]; go(cury, 0); tmp = max(tmp, dp[cury][0]); res += tmp; } printf(\"%lld\\n\", res); return 0;}","link":"/2019/06/11/ZJOI2008/"},{"title":"BZOJ-2956-模积和","text":"题目BZOJ-2056 一道有点复杂的数论分块。 公式推导所求即为： $$\\sum_{i=1}^{n}\\sum_{j=1}^{m}{(n \\bmod i )\\cdot (m\\bmod j)(i \\neq j)}​$$ 先不管$i\\neq j$的情况:$$\\sum_{i=1}^{n}(\\sum_{j=1}^{m}{(n\\bmod i) \\cdot (m\\bmod j)})$$ $$\\sum_{i=1}^{n}\\sum_{j=1}^{m}{(n-i\\lfloor \\frac{n}{i} \\rfloor)(m-j\\lfloor \\frac{m}{j} \\rfloor)}​$$ $$\\sum_{i=1}^{n}\\sum_{j=1}^{m}{(n m - n\\cdot j\\lfloor \\frac{m}{j} \\rfloor - m\\cdot i\\lfloor \\frac{n}{i} \\rfloor + ij\\lfloor \\frac{n}{i} \\rfloor \\lfloor \\frac{m}{j} \\rfloor)}​$$ $$n^2m^2 - n^2\\sum_{j=1}^{m}{j\\lfloor \\frac{m}{j} \\rfloor} - m^2\\sum_{i=1}^{n}i\\lfloor \\frac{n}{i} \\rfloor + \\sum_{i=1}^{n}i\\lfloor \\frac{n}{i} \\rfloor\\sum_{i=1}^{m}j\\lfloor \\frac{m}{j} \\rfloor​$$ 然后在讨论$i = j​$的情况: $$\\sum_{i=1}^{min(n, m)}{(n\\bmod i)\\cdot (m\\bmod i)}$$ $$\\sum_{i=1}^{min(n, m)}{(n - i\\lfloor \\frac{n}{i} \\rfloor)(m - i\\lfloor \\frac{m}{i} \\rfloor)} ​$$ $$\\sum_{i=1}^{min(n, m)}{n m - m\\cdot i\\lfloor \\frac{n}{i} \\rfloor - n\\cdot i\\lfloor \\frac{m}{i} \\rfloor + i^2 \\lfloor \\frac{n}{i} \\rfloor \\lfloor \\frac{m}{i} \\rfloor} ​$$ 然后就可以愉快的分块了。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576/************************************************************** Problem: 2956 User: Dicer Language: C++ Result: Accepted Time:184 ms Memory:1292 kb****************************************************************/ #include&lt;bits/stdc++.h&gt;#define rep(i, a, b) for(int i = (a); i &lt;= (int)(b); ++i)#define per(i, a, b) for(int i = (a); i &gt;= (int)(b); --i)#define debug(x) cout &lt;&lt; #x &lt;&lt; ' ' &lt;&lt; x &lt;&lt; endl;using namespace std; typedef long long ll;const int MAXN = 1e5 + 7;const int MOD = 19940417;const int INV = 3323403; ll cal(ll n){ ll ans = 0; for(ll i = 1, j; i &lt;= n; i = j + 1){ j = n / ( n / i); ans += (i + j) * (j - i + 1) / 2 * (n / i); ans %= MOD; } return ans;}ll cal(ll n, ll k){ ll ans = 0; for(ll i = 1, j; i &lt;= k; i = j + 1){ j = min(k, n / ( n / i)); ans += (i + j) * (j - i + 1) / 2 * (n / i); ans %= MOD; } return ans;} ll sum(ll n){ return n * (n + 1) % MOD * (2 * n + 1) % MOD * INV % MOD;} ll cal(ll n, ll m, ll k){ ll ans = 0; for(ll i = 1, j; i &lt;= k; i = j + 1){ j = min(k, min(n / (n / i), m / (m / i))); ans += (sum(j) - sum(i-1)) * (n/i) % MOD * (m/i) % MOD; ans %= MOD; } return ans;} ll mul(ll a, ll b){ a %= MOD; b %= MOD; return a * b % MOD;} int main(){ ll n, m, k; scanf(\"%lld%lld\", &amp;n, &amp;m); k = min(n, m); long long ans = 0; ans += mul(n * n, m * m); ans -= mul(n * n, cal(m)); ans -= mul(m * m, cal(n)); ans += mul(cal(n), cal(m)); ans = ((ans % MOD) + MOD) % MOD; ans -= mul(k, n * m); ans += mul(n, cal(m, k)); ans += mul(m, cal(n, k)); ans -= cal(n, m, k); ans = ((ans % MOD) + MOD) % MOD; printf(\"%lld\\n\", ans); return 0;}","link":"/2019/08/06/bzoj-2956/"},{"title":"Codeforces-568-G1","text":"题目hpuoj-74 codeforces-568-G1 题解两个题目都是状压DP，有一定的相似之处，放在一起写。 第一题显然，对于每个宿舍楼内部的宿舍来说，当顺序固定了以后，可以简单的通过贪心得到最少抗议的人数。 那么，我们的主要问题就变成了，求解宿舍楼安装空调最合适的顺序。 定义$dp[sta]$表示状态为$sta$时的最少抗议人数，$cost[i][j]$表示第$i$幢寝室楼第$j​$个空调的贪心值。 那么我们可以这样更新： 1234567for sta := 0 to (1&lt;&lt;n)-1 do cal = sta.count(1) for nex := 0 to n-1 do if (sta&gt;&gt;nex)&amp;1 then continue else dp[sta|1&lt;&lt;nex] = min(dp[sta|1&lt;&lt;nex], dp[sta] + cost[nex][cal+1]) 结果就是$dp[(1&lt;&lt;n)-1] $。 这样更新的理由是： 对于一个状态$sta$，用1表示宿舍楼已经被安排过位置了，0表示还没有安排，统计一下1的个数就能知道在这个状态下，下一个宿舍楼是第几个被装的，而且这个宿舍楼之前一定是没有装过。 例如： $n = 4, sta = 1001$，下一个要装第三个宿舍楼，而二号、三号宿舍楼还没有装。 因此可以更新到$sta = 1101, 1011$这两个状态。 第二题方法一定义$dp[cap][sta][last]$表示当前总和为$cap$，状态为$sta$，最后一首歌的类型为$last$，然后直接维护更新就好了。 时间复杂度：O(T*n*2^n) 方法二定义$dp[sta][last]$表示当前状态为$sta$，最后一首歌的类型为$last$，进行一下更新： 12345678for sta := 0 to (1&lt;&lt;n)-1 do for i := 1 to n do if (sta&gt;&gt;i)&amp;1 then continue for type := 1 to 3 do if type == last[i] then continue dp[sta|1&lt;&lt;(i-1)][last[i]] += dp[sta][type] 这样就能得到所有的情况，但是不一定每一种情况的$cap$都是$T$，所以我们在求和的时候进行判断： 12345678910sum = 0for sta := 0 to (1&lt;&lt;n)-1 do cap = 0 for i := 1 to n do if (sta&gt;&gt;i)&amp;1 then cap += t[i] if cap == T then for type := 1 to 3 do sum += dp[sta][type] 时间复杂度：O(n*2^n) 代码第一题123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef pair&lt;int, int &gt; pii;inline ll qpow(ll a,ll b,ll mod){ll res=1;while(b){if(b&amp;1)res = (res*a)%mod;a=(a*a)%mod;b&gt;&gt;=1;}return res;}const int mod = 1e9 + 7;const int MAXN = 2e5 + 7;int dp[1&lt;&lt;23];int f[23][2333];int a[23][23];int main(){ #ifndef ONLINE_JUDGE freopen(\"in.txt\", \"r\", stdin); freopen(\"out.txt\", \"w\", stdout); #endif int n, m; cin &gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt;= n; ++i){ for(int j = 1; j &lt;= m; ++j){ cin &gt;&gt; f[i][j]; } sort(f[i]+1, f[i]+1+m); } for(int i = 1; i &lt;= n; ++i){ for(int j = 1; j &lt;= n; ++j){ int cur = (j-1)*m + 1, res = 0; for(int k = 1; k &lt;= m; ++k){ if(f[i][k] &gt;= cur){ cur++; } else res++; } a[i][j] = res; } } memset(dp, 0x3f, sizeof dp); dp[0] = 0; function&lt;int(int)&gt; cal = [&amp;](int x){ int res = 0; while(x){ res += x&amp;1; x &gt;&gt;= 1; } return res; }; for(int i = 0; i &lt; (1&lt;&lt;n); ++i){ int cur = cal(i) + 1; for(int j = 0; j &lt; n; ++j){ if((i&gt;&gt;j)&amp;1) continue; dp[i|1&lt;&lt;j] = min(dp[i|1&lt;&lt;j], dp[i] + a[j+1][cur]); } } cout &lt;&lt; dp[(1&lt;&lt;n)-1] &lt;&lt; endl; return 0;} 第二题方法一12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef pair&lt;int, int &gt; pii;inline ll qpow(ll a,ll b,ll mod){ll res=1;while(b){if(b&amp;1)res = (res*a)%mod;a=(a*a)%mod;b&gt;&gt;=1;}return res;}const int mod = 1e9 + 7;const int MAXN = 2e5 + 7;int t[16], g[16];int dp[226][1&lt;&lt;15][3];int main(){ #ifndef ONLINE_JUDGE freopen(\"in.txt\", \"r\", stdin); freopen(\"out.txt\", \"w\", stdout); #endif int n, m; cin &gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt;= n; ++i){ cin &gt;&gt; t[i] &gt;&gt; g[i]; g[i]--; } dp[0][0][0] = 1; dp[0][0][1] = 1; dp[0][0][2] = 1; for(int i = 0; i &lt;= m; ++i){ for(int j = 0; j &lt; (1&lt;&lt;n); ++j){ for(int k = 0; k &lt; n; ++k){ if((j&gt;&gt;k)&amp;1) continue; if(i+t[k+1] &gt; m) continue; for(int type = 0; type &lt; 3; ++type){ if(type == g[k+1]) continue; // cout &lt;&lt; i+t[k+1] &lt;&lt; ' ' &lt;&lt; (j|1&lt;&lt;k) &lt;&lt; ' ' &lt;&lt; g[k+1] &lt;&lt; endl; dp[i+t[k+1]][j|1&lt;&lt;k][g[k+1]] += dp[i][j][type]; dp[i+t[k+1]][j|1&lt;&lt;k][g[k+1]] %= mod; } } } } ll res = 0; for(int i = 0; i &lt; (1&lt;&lt;n); ++i){ for(int j = 0; j &lt; 3; ++j){ res += dp[m][i][j]; res %= mod; } } cout &lt;&lt; res*qpow(2, mod-2, mod)%mod &lt;&lt; endl; return 0;} 方法二1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef pair&lt;int, int &gt; pii;inline ll qpow(ll a,ll b,ll mod){ll res=1;while(b){if(b&amp;1)res = (res*a)%mod;a=(a*a)%mod;b&gt;&gt;=1;}return res;}const int mod = 1e9 + 7;const int MAXN = 2e5 + 7;int t[16], g[16];int dp[1&lt;&lt;16][3];int main(){ #ifndef ONLINE_JUDGE freopen(\"in.txt\", \"r\", stdin); freopen(\"out.txt\", \"w\", stdout); #endif int n, m; cin &gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt;= n; ++i){ cin &gt;&gt; t[i] &gt;&gt; g[i]; } dp[0][1] = dp[0][2] = dp[0][3] = 1; for(int i = 0; i &lt; (1&lt;&lt;n); ++i){ for(int j = 0; j &lt; n; ++j){ if((i&gt;&gt;j)&amp;1) continue; for(int k = 1; k &lt;= 3; ++k){ if(k == g[j+1]) continue; dp[i|1&lt;&lt;j][g[j+1]] += dp[i][k]; dp[i|1&lt;&lt;j][g[j+1]] %= mod; } } } ll res = 0; for(int i = 0; i &lt; (1&lt;&lt;n); ++i){ for(int j = 1; j &lt;= 3; ++j){ int tmp = 0; for(int k = 0; k &lt; n; ++k){ if((i&gt;&gt;k)&amp;1){ tmp += t[k+1]; } } if(tmp == m){ res += dp[i][j]; res %= mod; } } } cout &lt;&lt; res*qpow(2, mod-2, mod)%mod &lt;&lt; endl; return 0;}","link":"/2019/06/24/codeforces-568-G1/"},{"title":"Codeforces-622-F","text":"题目F. The Sum of the k-th Powers 题解设$F(n) = \\sum _{i=1}^n{i^k} $，当k很小的时候，可以找到一些通项公式，比如：当$k= 1 $时，$F(n) = \\frac{(n \\cdot (n+1))}{2} $，当$k=2 $时，$F(n)= \\frac{n \\cdot \\ (2 \\cdot n + 1) \\cdot (n+1)}{6} $。 可以发现，$F(n)$实际上是一个$k+1 $次多项式函数。 因此，我们就可以使用拉格朗日插值法来推导了。 确定一个k+1次多项式需要k+2个点，我们很容易通过打表得到$F(1) \\sim F(k+2)$的值。 然后代入插值公式： $$F(n) = \\sum_{i=1}^{k+2}F(i) \\times P(i) $$ $$P(i) = \\prod_{j=1, j \\neq i}^{k+2}\\frac{n-j}{i-j}​$$ 所以 $$F(n) = \\sum_{i=1}^{k+2}F(i) \\times \\prod_{j=1, j \\neq i}^{k+2}\\frac{n-j}{i-j} \\ = \\sum_{i=1}^{k+2}F(i) \\times \\frac{\\prod_{j=1, j \\neq i}^{k+2}n-j}{\\prod_{j=1, j \\neq i}^{k+2}{i-j}}​$$ 但是这个公式的复杂度时$O(k^2)​$的，我们再优化一下。 设$T = \\prod_{j=1}^{k+2}{n-j}$，则 $$\\prod_{j=1, j \\neq i}^{k+2}n-j = \\frac{T}{n-i}​$$ 对于$\\prod_{j=1, j \\neq i}^{k+2}{i-j}​$，我们将它分成$i\\lt j​$和$i\\gt j​$两部分来考虑， $$\\prod_{j=1, j \\neq i}^{k+2}{i-j} = (i-1)!\\times(k+2-i)!\\times (-1)^{k+2-i}​$$ 带入原式，得： $$F(n) = \\sum_{i=1}^{k+2}(F(i)\\times\\frac{T}{n-i}\\times\\frac{1}{(i-1)!\\times(k+2-i)!\\times (-1)^{k+2-i}})​$$ 至此，我们可以通过打表的方式，在$O(k)$时间内得到$F(n)$了。 注意当$n \\leq k+2$时，该公式时不适用的，因为$T$会为$0$。 但是我们可以直接通过$F(n) = \\sum _{i=1}^n{i^k} $计算。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465/*--------------------------------- @Author: Dicer @DateTime: 2019-06-18 10:16:23---------------------------------*/#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef pair&lt;int, int&gt; pii;inline ll qpow(ll a,ll b,ll mod){ll res=1;while(b){if(b&amp;1)res = (res*a)%mod;a=(a*a)%mod;b&gt;&gt;=1;}return res;}const double eps = 1e-8;const int INF = 0x3f3f3f3f;const int mod = 1e9+7;const int MAXN = 1e6 + 7;ll F[MAXN], fac[MAXN], T;int n, k;ll inv(ll x){ return qpow(x, mod-2, mod);}void init(){ F[1] = 1; for(int i = 2; i &lt;= k+2; ++i){ F[i] = F[i-1] + qpow(i, k, mod); F[i] %= mod; } fac[0] = 1; for(int i = 1; i &lt;= k+2; ++i){ fac[i] = fac[i-1] * i; fac[i] %= mod; } T = 1; for(int i = 1; i &lt;= k+2; ++i){ T *= n - i; T %= mod; }}void solve(){ if(n &lt;= k+2){ ll res = 0; for(int i = 1; i &lt;= n; ++i){ res += qpow(i, k, mod); res %= mod; } cout &lt;&lt; res &lt;&lt; endl; return; } ll res = 0; for(int i = 1; i &lt;= k+2; ++i){ res += F[i] * T % mod * inv(n-i) % mod * inv(fac[i-1]) %mod * inv(fac[k+2-i]) %mod * ((k-i)%2 == 0?1:-1) %mod; res += mod; res %= mod; } cout &lt;&lt; res &lt;&lt; endl;}int main(int argc, char const *argv[]){ cin &gt;&gt; n &gt;&gt; k; init(); solve(); return 0;} Reference 本文题图由User:Glosser.ca - Self-made, based on Image:Lagrangepolys.png，CC BY-SA 3.0，https://commons.wikimedia.org/w/index.php?curid=5538041 参考文章 LaTex","link":"/2019/06/18/codeforces-622-F/"},{"title":"牛客小白赛15","text":"题目牛客小白赛15 题解E. 希望希望是什么，希望是我们这个时代最珍贵的东西。 直接用一颗线段树维护区间最小值就可以了。 然后在做一个背包。 H.数据结构题一个很神奇的思路。 我们将每一个出现x的位置，放进G[x]中，然后查找第一个比r大的位置，和第一个大于定于l的位置，然后这两个位置做差就可以得到x在这段区间中的出现次数了。 代码E. 希望123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081/*--------------------------------- @Author: Dicer @DateTime: 2019-06-16 11:54:32---------------------------------*/#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef pair&lt;int, int&gt; pii;inline ll qpow(ll a,ll b,ll mod){ll res=1;while(b){if(b&amp;1)res = (res*a)%mod;a=(a*a)%mod;b&gt;&gt;=1;}return res;}const double eps = 1e-8;const int INF = 0x3f3f3f3f;const int mod = 1e9+7;const int MAXN = 2e5 + 7;struct node{ int l, r; int mid(){return (l+r)&gt;&gt;1;} int val;}s[MAXN&lt;&lt;1];ll a[MAXN], b[MAXN], dp[MAXN];void build(int l, int r, int x){ s[x].l = l; s[x].r = r; s[x].val = 500; int mid = (l+r)&gt;&gt;1; if(l == r) return; build(l, mid, x&lt;&lt;1); build(mid+1, r, x&lt;&lt;1|1);}inline void upd(int l, int r, int x, int v){ // cout &lt;&lt; l &lt;&lt; ' ' &lt;&lt; r &lt;&lt; ' ' &lt;&lt; s[x].l &lt;&lt; ' ' &lt;&lt; s[x].r &lt;&lt; ' ' &lt;&lt; v &lt;&lt; endl; if(s[x].l &gt;= l &amp;&amp; s[x].r &lt;= r){ s[x].val = min(s[x].val, v); return; } int mid = s[x].mid(); if(r &gt; mid) upd(l, r, x&lt;&lt;1|1, v); if(l &lt;= mid) upd(l, r, x&lt;&lt;1, v);}inline void pushdown(int x){ if(s[x].l == s[x].r){ a[s[x].l] = s[x].val; return; } s[x&lt;&lt;1].val = min(s[x&lt;&lt;1].val, s[x].val); s[x&lt;&lt;1|1].val = min(s[x&lt;&lt;1|1].val, s[x].val); pushdown(x&lt;&lt;1); pushdown(x&lt;&lt;1|1);}int main(int argc, char const *argv[]){ #ifndef ONLINE_JUDGE freopen(\"in.txt\", \"r\", stdin); freopen(\"out.txt\", \"w\", stdout); #endif int n, k, m; cin &gt;&gt; n &gt;&gt; k &gt;&gt; m; for(int i = 1; i &lt;= n; ++i) cin &gt;&gt; b[i]; build(1, n, 1); int l, r; ll c; for(int i = 1; i &lt;= m; ++i){ cin &gt;&gt; l &gt;&gt; r &gt;&gt; c; upd(l, r, 1, c); } pushdown(1); // for(int i = 1; i &lt;= n; ++i) cout &lt;&lt; a[i] &lt;&lt; ' '; // cout &lt;&lt; endl; //dp ll sum = 0; for(int i = 1; i &lt;= n; ++i){ sum += b[i]; if(b[i] &gt;= 0) continue; for(int j = k; j &gt;= a[i]; --j){ dp[j] = max(dp[j], dp[j-a[i]] - b[i]); } } cout &lt;&lt; sum+dp[k] &lt;&lt; endl; return 0;} H.数据结构题123456789101112131415161718192021222324252627282930313233343536373839404142434445/*--------------------------------- @Author: Dicer @DateTime: 2019-06-16 01:55:25---------------------------------*/#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef pair&lt;int, int&gt; pii;inline ll qpow(ll a,ll b,ll mod){ll res=1;while(b){if(b&amp;1)res = (res*a)%mod;a=(a*a)%mod;b&gt;&gt;=1;}return res;}const double eps = 1e-8;const int INF = 0x3f3f3f3f;const int mod = 20180623;const int MAXN = 2e5 + 7;int a[MAXN];vector&lt;int&gt; G[MAXN];int main(int argc, char const *argv[]){ #ifndef ONLINE_JUDGE freopen(\"in.txt\", \"r\", stdin); freopen(\"out.txt\", \"w\", stdout); #endif int n, m; cin &gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt;= n; ++i){ cin &gt;&gt; a[i]; G[a[i]].push_back(i); } ll x, a, b, l1, l2, r1, r2; for(int i = 1; i &lt;= m; ++i){ cin &gt;&gt; l1 &gt;&gt; r1 &gt;&gt; l2 &gt;&gt; r2 &gt;&gt; x; if(l1 &gt; r1) swap(l1, r1); if(l2 &gt; r2) swap(l2, r2); a = upper_bound(G[x].begin(), G[x].end(), r1) - lower_bound(G[x].begin(), G[x].end(), l1); b = upper_bound(G[x].begin(), G[x].end(), r2) - lower_bound(G[x].begin(), G[x].end(), l2); cout &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; b &lt;&lt; endl; cout &lt;&lt; (a%mod)*(b%mod)%mod &lt;&lt; endl; } return 0;}","link":"/2019/06/16/niukexiaobai15/"},{"title":"hexo博客搭建总结","text":"序言之前使用jekyll在github上搭建了一个博客。但是，原博客不支持归档和搜索功能，主题也不是特别喜欢，于是决定重新搭建自己的博客站点。这次放弃了jekyll，使用hexo搭建。主要原因是hexo支持很多插件，且性能强悍。(相中了一个特别好看的主题)。 背景本文代码均基于阿里云Centos7服务器，Manjaro Linux客户端，与hexo引擎。 选择主题在搭建博客之前当然要选择一个自己喜欢的主题了。 可以在hexo的主题官方上挑选一个。戳我 注意挑选的时候不仅要看颜值，还要看一下自己需要的功能这个主题是否支持，当然如果你自己会添加插件，那就挑你最喜欢的就好了。 客户机配置安装Git 下载Git. 修改用户名和邮箱。 12345# 将此处的&quot;yourname&quot;替换成自己的用户名git config --global user.name &quot;yourname&quot;# 将此处的&quot;youremail&quot;替换成自己的邮箱git config --global user.email &quot;youremail&quot; 创建SSH钥匙对 检查是否存在钥匙对。 $ cd ~/.ssh 若没有钥匙对，则创建钥匙对。 $ ssh-keygen -t rsa -C “youremail” 安装Nodejs 使用命令行下载Nodejs。 检查是否下载完成。 $ node -v $ npm -v 安装Hexo框架 使用npm下载hexo $ npm install -g hexo-cli 因为一下原因，npm的下载速度十分感人，建议更换 选择一个你想要存放文件的文件夹，初始化blog。 $ hexo init blog 初始化完毕之后，打开博客根目录的package.json文件，在dependencies的配置中，追加一项：&quot;hexo-deployer-git&quot;: &quot;^0.3.1&quot; 运行hexo $ hexo s 然后在浏览器输入：｀localhost:4000｀，如果出现hexo的界面就说明已经搭建成功了。 如果有包缺失，根据提示下载相应的包，再次尝试即可。 服务端配置首先，进行服务端的系统更新。 $ yum update -y 更新完系统后，输入一下代码查看系统版本。 $ cat /etc/centos-release 安装Nginx安装Nginx分为以下几步。第一，配置Nginx官方源。第二，安装Nginx。第三，配置Nginx配置文件。1、配置Nginx官方源输入以下代码，新建一个文件以配置Nginx源 1$ vi /etc/yum.repos.d/nginx.repo 在打开的文件中输入以下代码，输入完毕之后，按 “esc” 键退出编辑模式， 输入 “:wq” 保存退出。 12345[nginx]name=nginx repobaseurl=http://nginx.org/packages/mainline/centos/7/$basearch/gpgcheck=0enabled=1 2、安装Nginx输入以下代码进行安装。 1$ yum install nginx -y 3、启动Nginx并设置开机自启输入以下代码: 12$ systemctl start nginx$ systemctl enable nginx 进行到这里，你已经可以把服务器ip复制到浏览器就可以看到Nginx的欢迎界面了。 4、配置Nginx接下来，需要修改一下nginx的相关配置，包括设置网站根目录以及配置域名。输入以下代码，打开Nginx的配置文件。(注：此处假定读者已完成了域名备案以及域名解析。) 1$ vi /etc/nginx/conf.d/default.conf 依照下图进行修改，将“/usr/share/nginx/html”改为“/usr/share/nginx/html/blog”。 至此，Nginx的配置就基本完成了。 安装Nodejs输入以下代码进行Nodejs的安装。 1$ yum install nodejs 可输入node -v以及npm -v查看node的版本。至此，Nodejs的安装就完成了。 安装Git以及进行相关配置1、输入以下代码，进行Git的安装 1$ yum install git 2、创建git用户以及设置密码输入以下代码： 1234# 创建用户,用户名为git$ adduser git# 设置密码$ passwd git 3、把git用户添加到sudo用户组中输入以下代码sudo vi /etc/sudoers，打开sudoers文件，输入:/root进行搜索，搜索到代码行root ALL=(ALL) ALL,然后在这一行下添加以下代码git ALL=(ALL) ALL。输入完毕之后，按wq!强制保存退出vi。 4、切换到git用户，添加SSH Key文件并且设置相应的读写与执行权限。输入以下代码： 123456# 切换用户$ su git# 创建目录$ mkdir ~/.ssh# 新建文件$ vim ~/.ssh/authorized_keys 然后把之前在客户端设置的SSH Key,复制到authorized_keys文件中，保存后退出。 接下来设置文件权限，把authorized_keys文件设置成只有属主有读写权限，把ssh目录设置为只有属主有读、写、执行权限。代码如下： 12$ chmod 600 ~/.ssh/authorized_keys$ chmod 700 ~/.ssh 设置完后，返回客户端，打开Git Bash，输入以下代码，测试是否能连接上服务器： 12# ServerIP为你自己服务器的ip$ ssh -v git@ServerIP 注意 SSH使用非对称加密，服务端不需要生成密钥对，而只需要一个authorized_keys文件，里面存放的是你客户端的公钥。客户端应该有密钥对id_rsa和id_rsa.pub文件，客户端的authorized_keys文件应该和id_rsa.pub文件内容一致。如果SSH免密码登录失败，请反复确认上述两点。 5、重新回到服务器，在网站根目录新建一个blog文件夹，用于客户端上传文件，并且把该文件授权给git用户。代码如下： 123# 使用sudo指令，需要输入git用户的密码$ sudo mkdir -p /usr/share/nginx/html/blog$ sudo chown -R git:git /usr/share/nginx/html/blog 6、在服务器上初始化一个git裸库切换到git用户，然后切换到git用户目录，接着初始化裸库，代码如下： 123$ su git$ cd ~$ git init --bare blog.git 接着新建一个post-receive文件 1$ vim ~/blog.git/hooks/post-receive 然后在该文件中输入以下内容： 12#！/bin/shgit --work-tree=/usr/share/nginx/html/blog --git-dir=/home/git/blog.git checkout -f 保存退出之后，再输入以下代码，赋予该文件可执行权限。 1$ chmod +x ~/blog.git/hooks/post-receive 7、返回客户端，设置博客根目录下的_config.yml文件。 12345deploy: type: git repo: git@SERVER:/home/git/blog.git #此处的SERVER需改为你自己服务器的ip branch: master #这里填写分支 message: #提交的信息 保存后，在博客根目录打开Git Bash，输入以下命令： 123$ hexo clean$ hexo g$ hexo d 部署完毕之后，即可在浏览器输入你的服务器ip进行访问你的博客了。 引用fogcrane-基于CentOS搭建Hexo博客","link":"/2019/04/11/hexo_blog_construct_summary/"},{"title":"红楼梦札记","text":"小记昨天晚上看了一集木鱼水心做的87版红楼梦讲解，颇有兴趣，于是决定写一篇博客，记录个人感受。 说起来，曾经多次想要认真读完红楼梦原著却都不了了之，究其根本可能是我本人对其中复杂人物关系招架不住，毕竟在生活中我就不擅长这些事情。还有可能是因为书中前篇铺垫冗长，这种慢热的写法导致我还没看到精彩的部分就已经没了耐心。 确实如木鱼水心在第一篇中所说的那样，虽然同为四大名著，红楼梦却没用其他三本书那样人尽皆知。 至于我为什么想读这本书，可能因为高中的时候同学老师的不经意提起，对为何它能被评为“小说的巅峰”感到好奇，还有就是对书中所描述的美食十分感兴趣。 我为何不选择自己品读名著，观看电视剧？ 原因有二：１、没有太多的时间。２、觉得自己品读原著读不出来什么东西，很可能很快就放弃了。 本篇博客小标题与木鱼水心分p标题相同。 通灵宝玉入红尘，宝黛初会续前盟抄录 满纸荒唐言，一把辛酸泪。 都云作者痴，谁解其中味。 红尘之中美中不足且好事多磨，乐极生悲之时又人非物换，不过是到头一梦，万境归空。 好了歌 世人都道神仙好 惟有功名忘不了 古今将相在何方 荒冢一堆草末了","link":"/2019/04/23/reading-Dream-of-the-Red-Chamber/"},{"title":"使用HTTP协议实现内网文件传输","text":"需求虽然说现在各种网盘、QQ，已经可以满足我们日常基本的小文件传输的需要了，但是当文件比较大的时候还是很慢，因此我们需要一种更快的，更简洁的传输方式来做局域网内的文件传输。 解决方案考虑使用本地的一台主机做服务器，为其他同局域网内的设备（如：手机、平板电脑）提供文件传输服务，使用http协议。 工具MobaXterm、python3。 下载MobaXterm（Windows） 步骤使用MobaXterm 打开Xterm的Servers，选择http。 设置端口号、文件所在地址和开启时间。 开启服务。 使用Python 打开cmd 输入 $ python -m http.server # python3 $ python -m SimpleHTTPServers # python2 如果想要选择端口号的话，可以直接在后面添加。 Tippython方法对中文路径很不友好，不建议使用中文文件名，可能会访问不了。MobaXterm没有问题，中文文件也可以正常访问。 浏览器访问经过上述步骤，你已经可以在其他设备上访问你服务器上的文件了。 在浏览器输入你服务器的本地IP即可（如果不是80端口，则需要自己手动输入）。 经测试，网页直接下载速度约为30Mb/s。 另外，意想不到的一点是，视频文件（MP4）可以直接播放，而且丝毫没有卡顿，因此，我们还可以把它当作视频服务器，下载到电脑上的视频可以在手机📱、平板上看啦。","link":"/2019/06/25/transfer-file-use-http/"}],"tags":[{"name":"Data structure","slug":"Data-structure","link":"/tags/Data-structure/"},{"name":"Dynamic programming","slug":"Dynamic-programming","link":"/tags/Dynamic-programming/"},{"name":"拉格朗日乘数法","slug":"拉格朗日乘数法","link":"/tags/拉格朗日乘数法/"},{"name":"IDA*","slug":"IDA","link":"/tags/IDA/"},{"name":"启发式搜索","slug":"启发式搜索","link":"/tags/启发式搜索/"},{"name":"树形动规","slug":"树形动规","link":"/tags/树形动规/"},{"name":"基环树","slug":"基环树","link":"/tags/基环树/"},{"name":"数论分块","slug":"数论分块","link":"/tags/数论分块/"},{"name":"状压DP","slug":"状压DP","link":"/tags/状压DP/"},{"name":"拉格朗日插值法","slug":"拉格朗日插值法","link":"/tags/拉格朗日插值法/"},{"name":"线段树","slug":"线段树","link":"/tags/线段树/"},{"name":"SSH","slug":"SSH","link":"/tags/SSH/"},{"name":"Server","slug":"Server","link":"/tags/Server/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"Book","slug":"Book","link":"/tags/Book/"},{"name":"http","slug":"http","link":"/tags/http/"}],"categories":[{"name":"Competition","slug":"Competition","link":"/categories/Competition/"},{"name":"数论","slug":"数论","link":"/categories/数论/"},{"name":"搜索","slug":"搜索","link":"/categories/搜索/"},{"name":"图论","slug":"图论","link":"/categories/图论/"},{"name":"动态规划","slug":"动态规划","link":"/categories/动态规划/"},{"name":"数据结构","slug":"数据结构","link":"/categories/数据结构/"},{"name":"Technology","slug":"Technology","link":"/categories/Technology/"},{"name":"Reading","slug":"Reading","link":"/categories/Reading/"},{"name":"网络协议","slug":"网络协议","link":"/categories/网络协议/"}]}