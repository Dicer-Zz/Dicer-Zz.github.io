{"pages":[{"title":"about","text":"Welcome!Hello, I’m Dicer. 欢迎来到我的小站，本站点仅用于存放个人blog和日记，所有内容由本人编撰或来自网络，如有侵权请联系我，Contact Me On Email：dicer0615@outlook.com。 本站超酷的图片来自俄罗斯画师：Anton Fadeev，Ta的主页","link":"/about/index.html"}],"posts":[{"title":"2017浙江省赛","text":"碎碎念明天就又去郑轻了（噫，我为什么要说又，哦，上次天梯就是在郑轻），希望这次能取得一个好成绩！不能再这么菜下去了。 老毕再次KILL一道数位DP，这也太强了。我贡献一发构造题。 复盘早上起晚了，迟到30min，AB两题我到的时候已经Ａ掉了，然后mengshen在上机写Ｃ，然后我看Ｄ，老毕再看Ｇ，说是博弈，然而我根本不会博弈，于是继续看我的Ｄ，看完发现是一个普通的线段合并，觉得可写，此时mengshen还在改Ｃ，于是我给老毕讲了一下题意想让他写，但是讲着讲着发下原来的思路复杂了，其实直接两个人的线段全部丢在一起，直接判断重复区间就可以了，就把mengshen赶下来写Ｄ，写完测样例通过直接就交上去了，然后ＷＡ了，发现ＤＥＢＵＧ的输出没删除，删除掉ＡＣ。然后mengshen又上机写Ｃ，并改变了做法，３ＡＣ。然后Ｅ题数位ＤＰ丢给老毕没管过，看Ｆ，本来用的优先队列写了一个假算法，演了一发，然后找到了一组数据ｈａｃｋ了自己，发现是没有贪心，改用multiset贪心，写完测过样例交了，TLE，然后mengshen提议讲ＳＴＬ的lower_bound()换成multiset自带的，说是曾经在CF上看到过一个被lower_bound()卡时间的帖子，遂改，3ＡＣ。 总结最终６题，听说这套省赛题目难度挺大的，感觉打的还可以。 由于前天睡得太晚导致迟到实在不应该，老毕还是强啊，精通数位ＤＰ，还是要继续加油。","link":"/2019/04/12/2017-Zhejiang-provincial-competition/"},{"title":"2019CCPC河南省省赛","text":"碎碎念早上８点才出发，本来以为时间会很紧张，不过９点多一点就到了。不过没有参加开幕式。 复盘然后比赛开始，前两道水题签到很快就过了，然后发现有人在交A，但是都没过，mengshen猜了半天的假结论，直接被hack掉了，然后被通知A重判了，发现过了好几个队，然后仔细想了下，发现直接把每个行当做元素进行LIS就行了。然后我写了半天的LCS过了样例就交了一发，１WA，然后甚至还觉得自己写的很完美，演了半天，然后改抄白书模板自作聪明改了一点，过了样例，又交，２WA，演了大概30min，然后mengshen上机抄了一下模板，然后改了一下check两行之间关系的函数，成功３AC。 期间我看了F题，看了一下题面直接丢给了老毕，然后听他说好像有一个边界判错了浪费了好长时间DEBUG，不过最后还是过了，１A。 这个时候四题已经在金区了（好水），发现C，H都有人过，于是看C，H，以为Ｃ是跟前几天训练一样的multiset写法，然后发现不会两个multiset的合并，内存时间都可能爆炸。Ｈ是一个奇奇怪怪的搜索顺序，到最后都没弄明白。然后觉得可能还有其他题目能开，于是开始一道一道看，发现了Ｉ题是一个暴力剪枝很可行的题，而且很难造能卡主暴力的数据，于是我上机敲了一发暴力，1Ａ，之后一直在Ｃ，Ｈ两题之间倒腾但是并不会写。 结语最后５题水了个金，赞助商爸爸大气，每题一血还有５００现金，Ｉ题差４min一血，好可惜。 面包牛奶香蕉好评，就是面包有点油。上次天梯赛在郑轻的时候，键盘Ctrl特别硬，都摁不下去，这次好像机房升级了，全部ＨＰ的键盘鼠标，县显示器１０８０分辨率超级舒服，i7-8700的电脑用起来真的爽，郑州轻工业大学牛逼！体验极佳。","link":"/2019/04/13/2019-Henan-CCPC-provincial-competition/"},{"title":"2019-ICPC-沈阳网络赛-D","text":"题目Fish eating fruit 点分治进阶题目，状态很多，统计起来有点复杂。 分析首先肯定是点分治没得跑了，然后就是怎么计算的问题了。 我是先统计出来所有的 $mod $ 后的值，对于每一个节点的深度，可以计算出来这个点对 三个剩余 的贡献。 转移一下就好了。 因为去重的时候做了减法，所有答案可能是负值，要调整回来。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106#include &lt;bits/stdc++.h&gt;#define rep(i, a, b) for(int i = (a); i &lt;= (b); ++i)#define per(i, a, b) for(int i = (a); i &gt;= (b); --i)#define debug(x) cerr &lt;&lt; #x &lt;&lt; ' ' &lt;&lt; x &lt;&lt; endl;#define size sizeeeeeeeeusing namespace std;typedef long long ll;const int MOD = 1e9+7;const int MAXN = 1e4 + 7;ll ans1, ans2, ans3, cnt[4];int n, root, size, tot = 0;int son[MAXN], f[MAXN], head[MAXN];int dep[MAXN]; bool vis[MAXN];struct node{ int u, w, nxt;}; vector&lt;node&gt; E;void add(int u, int v, int w) { E.push_back(node{v, w, head[u]}); head[u] = tot++;}void get_rt(int x, int fa = 0) { son[x] = 1; f[x] = 0; for(int j = head[x]; ~j; j = E[j].nxt) { int u = E[j].u, w = E[j].w; if(vis[u] || u == fa) continue; get_rt(u, x); son[x] += son[u]; f[x] = max(f[x], son[u]); } f[x] = max(f[x], size - son[x]); if(f[x] &lt; f[root]) root = x;}vector&lt;int&gt; v;void get_dep(int x, int fa) { v.push_back(dep[x]); cnt[dep[x]%3]++; for(int j = head[x]; ~j; j = E[j].nxt) { int u = E[j].u, w = E[j].w; if(vis[u] || u == fa) continue; dep[u] = dep[x] + w; get_dep(u, x); }}void calc(int x, int op) { memset(cnt, 0, sizeof cnt); v.clear(); get_dep(x, 0); ll res0, res1, res2; res0 = res1 = res2 = 0; for(int p: v) { int offset = p%3; if(offset == 0) { res0 += op * (cnt[0] - 1) * p; res1 += op * cnt[1] * p; res2 += op * cnt[2] * p; } else if(offset == 1) { res0 += op * cnt[2] * p; res1 += op * cnt[0] * p; res2 += op * (cnt[1] - 1) * p; } else { res0 += op * cnt[1] * p; res1 += op * (cnt[2] - 1) * p; res2 += op * cnt[0] * p; } res0 %= MOD; res1 %= MOD; res2 %= MOD; } ans1 += res0; ans2 += res1; ans3 += res2; ans1 %= MOD; ans2 %= MOD; ans3 %= MOD;}void solve(int x) { dep[x] = 0; calc(x, 1); vis[x] = 1; for(int j = head[x]; ~j; j = E[j].nxt) { int u = E[j].u, w = E[j].w; if(vis[u]) continue; dep[u] = w; calc(u, -1); root = 0; size = son[u]; get_rt(u); solve(root); }}int main(int argc, char const *argv[]){ while(~scanf(\"%d\", &amp;n)) { memset(head, -1, sizeof head); memset(vis, 0, sizeof vis); E.clear(); tot = 0; int u, v, w; rep(i, 1, n-1) { scanf(\"%d %d %d\", &amp;u, &amp;v, &amp;w); u++; v++; add(u, v, w); add(v, u, w); } root = 0; f[0] = size = n; get_rt(1, 0); ans1 = ans2 = ans3 = 0; solve(root); ans1 = ans1 * 2 % MOD; ans2 = ans2 * 2 % MOD; ans3 = ans3 * 2 % MOD; ans1 = (ans1 + MOD) % MOD; ans2 = (ans2 + MOD) % MOD; ans3 = (ans3 + MOD) % MOD; printf(\"%lld %lld %lld\\n\", ans1, ans2, ans3); } return 0;}","link":"/2019/09/28/2019-ICPC-Shenyang-contest-online/"},{"title":"2019-ICPC-南京网络赛","text":"题目计蒜客 A. The beautiful values of the palace知识点：坐标映射，离散化，树状数组，离线查询 坐标映射找一下规律。（虽然我不太会找这个规律 1234567ll get_int(int n, int x, int y){ x = x - n/2 - 1; y = y - n/2 - 1; ll t = max(abs(x), abs(y)); if(x &gt;= y) return 1ll * n * n - 4 * t * t - 2 * t - x - y; else return 1ll * n * n - 4 * t * t + 2 * t + x + y;} 离散化和离线查询只离散化一维就行了，当然两个维度都离散化也是没有问题的。 假设只离散化x轴，那么我们对建点和查询操作进行x优先排序，扫描x轴，当操作的x与当前枚举的x相同时进行操作，优先建点，然后查询。这样是为了保证顺序。 查询的时候，相当于查询一个一维前缀和，用树状数组维护就可以了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124#include&lt;bits/stdc++.h&gt;#define rep(i, a, b) for(int i = (a); i &lt;= (int)(b); ++i)#define per(i, a, b) for(int i = (a); i &gt;= (int)(b); --i)#define debug(x) cerr &lt;&lt; #x &lt;&lt; ' ' &lt;&lt; x &lt;&lt; endl;using namespace std;typedef long long ll;const int MAXN = 1e5 + 7;const int MOD = 998244353;struct node{ int x, y, id; ll val; friend bool operator &lt;(const node &amp;a, const node &amp;b){ return a.x &lt; b.x; }}s[MAXN], need[MAXN * 4];struct ask{ int a, b, c, d;}op[MAXN];ll get_int(int n, int x, int y){ x = x - n/2 - 1; y = y - n/2 - 1; ll t = max(abs(x), abs(y)); if(x &gt;= y) return 1ll * n * n - 4 * t * t - 2 * t - x - y; else return 1ll * n * n - 4 * t * t + 2 * t + x + y;}int get_val(ll val){ int ans = 0; while(val){ ans += val%10; val /= 10; } return ans;}struct BIT { int e[MAXN], n; void clear(){rep(i, 0, n) e[i] = 0;} int lowbit(int x){return x &amp; (-x);} void add(int x, int v){ while(x &lt;= n){ e[x] += v; x += lowbit(x); } } int get(int x){ int ans = 0; while(x){ ans += e[x]; x -= lowbit(x); } return ans; }}bit;int hx[MAXN * 10], hy[MAXN * 10];int main() { int T; scanf(\"%d\", &amp;T); while(T--){ int n, m, p; scanf(\"%d %d %d\", &amp;n, &amp;m, &amp;p); vector&lt;int&gt; vx, vy; rep(i, 1, m){ scanf(\"%d %d\", &amp;s[i].x, &amp;s[i].y); s[i].val = get_val(get_int(n, s[i].x, s[i].y)); vx.push_back(s[i].x); vy.push_back(s[i].y); } int x1, y1, x2, y2; rep(i, 0, p-1){ scanf(\"%d %d %d %d\", &amp;x1, &amp;y1, &amp;x2, &amp;y2); vx.push_back(x1-1); vx.push_back(x2); vy.push_back(y1-1); vy.push_back(y2); need[i * 4 + 1] = node{x1-1, y1-1, i * 4 + 1}; need[i * 4 + 2] = node{x1-1, y2, i * 4 + 2}; need[i * 4 + 3] = node{x2, y1-1, i * 4 + 3}; need[i * 4 + 4] = node{x2, y2, i * 4 + 4}; op[i] = ask{i*4 + 1, i*4 + 2, i*4 + 3, i*4 + 4}; } sort(vx.begin(), vx.end()); vx.erase(unique(vx.begin(), vx.end()), vx.end()); sort(vy.begin(), vy.end()); vy.erase(unique(vy.begin(), vy.end()), vy.end()); rep(i, 0, vx.size()-1){hx[vx[i]] = i + 1;} rep(i, 0, vy.size()-1){hy[vy[i]] = i + 1;} rep(i, 1, m){ s[i].x = hx[s[i].x]; s[i].y = hy[s[i].y]; } rep(i, 0, p-1){ need[i * 4 + 1].x = hx[need[i * 4 + 1].x]; need[i * 4 + 1].y = hy[need[i * 4 + 1].y]; need[i * 4 + 2].x = hx[need[i * 4 + 2].x]; need[i * 4 + 2].y = hy[need[i * 4 + 2].y]; need[i * 4 + 3].x = hx[need[i * 4 + 3].x]; need[i * 4 + 3].y = hy[need[i * 4 + 3].y]; need[i * 4 + 4].x = hx[need[i * 4 + 4].x]; need[i * 4 + 4].y = hy[need[i * 4 + 4].y]; } sort(s + 1, s + 1 + m); sort(need + 1, need + 1 + 4 * p); bit.n = vy.size(); bit.clear(); int cur = 1, curs = 1; rep(i, 0, vx.size()){ while(curs &lt;= m &amp;&amp; s[curs].x == i){ bit.add(s[curs].y, s[curs].val); curs++; } while(cur &lt;= 4 * p &amp;&amp; need[cur].x == i){ need[cur].val = bit.get(need[cur].y); cur++; } } sort(need + 1, need + 1 + 4 * p, [](const node &amp;a, const node &amp;b){return a.id &lt; b.id;}); rep(i, 0, p-1){ printf(\"%lld\\n\", need[op[i].a].val + need[op[i].d].val - need[op[i].b].val - need[op[i].c].val); } } return 0;} B. super_log知识点：递归，欧拉函数，欧拉定理 扩展欧拉定理$$a^b \\equiv \\begin{cases} a^b &amp; b &lt; \\varphi(m) \\ a^{b \\bmod \\varphi(m) + \\varphi(m)} &amp; b \\ge \\varphi(m) \\ \\end{cases}\\bmod m​$$ 快速幂也不知道为什么，快速幂写成这样就可以直接递归求解了。 这其中一定隐藏了什么不为人知的数论之谜。 123456789101112int up(ll a, int mod){ return a &lt; mod ? a : a % mod + mod;}int qpow(int a, int b, int mod){ int res = 1; while(b){ if(b&amp;1) res = up(1ll * res * a, mod); a = up(1ll * a * a, mod); b &gt;&gt;= 1; } return res;} 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;bits/stdc++.h&gt;#define rep(i, a, b) for(int i = (a); i &lt;= (b); ++i)#define per(i, a, b) for(int i = (a); i &gt;= (b); --i)using namespace std;typedef long long ll;const int MAXN = 1e6 + 7;int pri[MAXN], tot;int phi[MAXN];bool mark[MAXN];void init(){ tot = 0; phi[1] = 1; for(int i = 2; i &lt;= 1000000; ++i){ if(!mark[i]){ phi[i] = i - 1; pri[++tot] = i; } for(int j = 1; j &lt;= tot; ++j){ int x = pri[j]; if(i * x &gt; 1000000) break; mark[i * x] = 1; if(i%x == 0){ phi[i*x] = phi[i] * x; break; } else { phi[i*x] = phi[i] * phi[x]; } } }}int up(ll a, int mod){ return a &lt; mod ? a : a % mod + mod;}int qpow(int a, int b, int mod){ int res = 1; while(b){ if(b&amp;1) res = up(1ll * res * a, mod); a = up(1ll * a * a, mod); b &gt;&gt;= 1; } return res;}int solve(int a, int b, int m){ //calculate a^a^...^a mod m // |&lt;- b -&gt;| if(!b || m == 1) return 1; return qpow(a, solve(a, b-1, phi[m]), m);}int main(){ init(); int T, a, b, m; scanf(\"%d\", &amp;T); while(T--){ scanf(\"%d %d %d\", &amp;a, &amp;b, &amp;m); printf(\"%d\\n\", solve(a, b, m) % m); } return 0;}","link":"/2019/09/05/2019-icpc-nanjing/"},{"title":"2019-icpc-徐州网赛","text":"题目2019-icpc-徐州网赛 手速场，都是一些很经典的题目。 重新思考了一下二维偏序究竟是什么。 A. Who is better?生硬的套了两个知识点，扩展中国剩余定理和Fibonacci博弈。 套个板子就完事了。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849def egcd(a, b): \"\"\"扩展欧几里得\"\"\" if 0 == b: return 1, 0, a x, y, q = egcd(b, a % b) x, y = y, (x - a // b * y) return x, y, q n = int(input())flag = False a1, r1 = map(int, input().split()) for _ in range(n-1): a2, r2 = map(int, input().split()) R = r2-r1 x, y, d = egcd(a1, a2) tmp = a2//d if R%d != 0: flag = True r1=((x*R//d)%tmp+tmp)%tmp*a1+r1 a1=a1*(a2//d) lcm = a1ans = (r1%lcm+lcm)%lcmif flag: print(\"Tankernb!\") exit(0)fac = [1, 2]cur = 2while True: tmp = fac[cur-1] + fac[cur-2] if tmp &gt; ans: break fac.append(tmp) cur += 1flag = Falsefor v in fac: if v == ans: flag = True breakif flag: print(\"Lbnb!\")else: print(\"Zgxnb!\") E. XKC’s basketball team一个比较有趣的题目。 考虑从后往前维护一个单调递增的队列，之所以这样维护是因为： 当 $i &lt; j$ 且 $a[i] &lt; a[j]$ 时 $a[i]$ 是没有任何用处的，因为它又小又靠前，在它前面的那些值如果比 $a[i]$ 小那么肯定也比 $a[j]$ 小，而且 $i &lt; j$ 所以肯定会选择 $j$ 而不是 $i$ 。 然后我们二分单调队列就能得到最先进入队列的满足的那个值的位置，最先进入队列的当然是原序列中最靠后的满足要求的值。 时间复杂度：$O(n \\cdot \\log n)$ 1234567891011121314151617181920212223242526272829303132333435#include &lt;bits/stdc++.h&gt;#define rep(i, a, b) for(int i = (a); i &lt;= (b); ++i)#define per(i, a, b) for(int i = (a); i &gt;= (b); --i)using namespace std;typedef long long ll;const int mod = 1e9+7;const int MAXN = 5e5 + 7;int a[MAXN], ans[MAXN];int main(int argc, char const *argv[]){ int n, m; scanf(\"%d %d\", &amp;n, &amp;m); rep(i, 1, n) scanf(\"%d\", &amp;a[i]); vector&lt;int&gt; v, vp; v.push_back(a[n]); vp.push_back(n); ans[n] = -1; per(i, n-1, 1){ auto it = lower_bound(v.begin(), v.end(), a[i]+m); if(it == v.end()){ ans[i] = -1; } else { int pos = it - v.begin(); pos = vp[pos]; ans[i] = pos - i - 1; } if(a[i] &gt; v.back()){ v.push_back(a[i]); vp.push_back(i); } } rep(i, 1, n) printf(\"%d%c\", ans[i], i == n?'\\n':' '); return 0;} I. query又是一道二维偏序的问题。 偏序关系是全序关系的子集。 全序关系是指对于一个集合，其中的所有对 $&lt;i, j&gt;$ 都会有这种关系，也就是两两可以比较，比如整数域上的大小关系。 偏序关系是指对于一个集合，其中存在一些（注意：不是所有）对 $&lt;i, j&gt;$ 有这种关系，也就是不需要两两可以比较，比如整数域上的整除关系。 偏序关系有严格偏序和非严格偏序两种，各有自己的三条基本性质。 回到这个问题，$min(p_i, p_j) = \\gcd (p_i, p_j)$ 相当于 $p_i, p_j$存在整除关系。显然 $n$ 个数的全排列中满足整除关系的对数小于 $n\\cdot \\log n$对。 我们先将所有的满足条件的对数直接暴力筛出来，然后就抽象成了这样一个问题： 给出一些点，查询在区间 $[l, r]$ 内点的数量。 这就是一个经典的二位偏序问题了，直接对一维排序，二维用树状数组维护一下就好了。 时间复杂度：$O(n\\cdot \\log n)​$ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;bits/stdc++.h&gt;#define rep(i, a, b) for(int i = (a); i &lt;= (b); ++i)#define per(i, a, b) for(int i = (a); i &gt;= (b); --i)#define debug(x) cerr &lt;&lt; #x &lt;&lt; ' ' &lt;&lt; x &lt;&lt; endl;using namespace std;typedef long long ll;const int mod = 1e9+7;const int MAXN = 2e5 + 7;int a[MAXN], id[MAXN];struct node{ int l, r, val, id; friend bool operator &lt;(const node &amp;a, const node &amp;b){ if(a.r == b.r) return a.l &lt; b.l; return a.r &lt; b.r; }}s[MAXN];struct BIT{ int e[MAXN], n; int lowbit(int x){return x&amp;-x;} void add(int x, int v){ while(x &lt;= n){ e[x] += v; x += lowbit(x); } } int get(int x){ int res = 0; while(x){ res += e[x]; x -= lowbit(x); } return res; }}bit;vector&lt;int&gt; v[MAXN];int main(int argc, char const *argv[]){ int n, m; scanf(\"%d %d\", &amp;n, &amp;m); rep(i, 1, n){ scanf(\"%d\", &amp;a[i]); id[a[i]] = i; } rep(i, 1, n){ for(int j = 2*a[i]; j &lt;= n; j += a[i]){ if(id[j] &lt; i) v[i].push_back(id[j]); else v[id[j]].push_back(i); } } rep(i, 1, m){ scanf(\"%d %d\", &amp;s[i].l, &amp;s[i].r); s[i].id = i; } sort(s + 1, s + 1 + m); bit.n = n; int cur = 1; rep(i, 1, n){ rep(j, 0, (int)v[i].size()-1){ bit.add(v[i][j], 1); } while(cur &lt;= m &amp;&amp; s[cur].r == i){ s[cur].val = bit.get(i) - bit.get(s[cur].l-1); cur++; } } sort(s + 1, s + 1 + m, [](const node &amp;a, const node &amp;b){return a.id &lt; b.id;}); rep(i, 1, m) printf(\"%d\\n\", s[i].val); return 0;} J. Random Access Iterator感觉这个题目属于很简单的树上递推的题目。 题目的意思就是从树的根结点出发，每次在节点的儿子中随机选择一个，递归，重复子节点个数次。 我们先一次 $DFS$ 更新出来子树的高度和节点的子节点树，$h[x]$ 和 $son[x]$。 首先当一个子节点子树的高度加一小于当前节点的高度的时候这个子节点是没用的，因为它更新不到最大值。 而如果可以的话就加上这个子树的递归求出最大值的概率。叶子节点概率为一。 形式化来说就是： 1234567891011function DFS(x) k &lt;- the number of sons of x if k is 0 do return 1 p &lt;- 0 for son of x do if h[x] equal to h[son] + 1 do p += DFS(son) p &lt;- p divided by k res &lt;- 1 - pow(1-p, k) return res 后半段的处理是基于这样一个原因： 假设节点取到最大值的概率为p，那么对于一个节点 $x​$ 有： $$p[x] = 1 - (1 - \\frac{\\sum_{son \\in sons[x]}p[son]}{|sons[x]|})^{|sons[x]|} $$ 就是这样一个公式。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;bits/stdc++.h&gt;#define rep(i, a, b) for(ll i = (a); i &lt;= (b); ++i)#define per(i, a, b) for(ll i = (a); i &gt;= (b); --i)#define debug(x) cerr &lt;&lt; #x &lt;&lt; ' ' &lt;&lt; x &lt;&lt; endl;using namespace std;typedef long long ll;const ll MAXN = 1e6 + 7;const ll mod = 1e9 + 7;ll qpow(ll a, ll b){ ll res = 1; while(b){ if(b&amp;1) res = 1ll * res * a % mod; a = 1ll * a * a % mod; b &gt;&gt;= 1; } res = res%mod + mod; return res%mod;}ll inv(ll x){return qpow(x, mod-2);}vector&lt;ll&gt; G[MAXN];ll cor[MAXN], son[MAXN];void dfs(ll x, ll fa = 0){ ll res = 0; for(ll p: G[x]){ if(p == fa) continue; dfs(p, x); res = max(res, cor[p]); son[x]++; } cor[x] = res + 1;}ll dfs2(ll x, ll fa = 0){ if(son[x] == 0) return 1; ll p = 0; for(ll pp: G[x]){ if(pp == fa) continue; if(cor[x] == cor[pp] + 1){ p += dfs2(pp, x); } } p = p * inv(son[x]) % mod; return (1 - qpow(1-p+mod, son[x]) + mod) % mod;}int main() { ll n; scanf(\"%lld\", &amp;n); ll u, v; rep(i, 1, n-1){ scanf(\"%lld %lld\", &amp;u, &amp;v); G[u].push_back(v); G[v].push_back(u); } dfs(1); printf(\"%lld\\n\", dfs2(1)); return 0;}","link":"/2019/09/09/2019-icpc-xuzhou-online-contest/"},{"title":"2019-蓝桥杯国赛","text":"碎碎念 Day1第一年没比赛，本来以为是需要取报道的，结果不用。也没有其他的安排，就去故宫了。下午还去了北大，自己瞎逛没见到图书馆。 Day2上午在宾馆宅了一上午，下午比赛。 比赛题目突变，暴力能过杯变成了暴力骗分杯。 DP、搜索很多，甚至还有一道复杂的数据结构，蓝桥杯真的转型了。 写的很差，对答案的时候发现就没写对几道题，大概三四十分，心想凉凉。 Day3早上出了成绩发现竟然国一，激动得不行。也发现蓝桥杯还是那么水，这都能国一。 早上的招聘会约了但是没起来没去，只去了下午的颁奖，本来以后国一还能有个U盘，结果什么都没有。 颁奖典礼是真的体面，表白民族大学的小姐姐。魔术师贼帅。蓝桥大气，羡慕国特笔记本+手机。 因为是晚上十点的车，颁完奖才四点多，又去逛了逛圆明园，当天下了雨，圆明园是真的好看。 完。","link":"/2019/05/30/2019-lanqiao-guosai/"},{"title":"CODEVS-2370-小机房的树","text":"题目CODEVS-2370-小机房的树 一道经典的LCA问题。 题解题目就是求$u,v$两点之间的最短距离，利用$lca$的性质可以在$O(log(n))$的时间内求出答案。 也就是$dis[u] + dis[v] - 2 * dis[lca(u, v)]$，其中 $dis[u]$ 数组表示从根节点到点 $u$ 的距离。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;bits/stdc++.h&gt;#define rep(i, a, b) for(int i = (a); i &lt;= (int)(b); ++i)#define per(i, a, b) for(int i = (a); i &gt;= (int)(b); --i)#define debug(x) cerr &lt;&lt; #x &lt;&lt; ' ' &lt;&lt; x &lt;&lt; endl;using namespace std;typedef long long ll;typedef pair&lt;int, int&gt; pii;const int MAXN = 2e5 + 7;int dep[MAXN], dis[MAXN], f[MAXN][20];vector&lt;pii&gt; G[MAXN];void dfs(int x, int last = 0, int fa = -1) { f[x][0] = fa; dep[x] = dep[fa] + 1; dis[x] = dis[fa] + last; for(int i = 1; (1&lt;&lt;i) &lt;= dep[x]; ++i){ f[x][i] = f[f[x][i-1]][i-1]; } rep(i, 0, G[x].size()-1){ pii p = G[x][i]; if(p.first == fa) continue; dfs(p.first, p.second, x); }}int lca(int u, int v) { if(dep[u] &lt; dep[v]) swap(u, v); int dif = dep[u] - dep[v]; per(i, 20, 0){ if((1&lt;&lt;i) &lt;= dif){ dif -= (1&lt;&lt;i); u = f[u][i]; } } if(u == v) return u; per(i, 20, 0){ if(dep[u] &gt;= (1&lt;&lt;i) &amp;&amp; f[u][i] != f[v][i]){ u = f[u][i]; v = f[v][i]; } } return f[u][0];}int main() { int n; scanf(\"%d\", &amp;n); int u, v, c; rep(i, 1, n-1){ scanf(\"%d %d %d\", &amp;u, &amp;v, &amp;c); G[u].push_back(make_pair(v, c)); G[v].push_back(make_pair(u, c)); } dfs(0); int T; scanf(\"%d\", &amp;T); while(T--){ scanf(\"%d %d\", &amp;u, &amp;v); printf(\"%d\\n\", dis[u] + dis[v] - 2 * dis[lca(u, v)]); } return 0;}","link":"/2019/08/06/CODEVS-2370-小机房的树/"},{"title":"Codeforces-1207-F","text":"题目题目链接 分析以前从来没有做过这种问法的题目，觉得很有意思。 本来想的是可不可以把操作转化一下改到线段树上去，结果没有想到，好像也真的不行。 然后就灵光一闪发现当询问的 $x$ ，比较大的时候暴力查询也是跑的飞快，于是就开始想大数据暴力查询。 小数据可以发现直接维护一个二维数组 $sum[x][y]$ 表示答案。 然后大小的分隔本来以为就是 $sqrt(5 \\cdot 10^5)$ ，但其实并不是，因为这道题目并不是传统意义上的分块。 而是一种用空间换时间的方法，当 $x$ 比较大的时候我们很难去更新 $sum[x][y]$，也开不了那么大的空间。 思考一下，假如分割点是 $p$，那么对于更新操作来说，因为我们需要更新所有的 $sum[x][y]$ 以便查询小数据。 所以更新的复杂度就是：$O(p)$。 对于查询操作来说：如果查询的 $x \\leq p$ ，那么我们可以直接输出答案也就是 $O(1)$。 如果查询的 $ x &gt; p$，那么我们可以暴力查询，复杂度是：$O(\\frac{5\\cdot 10^5}{x})$。具体复杂度是：$\\Omega(\\frac{5\\cdot 10^5}{p}) - O(1)$。 分析一下 $p$ 取 300~1000 都是可以的。 代码1234567891011121314151617181920212223242526272829303132333435363738#include &lt;bits/stdc++.h&gt;#define rep(i, a, b) for(int i = (a); i &lt;= (b); ++i)#define per(i, a, b) for(int i = (a); i &gt;= (b); --i)using namespace std;typedef long long ll;const int mod = 1e9+7;const int MAXN = 5e5 + 7;int a[MAXN];int sum[1001][1001];int main(int argc, char const *argv[]){ int q; scanf(\"%d\", &amp;q); int op, x, y; while(q--){ scanf(\"%d %d %d\", &amp;op, &amp;x, &amp;y); if(op == 1){ a[x] += y; for(int i = 1; i &lt;= 1000; ++i){ sum[i][x%i] += y; } } else { if(x &lt;= 1000){ printf(\"%d\\n\", sum[x][y]); } else { int res = 0; while(y &lt;= 500000){ res += a[y]; y += x; } printf(\"%d\\n\", res); } } } return 0;}","link":"/2019/08/29/Codeforces-1207-F/"},{"title":"拉格朗日乘数法","text":"简单来说，拉格朗日乘子法可以解决$f(\\hat x)$在一些限制条件$g_k(\\hat x) = c_k$下的极值。 Mushroom ScientistsLink Prove本题题意就是给了一个函数$f(x,y,z) = x^a + y^b + z^c$，求这个函数在约束条件$g(x,y,z) = x + y + z - S$下的最大值。 首先，设拉格朗日函数： $$L(x,y,z,\\lambda) = f - \\lambda \\cdot g$$ 然后对各个变量求偏导数： $$\\frac{\\partial L}{\\partial x} = y^b\\cdot z^c \\cdot ax^{a-1} - \\lambda​$$ $$\\frac{\\partial L}{\\partial y} = x^a\\cdot z^c \\cdot by^{b-1} - \\lambda​$$ $$\\frac{\\partial L}{\\partial z} = x^a\\cdot y^b \\cdot cz^{c-1} - \\lambda​$$ $$\\frac{\\partial L}{\\partial \\lambda} = x + y + z - S​$$ 可以解出： $$\\frac{x}{a} = \\frac{y}{b} = \\frac{z}{c}$$ 所以： $$x = \\frac{S\\cdot a}{a+b+c}, y = \\frac{S\\cdot b}{a+b+c}, z = \\frac{S\\cdot c}{a+b+c}​$$ 代码12345678910111213141516171819202122#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;iomanip&gt;using namespace std; const int MAXN = 1e5 + 7;const int mod = 1e9 + 7;typedef long long ll; int main(){ cout &lt;&lt; fixed; int s; int a, b, c; cin &gt;&gt; s &gt;&gt; a &gt;&gt; b &gt;&gt; c; if(a + b + c == 0){ cout &lt;&lt; 0 &lt;&lt; ' ' &lt;&lt; 0 &lt;&lt; ' ' &lt;&lt; 0 &lt;&lt; endl; } else { cout &lt;&lt; setprecision(12) &lt;&lt; (1.0*s*a/(a+b+c)) &lt;&lt; ' ' &lt;&lt; (1.0*s*b/(a+b+c)) &lt;&lt; ' ' &lt;&lt; (1.0*s*c/(a+b+c)) &lt;&lt; endl; } return 0;} Samantha and Portfolio ManagementLink Prove约束条件下的极值问题，可以用拉格朗日乘子法解决。 约束条件：$$g(\\boldsymbol w) = \\sum_{i=1}^{n}{w_i} - 1$$ 极值方程： $$f(\\boldsymbol w) = \\sum_{i=1}^{n}{(w_i^2 \\cdot \\sigma_i^2)} = \\sum_{i=1}^{n}(w_i^2 \\cdot \\frac{1}{i})$$ 拉格朗日方程： $$L(\\boldsymbol w, \\lambda) = f(\\boldsymbol w) - \\lambda \\cdot g(\\boldsymbol w)​$$ 分别对 $\\boldsymbol w , \\lambda​$ 求导： $$\\frac{\\partial(L)}{\\partial(w_i)} = 2 \\frac{w_i}{i} - \\lambda$$ $$\\frac{\\partial(L)}{\\partial(\\lambda)} = g(\\boldsymbol{w}) = 1 - \\sum_{i=1}^{n}{w_i}​$$ 则有： $$w_i = \\frac{\\lambda \\cdot i}{2}$$ 移项： $$\\sum_{i=1}^{n}{w_i} = \\frac{\\lambda \\cdot \\sum_{i=1}^{n}(i)}{2} = \\frac{\\lambda \\cdot n(n+1)}{4} = 1$$ 则：$$\\lambda = \\frac{4}{n(n+1)}​$$ $$w_i = \\frac{\\lambda \\cdot i}{2} = \\frac{2\\cdot i}{n(n+1)}$$ 所以： $$V = \\sum_{i=1}^{n}{w_i^2\\times \\sigma_i^2 } = \\sum_{i=1}^{n}{\\frac{4\\cdot i}(n^2(n+1)^2)} = \\frac{1}{n(n+1)}$$ $$E = \\sum_{i=1}^{n}{w_i \\times \\bar r_i} = \\sum_{i=1}^{n}\\frac{(2\\cdot i \\cdot \\bar r_i)}{n(n+1)}$$ 然后就可以愉快的$O(n)​$解决了。 代码1234567891011121314151617181920212223#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXN = 1e5 + 7;int r[MAXN];void print(long long a, long long b) { long long g = __gcd(a, b); a /= g; b /= g; printf(\"%d %d\\n\", a, b);}int main(){ int n; scanf(\"%d\", &amp;n); long long sum = 0; for(int i = 1; i &lt;= n; ++i) { scanf(\"%d\", r+i); sum += 1LL * i * r[i]; } print(2 * sum, 1LL * n * (n+1)); print(2LL, n * (n+1)); return 0;} 参考1.Wikipedia-Lagrange-Multiplier2.http://jermmy.xyz/2017/07/27/2017-7-27-understand-lagrange-multiplier/","link":"/2019/07/19/Lagrange-Multiplier/"},{"title":"ZJOI2008-骑士","text":"题目luoguP2607 bzoj1040 题解基环树就是一颗多了一条边的树，多了这条边，就会产生一个环。 考虑找到这个环上的任意一条边，断掉这条边，然后图形就又变回了树。（可以证明，断环上的哪条边对结果并没有影响） 然后分别都被断掉的这条边的两个端点u、v，做树形动规。 $dp[i][0/1]$表示取不取第$i$个点的最大值。 这和luoguP1352，没有上司的舞会一样。 则这颗基环树的最大值为$max(dp[u][0], dp[v][0])$，当然因为树形动规的特点，一次动规是不能同时求出这两个值的，因此要分别对u、v进行动规。 ==两个注意事项== 非常重要的一点是，两个骑士可能互相憎恨，因此会存在重边，需要特判。 记得开long long。 处理重边的方法： 按照我的建图方式，如果存在重边&lt;u，v&gt;，那么u的可到点集合中会出现两次v。 根据这个特点就可以进行特判了。 另外，这份代码在最后一个测试点TLE了。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273// luogu-judger-enable-o2#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef pair&lt;int, int &gt; pii;inline ll qpow(ll a,ll b,ll mod){ll res=1;while(b){if(b&amp;1)res = (res*a)%mod;a=(a*a)%mod;b&gt;&gt;=1;}return res;}const int mod = 1e9 + 7;const int MAXN = 1e6 + 7;int curx, cury;bool vis[MAXN];vector&lt;int&gt; G[MAXN];ll dp[MAXN][2];int val[MAXN];void dfs(int x, int fa){ if(vis[x]){ curx = x; cury = fa; return; } vis[x] = 1; for(int i = 0; i &lt; G[x].size(); ++i){ int u = G[x][i]; if(u == fa) continue; dfs(u, x); }}void go(int x, int fa){ dp[x][0] = 0; dp[x][1] = val[x]; for(int i = 0; i &lt; G[x].size(); ++i){ int u = G[x][i]; if(u == fa) continue; if(x == curx &amp;&amp; u == cury) continue; if(u == curx &amp;&amp; x == cury) continue; go(u, x); dp[x][0] += max(dp[u][0], dp[u][1]); dp[x][1] += dp[u][0]; }}int main(){ #ifndef ONLINE_JUDGE freopen(\"in.txt\", \"r\", stdin); freopen(\"out.txt\", \"w\", stdout); #endif int n, x; scanf(\"%d\", &amp;n); for(int i = 1; i &lt;= n; ++i){ scanf(\"%d %d\", &amp;val[i], &amp;x); G[x].push_back(i); G[i].push_back(x); } ll res = 0, tmp; for(int i = 1; i &lt;= n; ++i){ if(vis[i]) continue; dfs(i, 0); // cout &lt;&lt; curx &lt;&lt; ' ' &lt;&lt; cury &lt;&lt; endl; // cout &lt;&lt; count(G[curx].begin(), G[curx].end(), cury) &lt;&lt; endl; if(count(G[curx].begin(), G[curx].end(), cury) == 2){ go(curx, 0); go(cury, 0); res += max(dp[curx][0] + dp[cury][1], dp[curx][1] + dp[cury][0]); continue; } go(curx, 0); tmp = dp[curx][0]; go(cury, 0); tmp = max(tmp, dp[cury][0]); res += tmp; } printf(\"%lld\\n\", res); return 0;}","link":"/2019/06/11/ZJOI2008/"},{"title":"SCOI2005-骑士精神","text":"题目luoguP2324 题解首先很容易想到的是，应该用空格去跳，而不是用马，因为马的数量太多了。 第二，因为搜索状态太多，考虑用使用IDDFS + A*，有一个比较简单的估价函数就是当前状态和终态的不同元素的个数。 考虑到折返是没有任何价值的，因此在搜索过程中保留上一次搜索的方向，在本次搜索中如果是折返操作则跳过。 未跳过折返时时间：1509ms，跳过后：66ms。 可以看出来优化还是很巨大的。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566// luogu-judger-enable-o2#include&lt;bits/stdc++.h&gt;using namespace std;const int n = 5;string final = \"111110111100*110000100000\";int dx[] = {1, 1, 2, 2, -2, -2, -1, -1};int dy[] = {2, -2, 1, -1, 1, -1, 2, -2};int dif(string s){ int res = 0; for(int i = 0; i &lt; n*n; ++i){ if(s[i] != final[i]) res++; } return res;}string s;int lim;bool suc = 0;void dfs(int cur, int last){ if(cur == lim){ //是否搜索成功 if(dif(s) == 0){ suc = 1; } return; } if(suc) return; //最优解剪枝 if(cur + max(0, dif(s) - 1) &gt; lim) return; //当前值 + 最优值 &gt; 迭代深度 int f = s.find('*'); int x = f/n, y = f%n; int xx, yy; for(int i = 0; i &lt; 8; ++i){ if(i + last == 7) continue; //防止回头，优化了很多 xx = x + dx[i]; yy = y + dy[i]; if(xx &gt;= 0 &amp;&amp; xx &lt; n &amp;&amp; yy &gt;= 0 &amp;&amp; yy &lt; n){ swap(s[xx*n + yy], s[x*n + y]); dfs(cur+1, i); swap(s[xx*n + yy], s[x*n + y]); //回溯 } }}int main(){ int T; cin &gt;&gt; T; while(T--){ s = \"\"; string tmp; for(int i = 1; i &lt;= n; ++i){ cin &gt;&gt; tmp; s += tmp; } if(dif(s) == 0) cout &lt;&lt; 0 &lt;&lt; endl; else{ suc = 0; for(int i = 1; i &lt;= 15; ++i){ lim = i; dfs(0, 9); if(suc){ cout &lt;&lt; i &lt;&lt; endl; break; } } if(!suc) cout &lt;&lt; -1 &lt;&lt; endl; } } return 0;}","link":"/2019/06/11/SCOI2005/"},{"title":"BZOJ-2956-模积和","text":"题目BZOJ-2056 一道有点复杂的数论分块。 公式推导所求即为： $$\\sum_{i=1}^{n}\\sum_{j=1}^{m}{(n \\bmod i )\\cdot (m\\bmod j)(i \\neq j)}​$$ 先不管$i\\neq j$的情况:$$\\sum_{i=1}^{n}(\\sum_{j=1}^{m}{(n\\bmod i) \\cdot (m\\bmod j)})$$ $$\\sum_{i=1}^{n}\\sum_{j=1}^{m}{(n-i\\lfloor \\frac{n}{i} \\rfloor)(m-j\\lfloor \\frac{m}{j} \\rfloor)}​$$ $$\\sum_{i=1}^{n}\\sum_{j=1}^{m}{(n m - n\\cdot j\\lfloor \\frac{m}{j} \\rfloor - m\\cdot i\\lfloor \\frac{n}{i} \\rfloor + ij\\lfloor \\frac{n}{i} \\rfloor \\lfloor \\frac{m}{j} \\rfloor)}​$$ $$n^2m^2 - n^2\\sum_{j=1}^{m}{j\\lfloor \\frac{m}{j} \\rfloor} - m^2\\sum_{i=1}^{n}i\\lfloor \\frac{n}{i} \\rfloor + \\sum_{i=1}^{n}i\\lfloor \\frac{n}{i} \\rfloor\\sum_{i=1}^{m}j\\lfloor \\frac{m}{j} \\rfloor​$$ 然后在讨论$i = j​$的情况: $$\\sum_{i=1}^{min(n, m)}{(n\\bmod i)\\cdot (m\\bmod i)}$$ $$\\sum_{i=1}^{min(n, m)}{(n - i\\lfloor \\frac{n}{i} \\rfloor)(m - i\\lfloor \\frac{m}{i} \\rfloor)} ​$$ $$\\sum_{i=1}^{min(n, m)}{n m - m\\cdot i\\lfloor \\frac{n}{i} \\rfloor - n\\cdot i\\lfloor \\frac{m}{i} \\rfloor + i^2 \\lfloor \\frac{n}{i} \\rfloor \\lfloor \\frac{m}{i} \\rfloor} ​$$ 然后就可以愉快的分块了。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576/************************************************************** Problem: 2956 User: Dicer Language: C++ Result: Accepted Time:184 ms Memory:1292 kb****************************************************************/ #include&lt;bits/stdc++.h&gt;#define rep(i, a, b) for(int i = (a); i &lt;= (int)(b); ++i)#define per(i, a, b) for(int i = (a); i &gt;= (int)(b); --i)#define debug(x) cout &lt;&lt; #x &lt;&lt; ' ' &lt;&lt; x &lt;&lt; endl;using namespace std; typedef long long ll;const int MAXN = 1e5 + 7;const int MOD = 19940417;const int INV = 3323403; ll cal(ll n){ ll ans = 0; for(ll i = 1, j; i &lt;= n; i = j + 1){ j = n / ( n / i); ans += (i + j) * (j - i + 1) / 2 * (n / i); ans %= MOD; } return ans;}ll cal(ll n, ll k){ ll ans = 0; for(ll i = 1, j; i &lt;= k; i = j + 1){ j = min(k, n / ( n / i)); ans += (i + j) * (j - i + 1) / 2 * (n / i); ans %= MOD; } return ans;} ll sum(ll n){ return n * (n + 1) % MOD * (2 * n + 1) % MOD * INV % MOD;} ll cal(ll n, ll m, ll k){ ll ans = 0; for(ll i = 1, j; i &lt;= k; i = j + 1){ j = min(k, min(n / (n / i), m / (m / i))); ans += (sum(j) - sum(i-1)) * (n/i) % MOD * (m/i) % MOD; ans %= MOD; } return ans;} ll mul(ll a, ll b){ a %= MOD; b %= MOD; return a * b % MOD;} int main(){ ll n, m, k; scanf(\"%lld%lld\", &amp;n, &amp;m); k = min(n, m); long long ans = 0; ans += mul(n * n, m * m); ans -= mul(n * n, cal(m)); ans -= mul(m * m, cal(n)); ans += mul(cal(n), cal(m)); ans = ((ans % MOD) + MOD) % MOD; ans -= mul(k, n * m); ans += mul(n, cal(m, k)); ans += mul(m, cal(n, k)); ans -= cal(n, m, k); ans = ((ans % MOD) + MOD) % MOD; printf(\"%lld\\n\", ans); return 0;}","link":"/2019/08/06/bzoj-2956/"},{"title":"Codeforces-568-G1","text":"题目hpuoj-74 codeforces-568-G1 题解两个题目都是状压DP，有一定的相似之处，放在一起写。 第一题显然，对于每个宿舍楼内部的宿舍来说，当顺序固定了以后，可以简单的通过贪心得到最少抗议的人数。 那么，我们的主要问题就变成了，求解宿舍楼安装空调最合适的顺序。 定义$dp[sta]$表示状态为$sta$时的最少抗议人数，$cost[i][j]$表示第$i$幢寝室楼第$j​$个空调的贪心值。 那么我们可以这样更新： 1234567for sta := 0 to (1&lt;&lt;n)-1 do cal = sta.count(1) for nex := 0 to n-1 do if (sta&gt;&gt;nex)&amp;1 then continue else dp[sta|1&lt;&lt;nex] = min(dp[sta|1&lt;&lt;nex], dp[sta] + cost[nex][cal+1]) 结果就是$dp[(1&lt;&lt;n)-1] $。 这样更新的理由是： 对于一个状态$sta$，用1表示宿舍楼已经被安排过位置了，0表示还没有安排，统计一下1的个数就能知道在这个状态下，下一个宿舍楼是第几个被装的，而且这个宿舍楼之前一定是没有装过。 例如： $n = 4, sta = 1001$，下一个要装第三个宿舍楼，而二号、三号宿舍楼还没有装。 因此可以更新到$sta = 1101, 1011$这两个状态。 第二题方法一定义$dp[cap][sta][last]$表示当前总和为$cap$，状态为$sta$，最后一首歌的类型为$last$，然后直接维护更新就好了。 时间复杂度：O(T*n*2^n) 方法二定义$dp[sta][last]$表示当前状态为$sta$，最后一首歌的类型为$last$，进行一下更新： 12345678for sta := 0 to (1&lt;&lt;n)-1 do for i := 1 to n do if (sta&gt;&gt;i)&amp;1 then continue for type := 1 to 3 do if type == last[i] then continue dp[sta|1&lt;&lt;(i-1)][last[i]] += dp[sta][type] 这样就能得到所有的情况，但是不一定每一种情况的$cap$都是$T$，所以我们在求和的时候进行判断： 12345678910sum = 0for sta := 0 to (1&lt;&lt;n)-1 do cap = 0 for i := 1 to n do if (sta&gt;&gt;i)&amp;1 then cap += t[i] if cap == T then for type := 1 to 3 do sum += dp[sta][type] 时间复杂度：O(n*2^n) 代码第一题123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef pair&lt;int, int &gt; pii;inline ll qpow(ll a,ll b,ll mod){ll res=1;while(b){if(b&amp;1)res = (res*a)%mod;a=(a*a)%mod;b&gt;&gt;=1;}return res;}const int mod = 1e9 + 7;const int MAXN = 2e5 + 7;int dp[1&lt;&lt;23];int f[23][2333];int a[23][23];int main(){ #ifndef ONLINE_JUDGE freopen(\"in.txt\", \"r\", stdin); freopen(\"out.txt\", \"w\", stdout); #endif int n, m; cin &gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt;= n; ++i){ for(int j = 1; j &lt;= m; ++j){ cin &gt;&gt; f[i][j]; } sort(f[i]+1, f[i]+1+m); } for(int i = 1; i &lt;= n; ++i){ for(int j = 1; j &lt;= n; ++j){ int cur = (j-1)*m + 1, res = 0; for(int k = 1; k &lt;= m; ++k){ if(f[i][k] &gt;= cur){ cur++; } else res++; } a[i][j] = res; } } memset(dp, 0x3f, sizeof dp); dp[0] = 0; function&lt;int(int)&gt; cal = [&amp;](int x){ int res = 0; while(x){ res += x&amp;1; x &gt;&gt;= 1; } return res; }; for(int i = 0; i &lt; (1&lt;&lt;n); ++i){ int cur = cal(i) + 1; for(int j = 0; j &lt; n; ++j){ if((i&gt;&gt;j)&amp;1) continue; dp[i|1&lt;&lt;j] = min(dp[i|1&lt;&lt;j], dp[i] + a[j+1][cur]); } } cout &lt;&lt; dp[(1&lt;&lt;n)-1] &lt;&lt; endl; return 0;} 第二题方法一12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef pair&lt;int, int &gt; pii;inline ll qpow(ll a,ll b,ll mod){ll res=1;while(b){if(b&amp;1)res = (res*a)%mod;a=(a*a)%mod;b&gt;&gt;=1;}return res;}const int mod = 1e9 + 7;const int MAXN = 2e5 + 7;int t[16], g[16];int dp[226][1&lt;&lt;15][3];int main(){ #ifndef ONLINE_JUDGE freopen(\"in.txt\", \"r\", stdin); freopen(\"out.txt\", \"w\", stdout); #endif int n, m; cin &gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt;= n; ++i){ cin &gt;&gt; t[i] &gt;&gt; g[i]; g[i]--; } dp[0][0][0] = 1; dp[0][0][1] = 1; dp[0][0][2] = 1; for(int i = 0; i &lt;= m; ++i){ for(int j = 0; j &lt; (1&lt;&lt;n); ++j){ for(int k = 0; k &lt; n; ++k){ if((j&gt;&gt;k)&amp;1) continue; if(i+t[k+1] &gt; m) continue; for(int type = 0; type &lt; 3; ++type){ if(type == g[k+1]) continue; // cout &lt;&lt; i+t[k+1] &lt;&lt; ' ' &lt;&lt; (j|1&lt;&lt;k) &lt;&lt; ' ' &lt;&lt; g[k+1] &lt;&lt; endl; dp[i+t[k+1]][j|1&lt;&lt;k][g[k+1]] += dp[i][j][type]; dp[i+t[k+1]][j|1&lt;&lt;k][g[k+1]] %= mod; } } } } ll res = 0; for(int i = 0; i &lt; (1&lt;&lt;n); ++i){ for(int j = 0; j &lt; 3; ++j){ res += dp[m][i][j]; res %= mod; } } cout &lt;&lt; res*qpow(2, mod-2, mod)%mod &lt;&lt; endl; return 0;} 方法二1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef pair&lt;int, int &gt; pii;inline ll qpow(ll a,ll b,ll mod){ll res=1;while(b){if(b&amp;1)res = (res*a)%mod;a=(a*a)%mod;b&gt;&gt;=1;}return res;}const int mod = 1e9 + 7;const int MAXN = 2e5 + 7;int t[16], g[16];int dp[1&lt;&lt;16][3];int main(){ #ifndef ONLINE_JUDGE freopen(\"in.txt\", \"r\", stdin); freopen(\"out.txt\", \"w\", stdout); #endif int n, m; cin &gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt;= n; ++i){ cin &gt;&gt; t[i] &gt;&gt; g[i]; } dp[0][1] = dp[0][2] = dp[0][3] = 1; for(int i = 0; i &lt; (1&lt;&lt;n); ++i){ for(int j = 0; j &lt; n; ++j){ if((i&gt;&gt;j)&amp;1) continue; for(int k = 1; k &lt;= 3; ++k){ if(k == g[j+1]) continue; dp[i|1&lt;&lt;j][g[j+1]] += dp[i][k]; dp[i|1&lt;&lt;j][g[j+1]] %= mod; } } } ll res = 0; for(int i = 0; i &lt; (1&lt;&lt;n); ++i){ for(int j = 1; j &lt;= 3; ++j){ int tmp = 0; for(int k = 0; k &lt; n; ++k){ if((i&gt;&gt;k)&amp;1){ tmp += t[k+1]; } } if(tmp == m){ res += dp[i][j]; res %= mod; } } } cout &lt;&lt; res*qpow(2, mod-2, mod)%mod &lt;&lt; endl; return 0;}","link":"/2019/06/24/codeforces-568-G1/"},{"title":"Codeforces-622-F","text":"题目F. The Sum of the k-th Powers 题解设$F(n) = \\sum _{i=1}^n{i^k} $，当k很小的时候，可以找到一些通项公式，比如：当$k= 1 $时，$F(n) = \\frac{(n \\cdot (n+1))}{2} $，当$k=2 $时，$F(n)= \\frac{n \\cdot \\ (2 \\cdot n + 1) \\cdot (n+1)}{6} $。 可以发现，$F(n)$实际上是一个$k+1 $次多项式函数。 因此，我们就可以使用拉格朗日插值法来推导了。 确定一个k+1次多项式需要k+2个点，我们很容易通过打表得到$F(1) \\sim F(k+2)$的值。 然后代入插值公式： $$F(n) = \\sum_{i=1}^{k+2}F(i) \\times P(i) $$ $$P(i) = \\prod_{j=1, j \\neq i}^{k+2}\\frac{n-j}{i-j}​$$ 所以 $$F(n) = \\sum_{i=1}^{k+2}F(i) \\times \\prod_{j=1, j \\neq i}^{k+2}\\frac{n-j}{i-j} \\ = \\sum_{i=1}^{k+2}F(i) \\times \\frac{\\prod_{j=1, j \\neq i}^{k+2}n-j}{\\prod_{j=1, j \\neq i}^{k+2}{i-j}}​$$ 但是这个公式的复杂度时$O(k^2)​$的，我们再优化一下。 设$T = \\prod_{j=1}^{k+2}{n-j}$，则 $$\\prod_{j=1, j \\neq i}^{k+2}n-j = \\frac{T}{n-i}​$$ 对于$\\prod_{j=1, j \\neq i}^{k+2}{i-j}​$，我们将它分成$i\\lt j​$和$i\\gt j​$两部分来考虑， $$\\prod_{j=1, j \\neq i}^{k+2}{i-j} = (i-1)!\\times(k+2-i)!\\times (-1)^{k+2-i}​$$ 带入原式，得： $$F(n) = \\sum_{i=1}^{k+2}(F(i)\\times\\frac{T}{n-i}\\times\\frac{1}{(i-1)!\\times(k+2-i)!\\times (-1)^{k+2-i}})​$$ 至此，我们可以通过打表的方式，在$O(k)$时间内得到$F(n)$了。 注意当$n \\leq k+2$时，该公式时不适用的，因为$T$会为$0$。 但是我们可以直接通过$F(n) = \\sum _{i=1}^n{i^k} $计算。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465/*--------------------------------- @Author: Dicer @DateTime: 2019-06-18 10:16:23---------------------------------*/#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef pair&lt;int, int&gt; pii;inline ll qpow(ll a,ll b,ll mod){ll res=1;while(b){if(b&amp;1)res = (res*a)%mod;a=(a*a)%mod;b&gt;&gt;=1;}return res;}const double eps = 1e-8;const int INF = 0x3f3f3f3f;const int mod = 1e9+7;const int MAXN = 1e6 + 7;ll F[MAXN], fac[MAXN], T;int n, k;ll inv(ll x){ return qpow(x, mod-2, mod);}void init(){ F[1] = 1; for(int i = 2; i &lt;= k+2; ++i){ F[i] = F[i-1] + qpow(i, k, mod); F[i] %= mod; } fac[0] = 1; for(int i = 1; i &lt;= k+2; ++i){ fac[i] = fac[i-1] * i; fac[i] %= mod; } T = 1; for(int i = 1; i &lt;= k+2; ++i){ T *= n - i; T %= mod; }}void solve(){ if(n &lt;= k+2){ ll res = 0; for(int i = 1; i &lt;= n; ++i){ res += qpow(i, k, mod); res %= mod; } cout &lt;&lt; res &lt;&lt; endl; return; } ll res = 0; for(int i = 1; i &lt;= k+2; ++i){ res += F[i] * T % mod * inv(n-i) % mod * inv(fac[i-1]) %mod * inv(fac[k+2-i]) %mod * ((k-i)%2 == 0?1:-1) %mod; res += mod; res %= mod; } cout &lt;&lt; res &lt;&lt; endl;}int main(int argc, char const *argv[]){ cin &gt;&gt; n &gt;&gt; k; init(); solve(); return 0;} Reference 本文题图由User:Glosser.ca - Self-made, based on Image:Lagrangepolys.png，CC BY-SA 3.0，https://commons.wikimedia.org/w/index.php?curid=5538041 参考文章 LaTex","link":"/2019/06/18/codeforces-622-F/"},{"title":"hexo博客搭建总结","text":"序言之前使用jekyll在github上搭建了一个博客。但是，原博客不支持归档和搜索功能，主题也不是特别喜欢，于是决定重新搭建自己的博客站点。这次放弃了jekyll，使用hexo搭建。主要原因是hexo支持很多插件，且性能强悍。(相中了一个特别好看的主题)。 背景本文代码均基于阿里云Centos7服务器，Manjaro Linux客户端，与hexo引擎。 选择主题在搭建博客之前当然要选择一个自己喜欢的主题了。 可以在hexo的主题官方上挑选一个。戳我 注意挑选的时候不仅要看颜值，还要看一下自己需要的功能这个主题是否支持，当然如果你自己会添加插件，那就挑你最喜欢的就好了。 客户机配置安装Git 下载Git. 修改用户名和邮箱。 12345# 将此处的&quot;yourname&quot;替换成自己的用户名git config --global user.name &quot;yourname&quot;# 将此处的&quot;youremail&quot;替换成自己的邮箱git config --global user.email &quot;youremail&quot; 创建SSH钥匙对 检查是否存在钥匙对。 $ cd ~/.ssh 若没有钥匙对，则创建钥匙对。 $ ssh-keygen -t rsa -C “youremail” 安装Nodejs 使用命令行下载Nodejs。 检查是否下载完成。 $ node -v $ npm -v 安装Hexo框架 使用npm下载hexo $ npm install -g hexo-cli 因为一下原因，npm的下载速度十分感人，建议更换 选择一个你想要存放文件的文件夹，初始化blog。 $ hexo init blog 初始化完毕之后，打开博客根目录的package.json文件，在dependencies的配置中，追加一项：&quot;hexo-deployer-git&quot;: &quot;^0.3.1&quot; 运行hexo $ hexo s 然后在浏览器输入：｀localhost:4000｀，如果出现hexo的界面就说明已经搭建成功了。 如果有包缺失，根据提示下载相应的包，再次尝试即可。 服务端配置首先，进行服务端的系统更新。 $ yum update -y 更新完系统后，输入一下代码查看系统版本。 $ cat /etc/centos-release 安装Nginx安装Nginx分为以下几步。第一，配置Nginx官方源。第二，安装Nginx。第三，配置Nginx配置文件。1、配置Nginx官方源输入以下代码，新建一个文件以配置Nginx源 1$ vi /etc/yum.repos.d/nginx.repo 在打开的文件中输入以下代码，输入完毕之后，按 “esc” 键退出编辑模式， 输入 “:wq” 保存退出。 12345[nginx]name=nginx repobaseurl=http://nginx.org/packages/mainline/centos/7/$basearch/gpgcheck=0enabled=1 2、安装Nginx输入以下代码进行安装。 1$ yum install nginx -y 3、启动Nginx并设置开机自启输入以下代码: 12$ systemctl start nginx$ systemctl enable nginx 进行到这里，你已经可以把服务器ip复制到浏览器就可以看到Nginx的欢迎界面了。 4、配置Nginx接下来，需要修改一下nginx的相关配置，包括设置网站根目录以及配置域名。输入以下代码，打开Nginx的配置文件。(注：此处假定读者已完成了域名备案以及域名解析。) 1$ vi /etc/nginx/conf.d/default.conf 依照下图进行修改，将“/usr/share/nginx/html”改为“/usr/share/nginx/html/blog”。 至此，Nginx的配置就基本完成了。 安装Nodejs输入以下代码进行Nodejs的安装。 1$ yum install nodejs 可输入node -v以及npm -v查看node的版本。至此，Nodejs的安装就完成了。 安装Git以及进行相关配置1、输入以下代码，进行Git的安装 1$ yum install git 2、创建git用户以及设置密码输入以下代码： 1234# 创建用户,用户名为git$ adduser git# 设置密码$ passwd git 3、把git用户添加到sudo用户组中输入以下代码sudo vi /etc/sudoers，打开sudoers文件，输入:/root进行搜索，搜索到代码行root ALL=(ALL) ALL,然后在这一行下添加以下代码git ALL=(ALL) ALL。输入完毕之后，按wq!强制保存退出vi。 4、切换到git用户，添加SSH Key文件并且设置相应的读写与执行权限。输入以下代码： 123456# 切换用户$ su git# 创建目录$ mkdir ~/.ssh# 新建文件$ vim ~/.ssh/authorized_keys 然后把之前在客户端设置的SSH Key,复制到authorized_keys文件中，保存后退出。 接下来设置文件权限，把authorized_keys文件设置成只有属主有读写权限，把ssh目录设置为只有属主有读、写、执行权限。代码如下： 12$ chmod 600 ~/.ssh/authorized_keys$ chmod 700 ~/.ssh 设置完后，返回客户端，打开Git Bash，输入以下代码，测试是否能连接上服务器： 12# ServerIP为你自己服务器的ip$ ssh -v git@ServerIP 注意 SSH使用非对称加密，服务端不需要生成密钥对，而只需要一个authorized_keys文件，里面存放的是你客户端的公钥。客户端应该有密钥对id_rsa和id_rsa.pub文件，客户端的authorized_keys文件应该和id_rsa.pub文件内容一致。如果SSH免密码登录失败，请反复确认上述两点。 5、重新回到服务器，在网站根目录新建一个blog文件夹，用于客户端上传文件，并且把该文件授权给git用户。代码如下： 123# 使用sudo指令，需要输入git用户的密码$ sudo mkdir -p /usr/share/nginx/html/blog$ sudo chown -R git:git /usr/share/nginx/html/blog 6、在服务器上初始化一个git裸库切换到git用户，然后切换到git用户目录，接着初始化裸库，代码如下： 123$ su git$ cd ~$ git init --bare blog.git 接着新建一个post-receive文件 1$ vim ~/blog.git/hooks/post-receive 然后在该文件中输入以下内容： 12#！/bin/shgit --work-tree=/usr/share/nginx/html/blog --git-dir=/home/git/blog.git checkout -f 保存退出之后，再输入以下代码，赋予该文件可执行权限。 1$ chmod +x ~/blog.git/hooks/post-receive 7、返回客户端，设置博客根目录下的_config.yml文件。 12345deploy: type: git repo: git@SERVER:/home/git/blog.git #此处的SERVER需改为你自己服务器的ip branch: master #这里填写分支 message: #提交的信息 保存后，在博客根目录打开Git Bash，输入以下命令： 123$ hexo clean$ hexo g$ hexo d 部署完毕之后，即可在浏览器输入你的服务器ip进行访问你的博客了。 引用fogcrane-基于CentOS搭建Hexo博客","link":"/2019/04/11/hexo_blog_construct_summary/"},{"title":"luogu-P1131","text":"题目时态同步 一道双 $dfs$ 的题目。 分析题意就是给出一棵树，可以增加任意一条边的权值，问最少增加多少可以让所有叶子节点到跟节点的距离相等。 先跑一边 $dfs$ 求出所有节点到根节点的距离，再统计出以每个节点为根的子树上的所有点到根节点的距离的最大值。 然后再做一次 $dfs$ ，当一棵子树中离根节点最远的那个节点到根节点的距离都小于所有树中的距离最大的那个的话就可以考虑增加当前子树的根节点与它父亲节点之间的距离了，因为子树中所有节点的距离都需要增大，增大这条边一定是消耗最少的，因为这条边被所有子树上的节点复用了。然后递归下去。 说起来有点复杂，举个例子吧： 比如对于： 5 1 1 2 1 1 3 5 2 4 2 2 5 3 先把图画出来，有三个叶子节点，3 4 5，你会发现 1 到 3 的距离是最远的，因此 4 5 到根节点需要增加，而它们到根节点的路径在 1 2 这条边上重合了，因此我们可以优先在这条边上加，加到子树上有些叶子节点已经达到的最大值。然后向下递归。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;bits/stdc++.h&gt;#define rep(i, a, b) for(int i = (a); i &lt;= (b); ++i)#define per(i, a, b) for(int i = (a); i &gt;= (b); --i)#define debug(x) cerr &lt;&lt; #x &lt;&lt; ' ' &lt;&lt; x &lt;&lt; endl;using namespace std;typedef long long ll;const int mod = 1e9+7;const int MAXN = 5e5 + 7;vector&lt;pair&lt;int, int&gt; &gt; G[MAXN];ll dis[MAXN], msd[MAXN], maxdis, ans;void dfs(int x, int fa) { for(auto p: G[x]) { int v = p.first, w = p.second; if(v == fa) continue; dis[v] = dis[x] + w; dfs(v, x); msd[x] = max(msd[x], msd[v] + w); }}void dfs2(int x, int fa) { for (auto p: G[x]) { int v = p.first, w = p.second; if(v == fa) continue; ans += msd[x] - msd[v] - w; dfs2(v, x); }}int main(int argc, char const *argv[]){ int n, rt; scanf(\"%d %d\", &amp;n, &amp;rt); int u, v, w; rep(i, 1, n-1){ scanf(\"%d %d %d\", &amp;u, &amp;v, &amp;w); G[u].push_back({v, w}); G[v].push_back({u, w}); } dfs(rt, 0); dfs2(rt, 0); printf(\"%lld\\n\", ans); return 0;}","link":"/2019/09/18/luogu-P1131/"},{"title":"洛谷P1879 & P2051","text":"题目中国象棋 玉米田Corn Fields 两道DP。 中国象棋以为是状压DP，但是不知道怎么做。 换了另一种做法。 显然，每列不可能有两个以上的炮，设 $f[i][j][k]$ 表示第 $i$ 行有 $j$ 列有一个炮车，有 $k$ 列有两个炮车。那么一个炮车也没有个列数就是 $m-j-k$。 定义完状态，再来想怎么转移。考虑从 $i-1$ 行向 $i$ 行转移。第 $i$ 行最多只能有两个炮车分情况讨论： 不放炮车，$f[i][j][k] = f[i-1][j][k]$ 放一个炮车，放在没有跑车的列或者有一个炮车列：$f[i][j+1][k] = f[j-1][j][k] * (m-j-k), f[i][j][k+1] = f[i-1][j][k]*j$ 放两个炮车的情况，讨论一下就好了，看代码吧。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;bits/stdc++.h&gt;#define rep(i, a, b) for(int i = (a); i &lt;= (b); ++i)#define per(i, a, b) for(int i = (a); i &gt;= (b); --i)#define debug(x) cerr &lt;&lt; #x &lt;&lt; ' ' &lt;&lt; x &lt;&lt; endl;using namespace std;typedef long long ll;const int MOD = 9999973;const int MAXN = 2e5 + 7;//第i行有j个单跑k个双炮ll f[105][105][105];ll C[105][105];void init(){ C[0][0] = 1; rep(i, 1, 100){ rep(j, 0, i){ C[i][j] = C[i-1][j] + C[i-1][j-1]; } }}int main(int argc, char const *argv[]){ init(); int n, m; scanf(\"%d %d\", &amp;n, &amp;m); f[0][0][0] = 1; rep(i, 1, n){ rep(j, 0, m){ rep(k, 0, m){ if(j + k &gt; m) continue; //不选 f[i][j][k] += f[i-1][j][k]; f[i][j][k] %= MOD; //选一个 选在空列 f[i][j+1][k] += f[i-1][j][k] * (m - j - k); f[i][j+1][k] %= MOD; // 选一个 选在单炮列 f[i][j-1][k+1] += f[i-1][j][k] * j; f[i][j-1][k+1] %= MOD; // 选两个 都选在空列 f[i][j+2][k] += f[i-1][j][k] * C[m - j - k][2]; f[i][j+2][k] %= MOD; // 选两个 都选在单炮列 f[i][j-2][k+2] += f[i-1][j][k] * C[j][2]; f[i][j-2][k+2] %= MOD; // 选两个 一个在空列一个在单炮列 f[i][j][k+1] += f[i-1][j][k] * (m - j - k) * j; f[i][j][k+1] %= MOD; } } } ll ans = 0; rep(i, 0, m) rep(j, 0, m) { ans += f[n][i][j]; ans %= MOD; } printf(\"%lld\\n\", ans); return 0;} 玉米田状压DP，先保存每一行的状态，在求出有效的状态。 枚举有效的状态，判断是否和土地状况冲突，不冲突再枚举上一行的状态，如果和当前行不冲突，那么就是有效的转移。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;bits/stdc++.h&gt;#define rep(i, a, b) for(int i = (a); i &lt;= (b); ++i)#define per(i, a, b) for(int i = (a); i &gt;= (b); --i)#define debug(x) cerr &lt;&lt; #x &lt;&lt; ' ' &lt;&lt; x &lt;&lt; endl;using namespace std;typedef long long ll;const int MOD = 1e9;const int MAXN = 2e5 + 7;ll f[15][5005];bool g[5005];int mp[15][15];int field[15];int main(int argc, char const *argv[]){ int n, m; scanf(\"%d %d\", &amp;n, &amp;m); rep(i, 1, n){ rep(j, 1, m){ scanf(\"%d\", &amp;mp[i][j]); field[i] &lt;&lt;= 1; field[i] |= mp[i][j]; } } //求出可行状态集 vector&lt;int&gt; sta; rep(i, 0, (1&lt;&lt;m)-1) if(!((i &amp; i&gt;&gt;1)||(i &amp; i&lt;&lt;1))) sta.push_back(i); f[0][0] = 1; rep(i, 1, n) { //枚举当前行的状态 for(int j: sta) { //如果和土地状况不冲突 if((j &amp; field[i]) == j) { //枚举上一行的状态 for(int k: sta) { //如果也不冲突 if((j &amp; k) == 0) { //可行的转移 f[i][j] += f[i-1][k], f[i][j] %= MOD; } } } } } ll ans = 0; rep(i, 0, (1&lt;&lt;m)-1) { ans += f[n][i]; ans %= MOD; } printf(\"%lld\\n\", ans); return 0;}","link":"/2019/09/18/luogu-P1879-P2051/"},{"title":"洛谷-P3806","text":"题目洛谷P3806 点分治模板题。 求边权树上距离为 $k$ 的点对。 分析第一眼没看到边带权，以为直接判断树的直径是否大于等于 $k$ 就行了。233333。 一道经典的点分治的题目，点分治是一种高效的求树上路径满足一定条件的路径个数，当然一条路径，对应两个端点，说成点对数也可以。 这道题目本来写成了在线，有一个点 $1.02s$ 过不去，本来想着卡卡就能过去了，可是去看了看别人的代码，发现总共只需要 $200+ms$ 就够了。想着是自己写搓了，然后翻开了题解，发现可以同时对所有的询问进行查询，没有必要一个一个查。改了改，就过了。 点分治还是比较考验对 $dfs$ 的理解的，因为这道题就有三个 $dfs$ ，甚至还有一个换根 $DP$ 求重心。 然后就是比较考验细节，今天两道模板题都是因为几个变量名弄混了，调了几个小时的 $BUG$ 。 讲一下思路吧。点分治最重要的两点，一是找重心，这样可以降低复杂度，二是统计和去重。 找重心每道题目都是一样的，就不说了。 这道题的统计就是，对于每一个重心树，先统计所有节点到根节点的距离，因为距离范围不超过 $1e7$ 可以用数组保存，剩下一个 $map$ 的 $log$ ，比较重要的是统计数组不能直接清空，我们考虑将所有距离先存起来，统计一下，然后再删除就好了。去重的话，就是很常规的去重。 我统计的直接就是距离为 $k$ 的点对数。 时间复杂度： $O(n\\cdot m \\log n)$ 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include&lt;bits/stdc++.h&gt;#define rep(i, a, b) for(int i = (a); i &lt;= (b); ++i)#define per(i, a, b) for(int i = (a); i &gt;= (b); --i)#define debug(x) cerr &lt;&lt; #x &lt;&lt; ' ' &lt;&lt; x &lt;&lt; endl#define size sizeeeeeeeusing namespace std;typedef long long ll;const int MAXN = 1e4 + 7;const int MAXM = 1e7 + 7;const int MOD = 1e9 + 7;vector&lt;pair&lt;int, int&gt; &gt; G[MAXN];int son[MAXN], dep[MAXN], f[MAXN], q[MAXN], ans[MAXN], k;int root, size; int cnt[MAXM], n, m;bool vis[MAXN];void get_rt(int x, int fa) { son[x] = 1; f[x] = 0; for(auto p: G[x]) { int u = p.first; if(u == fa || vis[u]) continue; get_rt(u, x); son[x] += son[u]; f[x] = max(f[x], son[u]); } f[x] = max(f[x], size - son[x]); if(f[x] &lt; f[root]) root = x;}vector&lt;int&gt; v;void get_dep(int x, int fa) { v.push_back(dep[x]); for(auto p: G[x]) { int u = p.first, w = p.second; if(u == fa || vis[u]) continue; dep[u] = dep[x] + w; get_dep(u, x); }}void calc(int x, int w, int op) { v.clear(); dep[x] = w; get_dep(x, 0); for(int p: v) { rep(i, 1, m) if(p &lt;= q[i]) ans[i] += op * cnt[q[i] - p]; cnt[p]++; } for(int p: v) cnt[p]--;}void solve(int x) { calc(x, 0, 1); vis[x] = 1; for(auto p: G[x]) { int u = p.first, w = p.second; if(vis[u]) continue; calc(u, w, -1); root = 0; size = son[u]; get_rt(u, 0); solve(root); }}int main() { scanf(\"%d %d\", &amp;n, &amp;m); int u, v, w; rep(i, 1, n-1) { scanf(\"%d %d %d\", &amp;u, &amp;v, &amp;w); G[u].push_back({v, w}); G[v].push_back({u, w}); } rep(i, 1, m) scanf(\"%d\", &amp;q[i]); f[0] = INT_MAX; size = n; root = 0; get_rt(1, 0); solve(root); rep(i, 1, m) { if(ans[i]) printf(\"AYE\\n\"); else printf(\"NAY\\n\"); } return 0;}","link":"/2019/09/28/luogu-P3806/"},{"title":"牛客小白赛15","text":"题目牛客小白赛15 题解E. 希望希望是什么，希望是我们这个时代最珍贵的东西。 直接用一颗线段树维护区间最小值就可以了。 然后在做一个背包。 H.数据结构题一个很神奇的思路。 我们将每一个出现x的位置，放进G[x]中，然后查找第一个比r大的位置，和第一个大于定于l的位置，然后这两个位置做差就可以得到x在这段区间中的出现次数了。 代码E. 希望123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081/*--------------------------------- @Author: Dicer @DateTime: 2019-06-16 11:54:32---------------------------------*/#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef pair&lt;int, int&gt; pii;inline ll qpow(ll a,ll b,ll mod){ll res=1;while(b){if(b&amp;1)res = (res*a)%mod;a=(a*a)%mod;b&gt;&gt;=1;}return res;}const double eps = 1e-8;const int INF = 0x3f3f3f3f;const int mod = 1e9+7;const int MAXN = 2e5 + 7;struct node{ int l, r; int mid(){return (l+r)&gt;&gt;1;} int val;}s[MAXN&lt;&lt;1];ll a[MAXN], b[MAXN], dp[MAXN];void build(int l, int r, int x){ s[x].l = l; s[x].r = r; s[x].val = 500; int mid = (l+r)&gt;&gt;1; if(l == r) return; build(l, mid, x&lt;&lt;1); build(mid+1, r, x&lt;&lt;1|1);}inline void upd(int l, int r, int x, int v){ // cout &lt;&lt; l &lt;&lt; ' ' &lt;&lt; r &lt;&lt; ' ' &lt;&lt; s[x].l &lt;&lt; ' ' &lt;&lt; s[x].r &lt;&lt; ' ' &lt;&lt; v &lt;&lt; endl; if(s[x].l &gt;= l &amp;&amp; s[x].r &lt;= r){ s[x].val = min(s[x].val, v); return; } int mid = s[x].mid(); if(r &gt; mid) upd(l, r, x&lt;&lt;1|1, v); if(l &lt;= mid) upd(l, r, x&lt;&lt;1, v);}inline void pushdown(int x){ if(s[x].l == s[x].r){ a[s[x].l] = s[x].val; return; } s[x&lt;&lt;1].val = min(s[x&lt;&lt;1].val, s[x].val); s[x&lt;&lt;1|1].val = min(s[x&lt;&lt;1|1].val, s[x].val); pushdown(x&lt;&lt;1); pushdown(x&lt;&lt;1|1);}int main(int argc, char const *argv[]){ #ifndef ONLINE_JUDGE freopen(\"in.txt\", \"r\", stdin); freopen(\"out.txt\", \"w\", stdout); #endif int n, k, m; cin &gt;&gt; n &gt;&gt; k &gt;&gt; m; for(int i = 1; i &lt;= n; ++i) cin &gt;&gt; b[i]; build(1, n, 1); int l, r; ll c; for(int i = 1; i &lt;= m; ++i){ cin &gt;&gt; l &gt;&gt; r &gt;&gt; c; upd(l, r, 1, c); } pushdown(1); // for(int i = 1; i &lt;= n; ++i) cout &lt;&lt; a[i] &lt;&lt; ' '; // cout &lt;&lt; endl; //dp ll sum = 0; for(int i = 1; i &lt;= n; ++i){ sum += b[i]; if(b[i] &gt;= 0) continue; for(int j = k; j &gt;= a[i]; --j){ dp[j] = max(dp[j], dp[j-a[i]] - b[i]); } } cout &lt;&lt; sum+dp[k] &lt;&lt; endl; return 0;} H.数据结构题123456789101112131415161718192021222324252627282930313233343536373839404142434445/*--------------------------------- @Author: Dicer @DateTime: 2019-06-16 01:55:25---------------------------------*/#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef pair&lt;int, int&gt; pii;inline ll qpow(ll a,ll b,ll mod){ll res=1;while(b){if(b&amp;1)res = (res*a)%mod;a=(a*a)%mod;b&gt;&gt;=1;}return res;}const double eps = 1e-8;const int INF = 0x3f3f3f3f;const int mod = 20180623;const int MAXN = 2e5 + 7;int a[MAXN];vector&lt;int&gt; G[MAXN];int main(int argc, char const *argv[]){ #ifndef ONLINE_JUDGE freopen(\"in.txt\", \"r\", stdin); freopen(\"out.txt\", \"w\", stdout); #endif int n, m; cin &gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt;= n; ++i){ cin &gt;&gt; a[i]; G[a[i]].push_back(i); } ll x, a, b, l1, l2, r1, r2; for(int i = 1; i &lt;= m; ++i){ cin &gt;&gt; l1 &gt;&gt; r1 &gt;&gt; l2 &gt;&gt; r2 &gt;&gt; x; if(l1 &gt; r1) swap(l1, r1); if(l2 &gt; r2) swap(l2, r2); a = upper_bound(G[x].begin(), G[x].end(), r1) - lower_bound(G[x].begin(), G[x].end(), l1); b = upper_bound(G[x].begin(), G[x].end(), r2) - lower_bound(G[x].begin(), G[x].end(), l2); cout &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; b &lt;&lt; endl; cout &lt;&lt; (a%mod)*(b%mod)%mod &lt;&lt; endl; } return 0;}","link":"/2019/06/16/niukexiaobai15/"},{"title":"牛客练习赛-53B","text":"题目题目链接 题意求和式： $$\\sum_{i=1}^{n}{\\sum_{j=1}^{i}{i \\lfloor {\\frac{i}{j}} \\rfloor ^j}}$$ 分析更换一下枚举顺序： $$\\sum_{j=1}^{n}\\sum_{i=j}^{n}{i \\lfloor \\frac{i}{j} \\rfloor ^ j}$$ 可以发现 $i$ 在 区间 $[k\\cdot j, (k+1)\\cdot j-1]$ 内 $\\lfloor \\frac{i}{j} \\rfloor = k$ ，因此可以对每个 $j$ 做分段处理，另外 $\\lfloor \\frac{i}{j} \\rfloor ^ j$ 可以从上一个状态转移过来。 时间复杂度： $O(n \\log n)$ 代码12345678910111213141516171819202122232425#include &lt;bits/stdc++.h&gt; using namespace std; typedef long long ll;const int MAXN = 3e6 + 7;const int MOD = 1e9 + 7;ll p[MAXN]; int main () { for (int i = 1; i &lt;= 3000000; ++i) p[i] = 1; ll n; cin &gt;&gt; n; ll ans = 0; for(ll j = 1; j &lt;= n; ++j) { ll lim = n/j, l = j, r = min(2 * j - 1, n); for (ll i = 1; i &lt;= lim; ++i) { p[i] = p[i] * i % MOD; ans += (l+r)*(r-l+1)/2%MOD*p[i]%MOD; ans %= MOD; l += j; r = min(r + j, n); } } cout &lt;&lt; ans &lt;&lt; endl; return 0;}","link":"/2019/10/12/niuke-exercise-53/"},{"title":"红楼梦札记","text":"小记昨天晚上看了一集木鱼水心做的87版红楼梦讲解，颇有兴趣，于是决定写一篇博客，记录个人感受。 说起来，曾经多次想要认真读完红楼梦原著却都不了了之，究其根本可能是我本人对其中复杂人物关系招架不住，毕竟在生活中我就不擅长这些事情。还有可能是因为书中前篇铺垫冗长，这种慢热的写法导致我还没看到精彩的部分就已经没了耐心。 确实如木鱼水心在第一篇中所说的那样，虽然同为四大名著，红楼梦却没用其他三本书那样人尽皆知。 至于我为什么想读这本书，可能因为高中的时候同学老师的不经意提起，对为何它能被评为“小说的巅峰”感到好奇，还有就是对书中所描述的美食十分感兴趣。 我为何不选择自己品读名著，观看电视剧？ 原因有二：１、没有太多的时间。２、觉得自己品读原著读不出来什么东西，很可能很快就放弃了。 本篇博客小标题与木鱼水心分p标题相同。 通灵宝玉入红尘，宝黛初会续前盟抄录 满纸荒唐言，一把辛酸泪。 都云作者痴，谁解其中味。 红尘之中美中不足且好事多磨，乐极生悲之时又人非物换，不过是到头一梦，万境归空。 好了歌 世人都道神仙好 惟有功名忘不了 古今将相在何方 荒冢一堆草末了","link":"/2019/04/23/reading-Dream-of-the-Red-Chamber/"},{"title":"使用HTTP协议实现内网文件传输","text":"需求虽然说现在各种网盘、QQ，已经可以满足我们日常基本的小文件传输的需要了，但是当文件比较大的时候还是很慢，因此我们需要一种更快的，更简洁的传输方式来做局域网内的文件传输。 解决方案考虑使用本地的一台主机做服务器，为其他同局域网内的设备（如：手机、平板电脑）提供文件传输服务，使用http协议。 工具MobaXterm、python3。 下载MobaXterm（Windows） 步骤使用MobaXterm 打开Xterm的Servers，选择http。 设置端口号、文件所在地址和开启时间。 开启服务。 使用Python 打开cmd 输入 $ python -m http.server # python3 $ python -m SimpleHTTPServers # python2 如果想要选择端口号的话，可以直接在后面添加。 Tippython方法对中文路径很不友好，不建议使用中文文件名，可能会访问不了。MobaXterm没有问题，中文文件也可以正常访问。 浏览器访问经过上述步骤，你已经可以在其他设备上访问你服务器上的文件了。 在浏览器输入你服务器的本地IP即可（如果不是80端口，则需要自己手动输入）。 经测试，网页直接下载速度约为30Mb/s。 另外，意想不到的一点是，视频文件（MP4）可以直接播放，而且丝毫没有卡顿，因此，我们还可以把它当作视频服务器，下载到电脑上的视频可以在手机📱、平板上看啦。","link":"/2019/06/25/transfer-file-use-http/"},{"title":"TJOI2013-松鼠聚会","text":"题目P3964 [TJOI2013]松鼠聚会 关于曼哈顿坐标系和切比雪夫坐标系之间的相互转换。 前置技能 曼哈顿坐标系是通过切比雪夫坐标系旋转$45 ^\\circ $后，再缩小到原来的一半得到的。 将一个点 $(x, y)$ 的坐标变为 $(x+y, x-y)$ 后，原坐标系中的曼哈顿距离等于新坐标系中的切比雪夫距离 将一个点 $(x, y)$ 的坐标变为 $(\\frac{x+y}{2}, \\frac{x-y}{2})$ 后，原坐标系中的切比雪夫距离等于新坐标系中的曼哈顿距离 分析首先，原题中定义的距离是切比雪夫距离，看着非常奇怪。 我们先考虑如果是曼哈顿距离怎么做。 考虑一些点： $$(x_1, y_1), (x_2, y_2), … , (x_n, y_n)$$ 只需求出： $$\\min_{j=1}^{n}\\sum_{i=1}^{n}|x_i-x_j|+|y_i-y_j|$$。 而： $$\\sum_{i=1}^{n}|x_i-x_j|+|y_i-y_j| = \\sum_{i=1}^{n}|x_i-x_j| + \\sum_{i=1}^{n}|y_i-y_j|$$ 发现这两个维度互不影响，可以分别求出 $x, y$ 轴的。 先对 $x$ 从小到大排序，设 $pre_i$ 前 $i-1$ 个点到点 $i$ 的 $x$ 轴距离前缀和，即： $$pre_i = \\sum_{j=1}^{i-1}|x_i - x_j|$$ 同理做后缀和： $$suf_i = \\sum_{j=i+1}^{n}|x_i - x_j|$$ 则： $$\\sum_{i=1}^{n}|x_i-x_j| = pre_i + suf_i$$ $y$ 轴同理。 所以只需要先将原切比雪夫坐标系转化为曼哈顿左边系就行了。 注意转化的时候先不要除 $2$，最后在除 $2$，可以防止产生小数。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;bits/stdc++.h&gt;#define rep(i, a, b) for(int i = (a); i &lt;= (b); ++i)#define per(i, a, b) for(int i = (a); i &gt;= (b); --i)using namespace std;typedef long long ll;const int MAXN = 2e5 + 7;ll suf[MAXN], pre[MAXN];struct node{ int x, y, id; ll ansx, ansy;}s[MAXN];int main() { int n, a, b; scanf(\"%d\", &amp;n); rep(i, 1, n){ scanf(\"%d %d\", &amp;a, &amp;b); s[i].x = a + b; s[i].y = a - b; s[i].id = i; } sort(s + 1, s + 1 + n, [](const node &amp;a, const node &amp;b){return a.x &lt; b.x;}); suf[1] = 0; pre[n] = 0; rep(i, 2, n) suf[i] = suf[i-1] + 1ll * (i-1) * (s[i].x - s[i-1].x); per(i, n-1, 1) pre[i] = pre[i+1] + 1ll * (n-i) * (s[i+1].x - s[i].x); rep(i, 1, n) s[i].ansx = suf[i] + pre[i]; sort(s + 1, s + 1 + n, [](const node &amp;a, const node &amp;b){return a.y &lt; b.y;}); suf[1] = 0; pre[n] = 0; rep(i, 2, n) suf[i] = suf[i-1] + 1ll * (i-1) * (s[i].y - s[i-1].y); per(i, n-1, 1) pre[i] = pre[i+1] + 1ll * (n-i) * (s[i+1].y - s[i].y); rep(i, 1, n) s[i].ansy = suf[i] + pre[i]; ll ans = 1ll&lt;&lt;60; rep(i, 1, n) ans = min(ans, s[i].ansx + s[i].ansy); printf(\"%lld\\n\", ans/2); return 0;}","link":"/2019/09/05/TJOI2013-songshujuhui/"}],"tags":[{"name":"Data structure","slug":"Data-structure","link":"/tags/Data-structure/"},{"name":"Dynamic programming","slug":"Dynamic-programming","link":"/tags/Dynamic-programming/"},{"name":"点分治","slug":"点分治","link":"/tags/点分治/"},{"name":"树状数组","slug":"树状数组","link":"/tags/树状数组/"},{"name":"欧拉定理","slug":"欧拉定理","link":"/tags/欧拉定理/"},{"name":"欧拉函数","slug":"欧拉函数","link":"/tags/欧拉函数/"},{"name":"中国剩余定理","slug":"中国剩余定理","link":"/tags/中国剩余定理/"},{"name":"二维偏序","slug":"二维偏序","link":"/tags/二维偏序/"},{"name":"单调队列","slug":"单调队列","link":"/tags/单调队列/"},{"name":"树形动规","slug":"树形动规","link":"/tags/树形动规/"},{"name":"LCA","slug":"LCA","link":"/tags/LCA/"},{"name":"瞎搞","slug":"瞎搞","link":"/tags/瞎搞/"},{"name":"拉格朗日乘数法","slug":"拉格朗日乘数法","link":"/tags/拉格朗日乘数法/"},{"name":"基环树","slug":"基环树","link":"/tags/基环树/"},{"name":"IDA*","slug":"IDA","link":"/tags/IDA/"},{"name":"启发式搜索","slug":"启发式搜索","link":"/tags/启发式搜索/"},{"name":"数论分块","slug":"数论分块","link":"/tags/数论分块/"},{"name":"状压DP","slug":"状压DP","link":"/tags/状压DP/"},{"name":"拉格朗日插值法","slug":"拉格朗日插值法","link":"/tags/拉格朗日插值法/"},{"name":"SSH","slug":"SSH","link":"/tags/SSH/"},{"name":"Server","slug":"Server","link":"/tags/Server/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"dfs","slug":"dfs","link":"/tags/dfs/"},{"name":"线段树","slug":"线段树","link":"/tags/线段树/"},{"name":"分块","slug":"分块","link":"/tags/分块/"},{"name":"Book","slug":"Book","link":"/tags/Book/"},{"name":"http","slug":"http","link":"/tags/http/"},{"name":"曼哈顿距离","slug":"曼哈顿距离","link":"/tags/曼哈顿距离/"},{"name":"切比雪夫距离","slug":"切比雪夫距离","link":"/tags/切比雪夫距离/"}],"categories":[{"name":"Competition","slug":"Competition","link":"/categories/Competition/"},{"name":"图论","slug":"图论","link":"/categories/图论/"},{"name":"数据结构","slug":"数据结构","link":"/categories/数据结构/"},{"name":"数论","slug":"数论","link":"/categories/数论/"},{"name":"数论","slug":"数据结构/数论","link":"/categories/数据结构/数论/"},{"name":"搜索","slug":"搜索","link":"/categories/搜索/"},{"name":"动态规划","slug":"动态规划","link":"/categories/动态规划/"},{"name":"Technology","slug":"Technology","link":"/categories/Technology/"},{"name":"Reading","slug":"Reading","link":"/categories/Reading/"},{"name":"网络协议","slug":"网络协议","link":"/categories/网络协议/"},{"name":"几何","slug":"几何","link":"/categories/几何/"}]}