{"pages":[{"title":"A Man Called Dicer Decided To Survive","text":"Hello, I’m Zhicheng Wang (alias: dicer), a graduate at AntNLP@ECNU. The topic I am interested in is Model Interpretability of Pre-trained Language Model in Natural Language Processing. Please feel free to contact me via dicer@gmail.com. PublicationNone yet.","link":"/about/index.html"}],"posts":[{"title":"2019CCPC河南省省赛","text":"碎碎念早上８点才出发，本来以为时间会很紧张，不过９点多一点就到了。不过没有参加开幕式。 复盘然后比赛开始，前两道水题签到很快就过了，然后发现有人在交A，但是都没过，mengshen猜了半天的假结论，直接被hack掉了，然后被通知A重判了，发现过了好几个队，然后仔细想了下，发现直接把每个行当做元素进行LIS就行了。然后我写了半天的LCS过了样例就交了一发，１WA，然后甚至还觉得自己写的很完美，演了半天，然后改抄白书模板自作聪明改了一点，过了样例，又交，２WA，演了大概30min，然后mengshen上机抄了一下模板，然后改了一下check两行之间关系的函数，成功３AC。 期间我看了F题，看了一下题面直接丢给了老毕，然后听他说好像有一个边界判错了浪费了好长时间DEBUG，不过最后还是过了，１A。 这个时候四题已经在金区了（好水），发现C，H都有人过，于是看C，H，以为Ｃ是跟前几天训练一样的multiset写法，然后发现不会两个multiset的合并，内存时间都可能爆炸。Ｈ是一个奇奇怪怪的搜索顺序，到最后都没弄明白。然后觉得可能还有其他题目能开，于是开始一道一道看，发现了Ｉ题是一个暴力剪枝很可行的题，而且很难造能卡主暴力的数据，于是我上机敲了一发暴力，1Ａ，之后一直在Ｃ，Ｈ两题之间倒腾但是并不会写。 结语最后５题水了个金，赞助商爸爸大气，每题一血还有５００现金，Ｉ题差４min一血，好可惜。 面包牛奶香蕉好评，就是面包有点油。上次天梯赛在郑轻的时候，键盘Ctrl特别硬，都摁不下去，这次好像机房升级了，全部ＨＰ的键盘鼠标，县显示器１０８０分辨率超级舒服，i7-8700的电脑用起来真的爽，郑州轻工业大学牛逼！体验极佳。","link":"/2019/04/13/2019-Henan-CCPC-provincial-competition/"},{"title":"2017浙江省赛","text":"碎碎念明天就又去郑轻了（噫，我为什么要说又，哦，上次天梯就是在郑轻），希望这次能取得一个好成绩！不能再这么菜下去了。 老毕再次KILL一道数位DP，这也太强了。我贡献一发构造题。 复盘早上起晚了，迟到30min，AB两题我到的时候已经Ａ掉了，然后mengshen在上机写Ｃ，然后我看Ｄ，老毕再看Ｇ，说是博弈，然而我根本不会博弈，于是继续看我的Ｄ，看完发现是一个普通的线段合并，觉得可写，此时mengshen还在改Ｃ，于是我给老毕讲了一下题意想让他写，但是讲着讲着发下原来的思路复杂了，其实直接两个人的线段全部丢在一起，直接判断重复区间就可以了，就把mengshen赶下来写Ｄ，写完测样例通过直接就交上去了，然后ＷＡ了，发现ＤＥＢＵＧ的输出没删除，删除掉ＡＣ。然后mengshen又上机写Ｃ，并改变了做法，３ＡＣ。然后Ｅ题数位ＤＰ丢给老毕没管过，看Ｆ，本来用的优先队列写了一个假算法，演了一发，然后找到了一组数据ｈａｃｋ了自己，发现是没有贪心，改用multiset贪心，写完测过样例交了，TLE，然后mengshen提议讲ＳＴＬ的lower_bound()换成multiset自带的，说是曾经在CF上看到过一个被lower_bound()卡时间的帖子，遂改，3ＡＣ。 总结最终６题，听说这套省赛题目难度挺大的，感觉打的还可以。 由于前天睡得太晚导致迟到实在不应该，老毕还是强啊，精通数位ＤＰ，还是要继续加油。","link":"/2019/04/12/2017-Zhejiang-provincial-competition/"},{"title":"2019-ICPC-沈阳网络赛-D","text":"题目Fish eating fruit 点分治进阶题目，状态很多，统计起来有点复杂。 分析首先肯定是点分治没得跑了，然后就是怎么计算的问题了。 我是先统计出来所有的 $mod $ 后的值，对于每一个节点的深度，可以计算出来这个点对 三个剩余 的贡献。 转移一下就好了。 因为去重的时候做了减法，所有答案可能是负值，要调整回来。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106#include &lt;bits/stdc++.h&gt;#define rep(i, a, b) for(int i = (a); i &lt;= (b); ++i)#define per(i, a, b) for(int i = (a); i &gt;= (b); --i)#define debug(x) cerr &lt;&lt; #x &lt;&lt; ' ' &lt;&lt; x &lt;&lt; endl;#define size sizeeeeeeeeusing namespace std;typedef long long ll;const int MOD = 1e9+7;const int MAXN = 1e4 + 7;ll ans1, ans2, ans3, cnt[4];int n, root, size, tot = 0;int son[MAXN], f[MAXN], head[MAXN];int dep[MAXN]; bool vis[MAXN];struct node{ int u, w, nxt;}; vector&lt;node&gt; E;void add(int u, int v, int w) { E.push_back(node{v, w, head[u]}); head[u] = tot++;}void get_rt(int x, int fa = 0) { son[x] = 1; f[x] = 0; for(int j = head[x]; ~j; j = E[j].nxt) { int u = E[j].u, w = E[j].w; if(vis[u] || u == fa) continue; get_rt(u, x); son[x] += son[u]; f[x] = max(f[x], son[u]); } f[x] = max(f[x], size - son[x]); if(f[x] &lt; f[root]) root = x;}vector&lt;int&gt; v;void get_dep(int x, int fa) { v.push_back(dep[x]); cnt[dep[x]%3]++; for(int j = head[x]; ~j; j = E[j].nxt) { int u = E[j].u, w = E[j].w; if(vis[u] || u == fa) continue; dep[u] = dep[x] + w; get_dep(u, x); }}void calc(int x, int op) { memset(cnt, 0, sizeof cnt); v.clear(); get_dep(x, 0); ll res0, res1, res2; res0 = res1 = res2 = 0; for(int p: v) { int offset = p%3; if(offset == 0) { res0 += op * (cnt[0] - 1) * p; res1 += op * cnt[1] * p; res2 += op * cnt[2] * p; } else if(offset == 1) { res0 += op * cnt[2] * p; res1 += op * cnt[0] * p; res2 += op * (cnt[1] - 1) * p; } else { res0 += op * cnt[1] * p; res1 += op * (cnt[2] - 1) * p; res2 += op * cnt[0] * p; } res0 %= MOD; res1 %= MOD; res2 %= MOD; } ans1 += res0; ans2 += res1; ans3 += res2; ans1 %= MOD; ans2 %= MOD; ans3 %= MOD;}void solve(int x) { dep[x] = 0; calc(x, 1); vis[x] = 1; for(int j = head[x]; ~j; j = E[j].nxt) { int u = E[j].u, w = E[j].w; if(vis[u]) continue; dep[u] = w; calc(u, -1); root = 0; size = son[u]; get_rt(u); solve(root); }}int main(int argc, char const *argv[]){ while(~scanf(&quot;%d&quot;, &amp;n)) { memset(head, -1, sizeof head); memset(vis, 0, sizeof vis); E.clear(); tot = 0; int u, v, w; rep(i, 1, n-1) { scanf(&quot;%d %d %d&quot;, &amp;u, &amp;v, &amp;w); u++; v++; add(u, v, w); add(v, u, w); } root = 0; f[0] = size = n; get_rt(1, 0); ans1 = ans2 = ans3 = 0; solve(root); ans1 = ans1 * 2 % MOD; ans2 = ans2 * 2 % MOD; ans3 = ans3 * 2 % MOD; ans1 = (ans1 + MOD) % MOD; ans2 = (ans2 + MOD) % MOD; ans3 = (ans3 + MOD) % MOD; printf(&quot;%lld %lld %lld\\n&quot;, ans1, ans2, ans3); } return 0;}","link":"/2019/09/28/2019-ICPC-Shenyang-contest-online/"},{"title":"2019-ICPC-南京网络赛","text":"题目计蒜客 A. The beautiful values of the palace知识点：坐标映射，离散化，树状数组，离线查询 坐标映射找一下规律。（虽然我不太会找这个规律 1234567ll get_int(int n, int x, int y){ x = x - n/2 - 1; y = y - n/2 - 1; ll t = max(abs(x), abs(y)); if(x &gt;= y) return 1ll * n * n - 4 * t * t - 2 * t - x - y; else return 1ll * n * n - 4 * t * t + 2 * t + x + y;} 离散化和离线查询只离散化一维就行了，当然两个维度都离散化也是没有问题的。 假设只离散化x轴，那么我们对建点和查询操作进行x优先排序，扫描x轴，当操作的x与当前枚举的x相同时进行操作，优先建点，然后查询。这样是为了保证顺序。 查询的时候，相当于查询一个一维前缀和，用树状数组维护就可以了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124#include&lt;bits/stdc++.h&gt;#define rep(i, a, b) for(int i = (a); i &lt;= (int)(b); ++i)#define per(i, a, b) for(int i = (a); i &gt;= (int)(b); --i)#define debug(x) cerr &lt;&lt; #x &lt;&lt; ' ' &lt;&lt; x &lt;&lt; endl;using namespace std;typedef long long ll;const int MAXN = 1e5 + 7;const int MOD = 998244353;struct node{ int x, y, id; ll val; friend bool operator &lt;(const node &amp;a, const node &amp;b){ return a.x &lt; b.x; }}s[MAXN], need[MAXN * 4];struct ask{ int a, b, c, d;}op[MAXN];ll get_int(int n, int x, int y){ x = x - n/2 - 1; y = y - n/2 - 1; ll t = max(abs(x), abs(y)); if(x &gt;= y) return 1ll * n * n - 4 * t * t - 2 * t - x - y; else return 1ll * n * n - 4 * t * t + 2 * t + x + y;}int get_val(ll val){ int ans = 0; while(val){ ans += val%10; val /= 10; } return ans;}struct BIT { int e[MAXN], n; void clear(){rep(i, 0, n) e[i] = 0;} int lowbit(int x){return x &amp; (-x);} void add(int x, int v){ while(x &lt;= n){ e[x] += v; x += lowbit(x); } } int get(int x){ int ans = 0; while(x){ ans += e[x]; x -= lowbit(x); } return ans; }}bit;int hx[MAXN * 10], hy[MAXN * 10];int main() { int T; scanf(&quot;%d&quot;, &amp;T); while(T--){ int n, m, p; scanf(&quot;%d %d %d&quot;, &amp;n, &amp;m, &amp;p); vector&lt;int&gt; vx, vy; rep(i, 1, m){ scanf(&quot;%d %d&quot;, &amp;s[i].x, &amp;s[i].y); s[i].val = get_val(get_int(n, s[i].x, s[i].y)); vx.push_back(s[i].x); vy.push_back(s[i].y); } int x1, y1, x2, y2; rep(i, 0, p-1){ scanf(&quot;%d %d %d %d&quot;, &amp;x1, &amp;y1, &amp;x2, &amp;y2); vx.push_back(x1-1); vx.push_back(x2); vy.push_back(y1-1); vy.push_back(y2); need[i * 4 + 1] = node{x1-1, y1-1, i * 4 + 1}; need[i * 4 + 2] = node{x1-1, y2, i * 4 + 2}; need[i * 4 + 3] = node{x2, y1-1, i * 4 + 3}; need[i * 4 + 4] = node{x2, y2, i * 4 + 4}; op[i] = ask{i*4 + 1, i*4 + 2, i*4 + 3, i*4 + 4}; } sort(vx.begin(), vx.end()); vx.erase(unique(vx.begin(), vx.end()), vx.end()); sort(vy.begin(), vy.end()); vy.erase(unique(vy.begin(), vy.end()), vy.end()); rep(i, 0, vx.size()-1){hx[vx[i]] = i + 1;} rep(i, 0, vy.size()-1){hy[vy[i]] = i + 1;} rep(i, 1, m){ s[i].x = hx[s[i].x]; s[i].y = hy[s[i].y]; } rep(i, 0, p-1){ need[i * 4 + 1].x = hx[need[i * 4 + 1].x]; need[i * 4 + 1].y = hy[need[i * 4 + 1].y]; need[i * 4 + 2].x = hx[need[i * 4 + 2].x]; need[i * 4 + 2].y = hy[need[i * 4 + 2].y]; need[i * 4 + 3].x = hx[need[i * 4 + 3].x]; need[i * 4 + 3].y = hy[need[i * 4 + 3].y]; need[i * 4 + 4].x = hx[need[i * 4 + 4].x]; need[i * 4 + 4].y = hy[need[i * 4 + 4].y]; } sort(s + 1, s + 1 + m); sort(need + 1, need + 1 + 4 * p); bit.n = vy.size(); bit.clear(); int cur = 1, curs = 1; rep(i, 0, vx.size()){ while(curs &lt;= m &amp;&amp; s[curs].x == i){ bit.add(s[curs].y, s[curs].val); curs++; } while(cur &lt;= 4 * p &amp;&amp; need[cur].x == i){ need[cur].val = bit.get(need[cur].y); cur++; } } sort(need + 1, need + 1 + 4 * p, [](const node &amp;a, const node &amp;b){return a.id &lt; b.id;}); rep(i, 0, p-1){ printf(&quot;%lld\\n&quot;, need[op[i].a].val + need[op[i].d].val - need[op[i].b].val - need[op[i].c].val); } } return 0;} B. super_log知识点：递归，欧拉函数，欧拉定理 扩展欧拉定理$$a^b \\equiv \\begin{cases} a^b &amp; b &lt; \\varphi(m) \\ a^{b \\bmod \\varphi(m) + \\varphi(m)} &amp; b \\ge \\varphi(m) \\ \\end{cases}\\bmod m$$ 快速幂也不知道为什么，快速幂写成这样就可以直接递归求解了。 这其中一定隐藏了什么不为人知的数论之谜。 123456789101112int up(ll a, int mod){ return a &lt; mod ? a : a % mod + mod;}int qpow(int a, int b, int mod){ int res = 1; while(b){ if(b&amp;1) res = up(1ll * res * a, mod); a = up(1ll * a * a, mod); b &gt;&gt;= 1; } return res;} 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;bits/stdc++.h&gt;#define rep(i, a, b) for(int i = (a); i &lt;= (b); ++i)#define per(i, a, b) for(int i = (a); i &gt;= (b); --i)using namespace std;typedef long long ll;const int MAXN = 1e6 + 7;int pri[MAXN], tot;int phi[MAXN];bool mark[MAXN];void init(){ tot = 0; phi[1] = 1; for(int i = 2; i &lt;= 1000000; ++i){ if(!mark[i]){ phi[i] = i - 1; pri[++tot] = i; } for(int j = 1; j &lt;= tot; ++j){ int x = pri[j]; if(i * x &gt; 1000000) break; mark[i * x] = 1; if(i%x == 0){ phi[i*x] = phi[i] * x; break; } else { phi[i*x] = phi[i] * phi[x]; } } }}int up(ll a, int mod){ return a &lt; mod ? a : a % mod + mod;}int qpow(int a, int b, int mod){ int res = 1; while(b){ if(b&amp;1) res = up(1ll * res * a, mod); a = up(1ll * a * a, mod); b &gt;&gt;= 1; } return res;}int solve(int a, int b, int m){ //calculate a^a^...^a mod m // |&lt;- b -&gt;| if(!b || m == 1) return 1; return qpow(a, solve(a, b-1, phi[m]), m);}int main(){ init(); int T, a, b, m; scanf(&quot;%d&quot;, &amp;T); while(T--){ scanf(&quot;%d %d %d&quot;, &amp;a, &amp;b, &amp;m); printf(&quot;%d\\n&quot;, solve(a, b, m) % m); } return 0;}","link":"/2019/09/05/2019-ICPC-nanjing/"},{"title":"2019-icpc-徐州网赛","text":"题目2019-icpc-徐州网赛 手速场，都是一些很经典的题目。 重新思考了一下二维偏序究竟是什么。 A. Who is better?生硬的套了两个知识点，扩展中国剩余定理和Fibonacci博弈。 套个板子就完事了。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849def egcd(a, b): &quot;&quot;&quot;扩展欧几里得&quot;&quot;&quot; if 0 == b: return 1, 0, a x, y, q = egcd(b, a % b) x, y = y, (x - a // b * y) return x, y, q n = int(input())flag = False a1, r1 = map(int, input().split()) for _ in range(n-1): a2, r2 = map(int, input().split()) R = r2-r1 x, y, d = egcd(a1, a2) tmp = a2//d if R%d != 0: flag = True r1=((x*R//d)%tmp+tmp)%tmp*a1+r1 a1=a1*(a2//d) lcm = a1ans = (r1%lcm+lcm)%lcmif flag: print(&quot;Tankernb!&quot;) exit(0)fac = [1, 2]cur = 2while True: tmp = fac[cur-1] + fac[cur-2] if tmp &gt; ans: break fac.append(tmp) cur += 1flag = Falsefor v in fac: if v == ans: flag = True breakif flag: print(&quot;Lbnb!&quot;)else: print(&quot;Zgxnb!&quot;) E. XKC’s basketball team一个比较有趣的题目。 考虑从后往前维护一个单调递增的队列，之所以这样维护是因为： 当 $i &lt; j$ 且 $a[i] &lt; a[j]$ 时 $a[i]$ 是没有任何用处的，因为它又小又靠前，在它前面的那些值如果比 $a[i]$ 小那么肯定也比 $a[j]$ 小，而且 $i &lt; j$ 所以肯定会选择 $j$ 而不是 $i$ 。 然后我们二分单调队列就能得到最先进入队列的满足的那个值的位置，最先进入队列的当然是原序列中最靠后的满足要求的值。 时间复杂度：$O(n \\cdot \\log n)$ 1234567891011121314151617181920212223242526272829303132333435#include &lt;bits/stdc++.h&gt;#define rep(i, a, b) for(int i = (a); i &lt;= (b); ++i)#define per(i, a, b) for(int i = (a); i &gt;= (b); --i)using namespace std;typedef long long ll;const int mod = 1e9+7;const int MAXN = 5e5 + 7;int a[MAXN], ans[MAXN];int main(int argc, char const *argv[]){ int n, m; scanf(&quot;%d %d&quot;, &amp;n, &amp;m); rep(i, 1, n) scanf(&quot;%d&quot;, &amp;a[i]); vector&lt;int&gt; v, vp; v.push_back(a[n]); vp.push_back(n); ans[n] = -1; per(i, n-1, 1){ auto it = lower_bound(v.begin(), v.end(), a[i]+m); if(it == v.end()){ ans[i] = -1; } else { int pos = it - v.begin(); pos = vp[pos]; ans[i] = pos - i - 1; } if(a[i] &gt; v.back()){ v.push_back(a[i]); vp.push_back(i); } } rep(i, 1, n) printf(&quot;%d%c&quot;, ans[i], i == n?'\\n':' '); return 0;} I. query又是一道二维偏序的问题。 偏序关系是全序关系的子集。 全序关系是指对于一个集合，其中的所有对 $&lt;i, j&gt;$ 都会有这种关系，也就是两两可以比较，比如整数域上的大小关系。 偏序关系是指对于一个集合，其中存在一些（注意：不是所有）对 $&lt;i, j&gt;$ 有这种关系，也就是不需要两两可以比较，比如整数域上的整除关系。 偏序关系有严格偏序和非严格偏序两种，各有自己的三条基本性质。 回到这个问题，$min(p_i, p_j) = \\gcd (p_i, p_j)$ 相当于 $p_i, p_j$存在整除关系。显然 $n$ 个数的全排列中满足整除关系的对数小于 $n\\cdot \\log n$对。 我们先将所有的满足条件的对数直接暴力筛出来，然后就抽象成了这样一个问题： 给出一些点，查询在区间 $[l, r]$ 内点的数量。 这就是一个经典的二位偏序问题了，直接对一维排序，二维用树状数组维护一下就好了。 时间复杂度：$O(n\\cdot \\log n)$ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;bits/stdc++.h&gt;#define rep(i, a, b) for(int i = (a); i &lt;= (b); ++i)#define per(i, a, b) for(int i = (a); i &gt;= (b); --i)#define debug(x) cerr &lt;&lt; #x &lt;&lt; ' ' &lt;&lt; x &lt;&lt; endl;using namespace std;typedef long long ll;const int mod = 1e9+7;const int MAXN = 2e5 + 7;int a[MAXN], id[MAXN];struct node{ int l, r, val, id; friend bool operator &lt;(const node &amp;a, const node &amp;b){ if(a.r == b.r) return a.l &lt; b.l; return a.r &lt; b.r; }}s[MAXN];struct BIT{ int e[MAXN], n; int lowbit(int x){return x&amp;-x;} void add(int x, int v){ while(x &lt;= n){ e[x] += v; x += lowbit(x); } } int get(int x){ int res = 0; while(x){ res += e[x]; x -= lowbit(x); } return res; }}bit;vector&lt;int&gt; v[MAXN];int main(int argc, char const *argv[]){ int n, m; scanf(&quot;%d %d&quot;, &amp;n, &amp;m); rep(i, 1, n){ scanf(&quot;%d&quot;, &amp;a[i]); id[a[i]] = i; } rep(i, 1, n){ for(int j = 2*a[i]; j &lt;= n; j += a[i]){ if(id[j] &lt; i) v[i].push_back(id[j]); else v[id[j]].push_back(i); } } rep(i, 1, m){ scanf(&quot;%d %d&quot;, &amp;s[i].l, &amp;s[i].r); s[i].id = i; } sort(s + 1, s + 1 + m); bit.n = n; int cur = 1; rep(i, 1, n){ rep(j, 0, (int)v[i].size()-1){ bit.add(v[i][j], 1); } while(cur &lt;= m &amp;&amp; s[cur].r == i){ s[cur].val = bit.get(i) - bit.get(s[cur].l-1); cur++; } } sort(s + 1, s + 1 + m, [](const node &amp;a, const node &amp;b){return a.id &lt; b.id;}); rep(i, 1, m) printf(&quot;%d\\n&quot;, s[i].val); return 0;} J. Random Access Iterator感觉这个题目属于很简单的树上递推的题目。 题目的意思就是从树的根结点出发，每次在节点的儿子中随机选择一个，递归，重复子节点个数次。 我们先一次 $DFS$ 更新出来子树的高度和节点的子节点树，$h[x]$ 和 $son[x]$。 首先当一个子节点子树的高度加一小于当前节点的高度的时候这个子节点是没用的，因为它更新不到最大值。 而如果可以的话就加上这个子树的递归求出最大值的概率。叶子节点概率为一。 形式化来说就是： 1234567891011function DFS(x) k &lt;- the number of sons of x if k is 0 do return 1 p &lt;- 0 for son of x do if h[x] equal to h[son] + 1 do p += DFS(son) p &lt;- p divided by k res &lt;- 1 - pow(1-p, k) return res 后半段的处理是基于这样一个原因： 假设节点取到最大值的概率为p，那么对于一个节点 $x$ 有： $$p[x] = 1 - (1 - \\frac{\\sum_{son \\in sons[x]}p[son]}{|sons[x]|})^{|sons[x]|} $$ 就是这样一个公式。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;bits/stdc++.h&gt;#define rep(i, a, b) for(ll i = (a); i &lt;= (b); ++i)#define per(i, a, b) for(ll i = (a); i &gt;= (b); --i)#define debug(x) cerr &lt;&lt; #x &lt;&lt; ' ' &lt;&lt; x &lt;&lt; endl;using namespace std;typedef long long ll;const ll MAXN = 1e6 + 7;const ll mod = 1e9 + 7;ll qpow(ll a, ll b){ ll res = 1; while(b){ if(b&amp;1) res = 1ll * res * a % mod; a = 1ll * a * a % mod; b &gt;&gt;= 1; } res = res%mod + mod; return res%mod;}ll inv(ll x){return qpow(x, mod-2);}vector&lt;ll&gt; G[MAXN];ll cor[MAXN], son[MAXN];void dfs(ll x, ll fa = 0){ ll res = 0; for(ll p: G[x]){ if(p == fa) continue; dfs(p, x); res = max(res, cor[p]); son[x]++; } cor[x] = res + 1;}ll dfs2(ll x, ll fa = 0){ if(son[x] == 0) return 1; ll p = 0; for(ll pp: G[x]){ if(pp == fa) continue; if(cor[x] == cor[pp] + 1){ p += dfs2(pp, x); } } p = p * inv(son[x]) % mod; return (1 - qpow(1-p+mod, son[x]) + mod) % mod;}int main() { ll n; scanf(&quot;%lld&quot;, &amp;n); ll u, v; rep(i, 1, n-1){ scanf(&quot;%lld %lld&quot;, &amp;u, &amp;v); G[u].push_back(v); G[v].push_back(u); } dfs(1); printf(&quot;%lld\\n&quot;, dfs2(1)); return 0;}","link":"/2019/09/09/2019-ICPC-xuzhou-online-contest/"},{"title":"BZOJ-2956-模积和","text":"题目BZOJ-2056 一道有点复杂的数论分块。 公式推导所求即为： $$\\sum_{i=1}^{n}\\sum_{j=1}^{m}{(n \\bmod i )\\cdot (m\\bmod j)(i \\neq j)}$$ 先不管$i\\neq j$的情况:$$\\sum_{i=1}^{n}(\\sum_{j=1}^{m}{(n\\bmod i) \\cdot (m\\bmod j)})$$ $$\\sum_{i=1}^{n}\\sum_{j=1}^{m}{(n-i\\lfloor \\frac{n}{i} \\rfloor)(m-j\\lfloor \\frac{m}{j} \\rfloor)}$$ $$\\sum_{i=1}^{n}\\sum_{j=1}^{m}{(n m - n\\cdot j\\lfloor \\frac{m}{j} \\rfloor - m\\cdot i\\lfloor \\frac{n}{i} \\rfloor + ij\\lfloor \\frac{n}{i} \\rfloor \\lfloor \\frac{m}{j} \\rfloor)}$$ $$n^2m^2 - n^2\\sum_{j=1}^{m}{j\\lfloor \\frac{m}{j} \\rfloor} - m^2\\sum_{i=1}^{n}i\\lfloor \\frac{n}{i} \\rfloor + \\sum_{i=1}^{n}i\\lfloor \\frac{n}{i} \\rfloor\\sum_{i=1}^{m}j\\lfloor \\frac{m}{j} \\rfloor$$ 然后在讨论$i = j$的情况: $$\\sum_{i=1}^{min(n, m)}{(n\\bmod i)\\cdot (m\\bmod i)}$$ $$\\sum_{i=1}^{min(n, m)}{(n - i\\lfloor \\frac{n}{i} \\rfloor)(m - i\\lfloor \\frac{m}{i} \\rfloor)} $$ $$\\sum_{i=1}^{min(n, m)}{n m - m\\cdot i\\lfloor \\frac{n}{i} \\rfloor - n\\cdot i\\lfloor \\frac{m}{i} \\rfloor + i^2 \\lfloor \\frac{n}{i} \\rfloor \\lfloor \\frac{m}{i} \\rfloor} $$ 然后就可以愉快的分块了。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576/************************************************************** Problem: 2956 User: Dicer Language: C++ Result: Accepted Time:184 ms Memory:1292 kb****************************************************************/ #include&lt;bits/stdc++.h&gt;#define rep(i, a, b) for(int i = (a); i &lt;= (int)(b); ++i)#define per(i, a, b) for(int i = (a); i &gt;= (int)(b); --i)#define debug(x) cout &lt;&lt; #x &lt;&lt; ' ' &lt;&lt; x &lt;&lt; endl;using namespace std; typedef long long ll;const int MAXN = 1e5 + 7;const int MOD = 19940417;const int INV = 3323403; ll cal(ll n){ ll ans = 0; for(ll i = 1, j; i &lt;= n; i = j + 1){ j = n / ( n / i); ans += (i + j) * (j - i + 1) / 2 * (n / i); ans %= MOD; } return ans;}ll cal(ll n, ll k){ ll ans = 0; for(ll i = 1, j; i &lt;= k; i = j + 1){ j = min(k, n / ( n / i)); ans += (i + j) * (j - i + 1) / 2 * (n / i); ans %= MOD; } return ans;} ll sum(ll n){ return n * (n + 1) % MOD * (2 * n + 1) % MOD * INV % MOD;} ll cal(ll n, ll m, ll k){ ll ans = 0; for(ll i = 1, j; i &lt;= k; i = j + 1){ j = min(k, min(n / (n / i), m / (m / i))); ans += (sum(j) - sum(i-1)) * (n/i) % MOD * (m/i) % MOD; ans %= MOD; } return ans;} ll mul(ll a, ll b){ a %= MOD; b %= MOD; return a * b % MOD;} int main(){ ll n, m, k; scanf(&quot;%lld%lld&quot;, &amp;n, &amp;m); k = min(n, m); long long ans = 0; ans += mul(n * n, m * m); ans -= mul(n * n, cal(m)); ans -= mul(m * m, cal(n)); ans += mul(cal(n), cal(m)); ans = ((ans % MOD) + MOD) % MOD; ans -= mul(k, n * m); ans += mul(n, cal(m, k)); ans += mul(m, cal(n, k)); ans -= cal(n, m, k); ans = ((ans % MOD) + MOD) % MOD; printf(&quot;%lld\\n&quot;, ans); return 0;}","link":"/2019/08/06/BZOJ-2956/"},{"title":"CODEVS-2370-小机房的树","text":"题目CODEVS-2370-小机房的树 一道经典的LCA问题。 题解题目就是求$u,v$两点之间的最短距离，利用$lca$的性质可以在$O(log(n))$的时间内求出答案。 也就是$dis[u] + dis[v] - 2 * dis[lca(u, v)]$，其中 $dis[u]$ 数组表示从根节点到点 $u$ 的距离。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;bits/stdc++.h&gt;#define rep(i, a, b) for(int i = (a); i &lt;= (int)(b); ++i)#define per(i, a, b) for(int i = (a); i &gt;= (int)(b); --i)#define debug(x) cerr &lt;&lt; #x &lt;&lt; ' ' &lt;&lt; x &lt;&lt; endl;using namespace std;typedef long long ll;typedef pair&lt;int, int&gt; pii;const int MAXN = 2e5 + 7;int dep[MAXN], dis[MAXN], f[MAXN][20];vector&lt;pii&gt; G[MAXN];void dfs(int x, int last = 0, int fa = -1) { f[x][0] = fa; dep[x] = dep[fa] + 1; dis[x] = dis[fa] + last; for(int i = 1; (1&lt;&lt;i) &lt;= dep[x]; ++i){ f[x][i] = f[f[x][i-1]][i-1]; } rep(i, 0, G[x].size()-1){ pii p = G[x][i]; if(p.first == fa) continue; dfs(p.first, p.second, x); }}int lca(int u, int v) { if(dep[u] &lt; dep[v]) swap(u, v); int dif = dep[u] - dep[v]; per(i, 20, 0){ if((1&lt;&lt;i) &lt;= dif){ dif -= (1&lt;&lt;i); u = f[u][i]; } } if(u == v) return u; per(i, 20, 0){ if(dep[u] &gt;= (1&lt;&lt;i) &amp;&amp; f[u][i] != f[v][i]){ u = f[u][i]; v = f[v][i]; } } return f[u][0];}int main() { int n; scanf(&quot;%d&quot;, &amp;n); int u, v, c; rep(i, 1, n-1){ scanf(&quot;%d %d %d&quot;, &amp;u, &amp;v, &amp;c); G[u].push_back(make_pair(v, c)); G[v].push_back(make_pair(u, c)); } dfs(0); int T; scanf(&quot;%d&quot;, &amp;T); while(T--){ scanf(&quot;%d %d&quot;, &amp;u, &amp;v); printf(&quot;%d\\n&quot;, dis[u] + dis[v] - 2 * dis[lca(u, v)]); } return 0;}","link":"/2019/08/06/CODEVS-2370-%E5%B0%8F%E6%9C%BA%E6%88%BF%E7%9A%84%E6%A0%91/"},{"title":"Codeforces-568-G1","text":"题目hpuoj-74 codeforces-568-G1 题解两个题目都是状压DP，有一定的相似之处，放在一起写。 第一题显然，对于每个宿舍楼内部的宿舍来说，当顺序固定了以后，可以简单的通过贪心得到最少抗议的人数。 那么，我们的主要问题就变成了，求解宿舍楼安装空调最合适的顺序。 定义$dp[sta]$表示状态为$sta$时的最少抗议人数，$cost[i][j]$表示第$i$幢寝室楼第$j$个空调的贪心值。 那么我们可以这样更新： 1234567for sta := 0 to (1&lt;&lt;n)-1 do cal = sta.count(1) for nex := 0 to n-1 do if (sta&gt;&gt;nex)&amp;1 then continue else dp[sta|1&lt;&lt;nex] = min(dp[sta|1&lt;&lt;nex], dp[sta] + cost[nex][cal+1]) 结果就是$dp[(1&lt;&lt;n)-1] $。 这样更新的理由是： 对于一个状态$sta$，用1表示宿舍楼已经被安排过位置了，0表示还没有安排，统计一下1的个数就能知道在这个状态下，下一个宿舍楼是第几个被装的，而且这个宿舍楼之前一定是没有装过。 例如： $n = 4, sta = 1001$，下一个要装第三个宿舍楼，而二号、三号宿舍楼还没有装。 因此可以更新到$sta = 1101, 1011$这两个状态。 第二题方法一定义$dp[cap][sta][last]$表示当前总和为$cap$，状态为$sta$，最后一首歌的类型为$last$，然后直接维护更新就好了。 时间复杂度：O(T*n*2^n) 方法二定义$dp[sta][last]$表示当前状态为$sta$，最后一首歌的类型为$last$，进行一下更新： 12345678for sta := 0 to (1&lt;&lt;n)-1 do for i := 1 to n do if (sta&gt;&gt;i)&amp;1 then continue for type := 1 to 3 do if type == last[i] then continue dp[sta|1&lt;&lt;(i-1)][last[i]] += dp[sta][type] 这样就能得到所有的情况，但是不一定每一种情况的$cap$都是$T$，所以我们在求和的时候进行判断： 12345678910sum = 0for sta := 0 to (1&lt;&lt;n)-1 do cap = 0 for i := 1 to n do if (sta&gt;&gt;i)&amp;1 then cap += t[i] if cap == T then for type := 1 to 3 do sum += dp[sta][type] 时间复杂度：O(n*2^n) 代码第一题123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef pair&lt;int, int &gt; pii;inline ll qpow(ll a,ll b,ll mod){ll res=1;while(b){if(b&amp;1)res = (res*a)%mod;a=(a*a)%mod;b&gt;&gt;=1;}return res;}const int mod = 1e9 + 7;const int MAXN = 2e5 + 7;int dp[1&lt;&lt;23];int f[23][2333];int a[23][23];int main(){ #ifndef ONLINE_JUDGE freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin); freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout); #endif int n, m; cin &gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt;= n; ++i){ for(int j = 1; j &lt;= m; ++j){ cin &gt;&gt; f[i][j]; } sort(f[i]+1, f[i]+1+m); } for(int i = 1; i &lt;= n; ++i){ for(int j = 1; j &lt;= n; ++j){ int cur = (j-1)*m + 1, res = 0; for(int k = 1; k &lt;= m; ++k){ if(f[i][k] &gt;= cur){ cur++; } else res++; } a[i][j] = res; } } memset(dp, 0x3f, sizeof dp); dp[0] = 0; function&lt;int(int)&gt; cal = [&amp;](int x){ int res = 0; while(x){ res += x&amp;1; x &gt;&gt;= 1; } return res; }; for(int i = 0; i &lt; (1&lt;&lt;n); ++i){ int cur = cal(i) + 1; for(int j = 0; j &lt; n; ++j){ if((i&gt;&gt;j)&amp;1) continue; dp[i|1&lt;&lt;j] = min(dp[i|1&lt;&lt;j], dp[i] + a[j+1][cur]); } } cout &lt;&lt; dp[(1&lt;&lt;n)-1] &lt;&lt; endl; return 0;} 第二题方法一12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef pair&lt;int, int &gt; pii;inline ll qpow(ll a,ll b,ll mod){ll res=1;while(b){if(b&amp;1)res = (res*a)%mod;a=(a*a)%mod;b&gt;&gt;=1;}return res;}const int mod = 1e9 + 7;const int MAXN = 2e5 + 7;int t[16], g[16];int dp[226][1&lt;&lt;15][3];int main(){ #ifndef ONLINE_JUDGE freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin); freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout); #endif int n, m; cin &gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt;= n; ++i){ cin &gt;&gt; t[i] &gt;&gt; g[i]; g[i]--; } dp[0][0][0] = 1; dp[0][0][1] = 1; dp[0][0][2] = 1; for(int i = 0; i &lt;= m; ++i){ for(int j = 0; j &lt; (1&lt;&lt;n); ++j){ for(int k = 0; k &lt; n; ++k){ if((j&gt;&gt;k)&amp;1) continue; if(i+t[k+1] &gt; m) continue; for(int type = 0; type &lt; 3; ++type){ if(type == g[k+1]) continue; // cout &lt;&lt; i+t[k+1] &lt;&lt; ' ' &lt;&lt; (j|1&lt;&lt;k) &lt;&lt; ' ' &lt;&lt; g[k+1] &lt;&lt; endl; dp[i+t[k+1]][j|1&lt;&lt;k][g[k+1]] += dp[i][j][type]; dp[i+t[k+1]][j|1&lt;&lt;k][g[k+1]] %= mod; } } } } ll res = 0; for(int i = 0; i &lt; (1&lt;&lt;n); ++i){ for(int j = 0; j &lt; 3; ++j){ res += dp[m][i][j]; res %= mod; } } cout &lt;&lt; res*qpow(2, mod-2, mod)%mod &lt;&lt; endl; return 0;} 方法二1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef pair&lt;int, int &gt; pii;inline ll qpow(ll a,ll b,ll mod){ll res=1;while(b){if(b&amp;1)res = (res*a)%mod;a=(a*a)%mod;b&gt;&gt;=1;}return res;}const int mod = 1e9 + 7;const int MAXN = 2e5 + 7;int t[16], g[16];int dp[1&lt;&lt;16][3];int main(){ #ifndef ONLINE_JUDGE freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin); freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout); #endif int n, m; cin &gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt;= n; ++i){ cin &gt;&gt; t[i] &gt;&gt; g[i]; } dp[0][1] = dp[0][2] = dp[0][3] = 1; for(int i = 0; i &lt; (1&lt;&lt;n); ++i){ for(int j = 0; j &lt; n; ++j){ if((i&gt;&gt;j)&amp;1) continue; for(int k = 1; k &lt;= 3; ++k){ if(k == g[j+1]) continue; dp[i|1&lt;&lt;j][g[j+1]] += dp[i][k]; dp[i|1&lt;&lt;j][g[j+1]] %= mod; } } } ll res = 0; for(int i = 0; i &lt; (1&lt;&lt;n); ++i){ for(int j = 1; j &lt;= 3; ++j){ int tmp = 0; for(int k = 0; k &lt; n; ++k){ if((i&gt;&gt;k)&amp;1){ tmp += t[k+1]; } } if(tmp == m){ res += dp[i][j]; res %= mod; } } } cout &lt;&lt; res*qpow(2, mod-2, mod)%mod &lt;&lt; endl; return 0;}","link":"/2019/06/24/Codeforces-568-G1/"},{"title":"Codeforces-1207-F","text":"题目题目链接 分析以前从来没有做过这种问法的题目，觉得很有意思。 本来想的是可不可以把操作转化一下改到线段树上去，结果没有想到，好像也真的不行。 然后就灵光一闪发现当询问的 $x$ ，比较大的时候暴力查询也是跑的飞快，于是就开始想大数据暴力查询。 小数据可以发现直接维护一个二维数组 $sum[x][y]$ 表示答案。 然后大小的分隔本来以为就是 $sqrt(5 \\cdot 10^5)$ ，但其实并不是，因为这道题目并不是传统意义上的分块。 而是一种用空间换时间的方法，当 $x$ 比较大的时候我们很难去更新 $sum[x][y]$，也开不了那么大的空间。 思考一下，假如分割点是 $p$，那么对于更新操作来说，因为我们需要更新所有的 $sum[x][y]$ 以便查询小数据。 所以更新的复杂度就是：$O(p)$。 对于查询操作来说：如果查询的 $x \\leq p$ ，那么我们可以直接输出答案也就是 $O(1)$。 如果查询的 $ x &gt; p$，那么我们可以暴力查询，复杂度是：$O(\\frac{5\\cdot 10^5}{x})$。具体复杂度是：$\\Omega(\\frac{5\\cdot 10^5}{p}) - O(1)$。 分析一下 $p$ 取 300~1000 都是可以的。 代码1234567891011121314151617181920212223242526272829303132333435363738#include &lt;bits/stdc++.h&gt;#define rep(i, a, b) for(int i = (a); i &lt;= (b); ++i)#define per(i, a, b) for(int i = (a); i &gt;= (b); --i)using namespace std;typedef long long ll;const int mod = 1e9+7;const int MAXN = 5e5 + 7;int a[MAXN];int sum[1001][1001];int main(int argc, char const *argv[]){ int q; scanf(&quot;%d&quot;, &amp;q); int op, x, y; while(q--){ scanf(&quot;%d %d %d&quot;, &amp;op, &amp;x, &amp;y); if(op == 1){ a[x] += y; for(int i = 1; i &lt;= 1000; ++i){ sum[i][x%i] += y; } } else { if(x &lt;= 1000){ printf(&quot;%d\\n&quot;, sum[x][y]); } else { int res = 0; while(y &lt;= 500000){ res += a[y]; y += x; } printf(&quot;%d\\n&quot;, res); } } } return 0;}","link":"/2019/08/29/Codeforces-1207-F/"},{"title":"Codeforces-622-F","text":"题目F. The Sum of the k-th Powers 题解设$F(n) = \\sum _{i=1}^n{i^k} $，当k很小的时候，可以找到一些通项公式，比如：当$k= 1 $时，$F(n) = \\frac{(n \\cdot (n+1))}{2} $，当$k=2 $时，$F(n)= \\frac{n \\cdot \\ (2 \\cdot n + 1) \\cdot (n+1)}{6} $。 可以发现，$F(n)$实际上是一个$k+1 $次多项式函数。 因此，我们就可以使用拉格朗日插值法来推导了。 确定一个k+1次多项式需要k+2个点，我们很容易通过打表得到$F(1) \\sim F(k+2)$的值。 然后代入插值公式： $$F(n) = \\sum_{i=1}^{k+2}F(i) \\times P(i) $$ $$P(i) = \\prod_{j=1, j \\neq i}^{k+2}\\frac{n-j}{i-j}$$ 所以 $$F(n) = \\sum_{i=1}^{k+2}F(i) \\times \\prod_{j=1, j \\neq i}^{k+2}\\frac{n-j}{i-j} \\ = \\sum_{i=1}^{k+2}F(i) \\times \\frac{\\prod_{j=1, j \\neq i}^{k+2}n-j}{\\prod_{j=1, j \\neq i}^{k+2}{i-j}}$$ 但是这个公式的复杂度时$O(k^2)$的，我们再优化一下。 设$T = \\prod_{j=1}^{k+2}{n-j}$，则 $$\\prod_{j=1, j \\neq i}^{k+2}n-j = \\frac{T}{n-i}$$ 对于$\\prod_{j=1, j \\neq i}^{k+2}{i-j}$，我们将它分成$i\\lt j$和$i\\gt j$两部分来考虑， $$\\prod_{j=1, j \\neq i}^{k+2}{i-j} = (i-1)!\\times(k+2-i)!\\times (-1)^{k+2-i}$$ 带入原式，得： $$F(n) = \\sum_{i=1}^{k+2}(F(i)\\times\\frac{T}{n-i}\\times\\frac{1}{(i-1)!\\times(k+2-i)!\\times (-1)^{k+2-i}})$$ 至此，我们可以通过打表的方式，在$O(k)$时间内得到$F(n)$了。 注意当$n \\leq k+2$时，该公式时不适用的，因为$T$会为$0$。 但是我们可以直接通过$F(n) = \\sum _{i=1}^n{i^k} $计算。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465/*--------------------------------- @Author: Dicer @DateTime: 2019-06-18 10:16:23---------------------------------*/#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef pair&lt;int, int&gt; pii;inline ll qpow(ll a,ll b,ll mod){ll res=1;while(b){if(b&amp;1)res = (res*a)%mod;a=(a*a)%mod;b&gt;&gt;=1;}return res;}const double eps = 1e-8;const int INF = 0x3f3f3f3f;const int mod = 1e9+7;const int MAXN = 1e6 + 7;ll F[MAXN], fac[MAXN], T;int n, k;ll inv(ll x){ return qpow(x, mod-2, mod);}void init(){ F[1] = 1; for(int i = 2; i &lt;= k+2; ++i){ F[i] = F[i-1] + qpow(i, k, mod); F[i] %= mod; } fac[0] = 1; for(int i = 1; i &lt;= k+2; ++i){ fac[i] = fac[i-1] * i; fac[i] %= mod; } T = 1; for(int i = 1; i &lt;= k+2; ++i){ T *= n - i; T %= mod; }}void solve(){ if(n &lt;= k+2){ ll res = 0; for(int i = 1; i &lt;= n; ++i){ res += qpow(i, k, mod); res %= mod; } cout &lt;&lt; res &lt;&lt; endl; return; } ll res = 0; for(int i = 1; i &lt;= k+2; ++i){ res += F[i] * T % mod * inv(n-i) % mod * inv(fac[i-1]) %mod * inv(fac[k+2-i]) %mod * ((k-i)%2 == 0?1:-1) %mod; res += mod; res %= mod; } cout &lt;&lt; res &lt;&lt; endl;}int main(int argc, char const *argv[]){ cin &gt;&gt; n &gt;&gt; k; init(); solve(); return 0;} Reference 本文题图由User:Glosser.ca - Self-made, based on Image:Lagrangepolys.png，CC BY-SA 3.0，https://commons.wikimedia.org/w/index.php?curid=5538041 参考文章 LaTex","link":"/2019/06/18/Codeforces-622-F/"},{"title":"ECNU 往年机试","text":"两场EOJ上公开的机试EOJ上好多机试题都关闭了，只剩下这两场了。 我和那一场区域赛难度的机试似乎无缘相见了。 题目简单，不想写题解。 2018 研究生面试机考 (软件工程)Link: https://acm.ecnu.edu.cn/contest/61/ A123456789101112131415161718#include&lt;bits/stdc++.h&gt;using namespace std;int main() { int n, m; cin &gt;&gt; n &gt;&gt; m; int sum = 0; for(int i = 1; i &lt;= n; i++) { int tmp = 0, x; for(int j = 1; j &lt;= m; j++) { cin &gt;&gt; x; tmp = max(tmp, x); } sum += tmp; } cout &lt;&lt; sum &lt;&lt; endl; return 0;} B12345678910111213141516171819#include&lt;bits/stdc++.h&gt;using namespace std;int arr[21][21];int main() { int n; cin &gt;&gt; n; for(int i = 1; i &lt;= n; i++) { for(int j = 1; j &lt;= i; j++) { if(j == 1 || j == i) arr[i][j] = 1; else arr[i][j] = arr[i-1][j-1] + arr[i-1][j]; } for(int j = 1; j &lt;= i; j++) { printf(&quot;%d%c&quot;, arr[i][j], (i == j)?'\\\\n':' '); } } return 0;} C123456789101112131415161718192021#include&lt;bits/stdc++.h&gt;using namespace std;string s[21];int main() { int n; cin &gt;&gt; n; for(int i = 1; i &lt;= n; i++) cin &gt;&gt; s[i]; sort(s+1, s+1+n, [](string s1, string s2) -&gt; bool { int n = min(s1.size(), s2.size()); for(int i = 0; i &lt; n; i++) { if(s1[i] &gt; s2[i]) return 1; else if(s1[i] &lt; s2[i]) return 0; else continue; } return 1; }); for(int i = 1; i &lt;= n; i++) cout &lt;&lt; s[i]; return 0;} D12345678910111213141516171819202122232425#include&lt;bits/stdc++.h&gt;using namespace std;int main() { int n, k; cin &gt;&gt; n &gt;&gt; k; map&lt;int, bool&gt; disable; for(int i = 1; i &lt;= k; i++) { int x; cin &gt;&gt; x; disable[x] = 1; } vector&lt;int&gt; dp(n+1, 0); dp[0] = 1; for(int i = 1; i &lt;= n; i++) { int sum = 0; if(i - 1 &gt;= 0 &amp;&amp; disable[i-1] == 0) sum += dp[i-1]; if(i - 2 &gt;= 0 &amp;&amp; disable[i-2] == 0) sum += dp[i-2]; if(i - 3 &gt;= 0 &amp;&amp; disable[i-3] == 0) sum += dp[i-3]; if(disable[i] == 0) dp[i] = sum; else dp[i] = 0; } cout &lt;&lt; dp[n] &lt;&lt; endl; return 0;} E123456789101112131415161718192021222324#include&lt;bits/stdc++.h&gt;using namespace std;int main() { map&lt;int, bool&gt; one; one[1] = 1; int x = 1, p = 1; while(x &lt;= 1e9) { one[x+p] = 1; x += p; p++; } int n; cin &gt;&gt; n; while(n--) { cin &gt;&gt; x; cout &lt;&lt; one[x] &lt;&lt; endl; } return 0;}/*1 2 4 7 11*/ F1234567891011121314#include&lt;bits/stdc++.h&gt;using namespace std;int main() { int n, m, k; cin &gt;&gt; n &gt;&gt; m &gt;&gt; k; int i = 0, j = 0; while(k--) { cout &lt;&lt; i + 1 &lt;&lt; ' ' &lt;&lt; j + 1 &lt;&lt; endl; i++; i %= n; j++; j %= m; } return 0;} 2018 研究生机试 (计算机系第二批)Link: https://acm.ecnu.edu.cn/contest/66/ A12a = [int(x) for x in input().split()]print(max(a[1:])) B123456789#include&lt;bits/stdc++.h&gt;using namespace std;int main() { int n; cin &gt;&gt; n; for(int i = 7; i &gt;= 0; i--) cout &lt;&lt; ((n&gt;&gt;i)&amp;1); return 0;} C12345s = input()count = 0for i in range(len(s)): count += ('0' &lt;=s[i] &lt;= '9')print(count) D1234567arr = [int(x) for x in input().split()][1:]arr = sorted(arr)# print(arr)ans = 0x7f7f7f7ffor i in range(1, len(arr)): ans = min(ans, arr[i] - arr[i-1])print(ans) E123456arr = [int(x) for x in input().split()][1:]arr.sort()arr = arr[::-1]arr.sort(key = lambda x: abs(x))arr = arr[::-1]print(','.join([str(x) for x in arr])) F1234567import structf = float(input())m = struct.pack('d', f).hex()m = str(m).upper()m = [m[i*2:i*2+2] for i in range(0, 8)][::-1]m = '-'.join(m)print(m)","link":"/2021/03/08/ECNU-%E5%BE%80%E5%B9%B4%E6%9C%BA%E8%AF%95/"},{"title":"Python连接MySQL","text":"前言毕设需要保存大量数据，于是想在服务器上运行一个数据库。 Cent OS 默认的 MySQL是Mariadb版本的，据说这个版本是在MySQL被Oracle并购之后，一些MySQL的老员工考虑到MySQL可能被商用而发行的一个免费开源版本。 1234567891011121314151617181920$ screenfetch .. root@Dicer .PLTJ. OS: CentOS &lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt; Kernel: x86_64 Linux 3.10.0-957.21.3.el7.x86_64 KKSSV' 4KKK LJ KKKL.'VSSKK Uptime: 596d 20h 16m KKV' 4KKKKK LJ KKKKAL 'VKK Packages: 569 V' ' 'VKKKK LJ KKKKV' ' 'V Shell: zsh 5.0.2 .4MA.' 'VKK LJ KKV' '.4Mb. Disk: 12G / 41G (30%) . KKKKKA.' 'V LJ V' '.4KKKKK . CPU: Intel Xeon E5-2682 v4 @ 2.494GHz .4D KKKKKKKA.'' LJ ''.4KKKKKKK FA. GPU: Cirrus Logic GD 5446 &lt;QDD ++++++++++++ ++++++++++++ GFD&gt; RAM: 488MiB / 1838MiB 'VD KKKKKKKK'.. LJ ..'KKKKKKKK FV ' VKKKKK'. .4 LJ K. .'KKKKKV ' 'VK'. .4KK LJ KKA. .'KV' A. . .4KKKK LJ KKKKA. . .4 KKA. 'KKKKK LJ KKKKK' .4KK KKSSA. VKKK LJ KKKV .4SSKK &lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt; 'MKKM' '' Mariadb查看是否安装过Mariadb1$ rpm -qs | grep mariadb 安装并启动Mariadb1234$ yum install mariadb mariadb-server$ systemctl enable mariadb$ systemctl start mariadb 安全设置1$ mysql_secure_installation 远程访问1234$ mysql -u root -h localhost -p &quot;mypassword&quot;Mariadb root@localhost:mysql&gt; UPDATE user SET host='%' WHERE user='root';Mariadb root@localhost:mysql&gt; GRANT ALL PRIVILEGES ON *.* TO 'root'@'%' IDENTIFIED BY 'mypassword' WITH GRANT OPTION;Mariadb root@localhost:mysql&gt; FLUSH PRIVILEGES; 关闭防火墙如果以上步骤都完成了以后，远程连接超时的话一般都是防火墙的问题，可以将防火墙关闭： 1$ systemctl stop firewalld.service 卸载Mariadb1234$ yum remove mariadb mariadb-server mariadb-libs$ rm -rf /var/lib/mysql$ rm /etc/my.cnf$ yum install mariadb mariadb-server Python 连接 Mariadb1234567891011import mysql.connector as conndb = conn.connect( host = 'myIP', port = 'myPort', user = 'root', password = 'myPassword', database = 'myDB')cursor = db.cursor() REFERENCEhttps://www.linode.com/docs/guides/how-to-install-mariadb-on-centos-7/","link":"/2021/03/10/Python%E8%BF%9E%E6%8E%A5MySQL/"},{"title":"拉格朗日乘数法","text":"简单来说，拉格朗日乘子法可以解决$f(\\hat x)$在一些限制条件$g_k(\\hat x) = c_k$下的极值。 Mushroom ScientistsLink Prove本题题意就是给了一个函数$f(x,y,z) = x^a + y^b + z^c$，求这个函数在约束条件$g(x,y,z) = x + y + z - S$下的最大值。 首先，设拉格朗日函数： $$L(x,y,z,\\lambda) = f - \\lambda \\cdot g$$ 然后对各个变量求偏导数： $$\\frac{\\partial L}{\\partial x} = y^b\\cdot z^c \\cdot ax^{a-1} - \\lambda$$ $$\\frac{\\partial L}{\\partial y} = x^a\\cdot z^c \\cdot by^{b-1} - \\lambda$$ $$\\frac{\\partial L}{\\partial z} = x^a\\cdot y^b \\cdot cz^{c-1} - \\lambda$$ $$\\frac{\\partial L}{\\partial \\lambda} = x + y + z - S$$ 可以解出： $$\\frac{x}{a} = \\frac{y}{b} = \\frac{z}{c}$$ 所以： $$x = \\frac{S\\cdot a}{a+b+c}, y = \\frac{S\\cdot b}{a+b+c}, z = \\frac{S\\cdot c}{a+b+c}$$ 代码12345678910111213141516171819202122#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;iomanip&gt;using namespace std; const int MAXN = 1e5 + 7;const int mod = 1e9 + 7;typedef long long ll; int main(){ cout &lt;&lt; fixed; int s; int a, b, c; cin &gt;&gt; s &gt;&gt; a &gt;&gt; b &gt;&gt; c; if(a + b + c == 0){ cout &lt;&lt; 0 &lt;&lt; ' ' &lt;&lt; 0 &lt;&lt; ' ' &lt;&lt; 0 &lt;&lt; endl; } else { cout &lt;&lt; setprecision(12) &lt;&lt; (1.0*s*a/(a+b+c)) &lt;&lt; ' ' &lt;&lt; (1.0*s*b/(a+b+c)) &lt;&lt; ' ' &lt;&lt; (1.0*s*c/(a+b+c)) &lt;&lt; endl; } return 0;} Samantha and Portfolio ManagementLink Prove约束条件下的极值问题，可以用拉格朗日乘子法解决。 约束条件：$$g(\\boldsymbol w) = \\sum_{i=1}^{n}{w_i} - 1$$ 极值方程： $$f(\\boldsymbol w) = \\sum_{i=1}^{n}{(w_i^2 \\cdot \\sigma_i^2)} = \\sum_{i=1}^{n}(w_i^2 \\cdot \\frac{1}{i})$$ 拉格朗日方程： $$L(\\boldsymbol w, \\lambda) = f(\\boldsymbol w) - \\lambda \\cdot g(\\boldsymbol w)$$ 分别对 $\\boldsymbol w , \\lambda$ 求导： $$\\frac{\\partial(L)}{\\partial(w_i)} = 2 \\frac{w_i}{i} - \\lambda$$ $$\\frac{\\partial(L)}{\\partial(\\lambda)} = g(\\boldsymbol{w}) = 1 - \\sum_{i=1}^{n}{w_i}$$ 则有： $$w_i = \\frac{\\lambda \\cdot i}{2}$$ 移项： $$\\sum_{i=1}^{n}{w_i} = \\frac{\\lambda \\cdot \\sum_{i=1}^{n}(i)}{2} = \\frac{\\lambda \\cdot n(n+1)}{4} = 1$$ 则：$$\\lambda = \\frac{4}{n(n+1)}$$ $$w_i = \\frac{\\lambda \\cdot i}{2} = \\frac{2\\cdot i}{n(n+1)}$$ 所以： $$V = \\sum_{i=1}^{n}{w_i^2\\times \\sigma_i^2 } = \\sum_{i=1}^{n}{\\frac{4\\cdot i}(n^2(n+1)^2)} = \\frac{1}{n(n+1)}$$ $$E = \\sum_{i=1}^{n}{w_i \\times \\bar r_i} = \\sum_{i=1}^{n}\\frac{(2\\cdot i \\cdot \\bar r_i)}{n(n+1)}$$ 然后就可以愉快的$O(n)$解决了。 代码1234567891011121314151617181920212223#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXN = 1e5 + 7;int r[MAXN];void print(long long a, long long b) { long long g = __gcd(a, b); a /= g; b /= g; printf(&quot;%d %d\\n&quot;, a, b);}int main(){ int n; scanf(&quot;%d&quot;, &amp;n); long long sum = 0; for(int i = 1; i &lt;= n; ++i) { scanf(&quot;%d&quot;, r+i); sum += 1LL * i * r[i]; } print(2 * sum, 1LL * n * (n+1)); print(2LL, n * (n+1)); return 0;} 参考1.Wikipedia-Lagrange-Multiplier2.http://jermmy.xyz/2017/07/27/2017-7-27-understand-lagrange-multiplier/","link":"/2019/07/19/Lagrange-Multiplier/"},{"title":"SCOI2005-骑士精神","text":"题目luoguP2324 题解首先很容易想到的是，应该用空格去跳，而不是用马，因为马的数量太多了。 第二，因为搜索状态太多，考虑用使用IDDFS + A*，有一个比较简单的估价函数就是当前状态和终态的不同元素的个数。 考虑到折返是没有任何价值的，因此在搜索过程中保留上一次搜索的方向，在本次搜索中如果是折返操作则跳过。 未跳过折返时时间：1509ms，跳过后：66ms。 可以看出来优化还是很巨大的。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566// luogu-judger-enable-o2#include&lt;bits/stdc++.h&gt;using namespace std;const int n = 5;string final = &quot;111110111100*110000100000&quot;;int dx[] = {1, 1, 2, 2, -2, -2, -1, -1};int dy[] = {2, -2, 1, -1, 1, -1, 2, -2};int dif(string s){ int res = 0; for(int i = 0; i &lt; n*n; ++i){ if(s[i] != final[i]) res++; } return res;}string s;int lim;bool suc = 0;void dfs(int cur, int last){ if(cur == lim){ //是否搜索成功 if(dif(s) == 0){ suc = 1; } return; } if(suc) return; //最优解剪枝 if(cur + max(0, dif(s) - 1) &gt; lim) return; //当前值 + 最优值 &gt; 迭代深度 int f = s.find('*'); int x = f/n, y = f%n; int xx, yy; for(int i = 0; i &lt; 8; ++i){ if(i + last == 7) continue; //防止回头，优化了很多 xx = x + dx[i]; yy = y + dy[i]; if(xx &gt;= 0 &amp;&amp; xx &lt; n &amp;&amp; yy &gt;= 0 &amp;&amp; yy &lt; n){ swap(s[xx*n + yy], s[x*n + y]); dfs(cur+1, i); swap(s[xx*n + yy], s[x*n + y]); //回溯 } }}int main(){ int T; cin &gt;&gt; T; while(T--){ s = &quot;&quot;; string tmp; for(int i = 1; i &lt;= n; ++i){ cin &gt;&gt; tmp; s += tmp; } if(dif(s) == 0) cout &lt;&lt; 0 &lt;&lt; endl; else{ suc = 0; for(int i = 1; i &lt;= 15; ++i){ lim = i; dfs(0, 9); if(suc){ cout &lt;&lt; i &lt;&lt; endl; break; } } if(!suc) cout &lt;&lt; -1 &lt;&lt; endl; } } return 0;}","link":"/2019/06/11/SCOI2005/"},{"title":"Nginx 添加SSL证书","text":"在使用Chrome浏览器时，访问没有SSL的网页时会提醒网页不安全，添加过SSL证书之后，会有一个小锁，很好看。 HTTP vs HTTPS: https://www.runoob.com/w3cnote/http-vs-https.html 申请SSL证书阿里云和腾讯云都有免费的SSL证书可以申请，我用的是阿里云的云盾SSL证书，我用的服务器也是阿里云的，所以申请下来挺快的，大概几分钟。 然后将证书下载下来，证书包含两个部分：.pem文件和.key文件，都需要上传到服务器。 1234$ scp dicer.fun.pem /home/git/SSL/# 输入服务器密码$ scp dicer.fun.key/home/git/SSL/# 输入服务器密码 修改nginx.conf在ningx.conf中添加以下内容： 123456789101112131415161718192021222324252627282930server { listen 443 ssl; listen [::]:443 ssl; server_name dicer.fun; root /usr/share/nginx/html/blog; # ssl on; ssl_certificate &quot;/home/git/SSL/dicer.fun.pem&quot;; ssl_certificate_key &quot;/home/git/SSL/dicer.fun.key&quot;; ssl_session_cache shared:SSL:1m; ssl_session_timeout 10m; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; ssl_ciphers HIGH:!aNULL:!MD5; ssl_prefer_server_ciphers on; # Load configuration files for the default server block. include /etc/nginx/default.d/*.conf; location / { } error_page 404 /404.html; location = /40x.html { } error_page 500 502 503 504 /50x.html; location = /50x.html { } } 其中 server_name, root, ssl_certificate, ssl_certificate_key 需要进行对应的修改。 验证nginx.conf 并重启服务12nginx -tnginx -s reload 重定向HTTP到HTTPS在80端口的解析中，添加重定向。 状态码301表示永久重定向。 12345678910111213141516171819202122server { listen 80 default_server; listen [::]:80 default_server; server_name dicer.fun; root /usr/share/nginx/html/blog; return 301 https://$server_name$request_uri; # 重定向 # Load configuration files for the default server block. include /etc/nginx/default.d/*.conf; location / { } error_page 404 /404.html; location = /40x.html { } error_page 500 502 503 504 /50x.html; location = /50x.html { } } 修改文件后，需要重启nginx服务。 REFERENCEShttps://segmentfault.com/a/1190000009363890 https://www.cnblogs.com/kevingrace/p/6187072.html","link":"/2021/03/14/Nginx-%E6%B7%BB%E5%8A%A0SSL%E8%AF%81%E4%B9%A6/"},{"title":"知乎回答图片爬虫","text":"有一些知乎问题下的回答中包含了很多精美的图片，比如一些壁纸、风景图。 如果想保存的话，手动一张一张的保存有太慢了。 我自己用Python爬虫实现了一个并发的知乎回答图片爬虫，只需要将知乎问题ID输入即可，还能支持多问题同时爬取。速度非常快。只需要python环境和一些很基础的网络工具包就可以了，快来试试吧！ 项目地址：ZhihuPicCrawler 项目优势 不需要登陆。 图片并发下载，速度更快。 可以限制图片的数量和大小。 支持一次同时爬取多个问题。 效果展示我们选择这个问题：有哪些你不舍得换的手机壁纸？ 可以看到问题ID是41895584，在命令行执行： 1234567891011121314151617181920212223242526$ python Spider.py -q 41895584 --num_pic 1000已获取前 10 个回答，当前链接总数为 1795图片链接爬取完毕50 images saved (21 MB).100 images saved (45 MB).150 images saved (67 MB).200 images saved (92 MB).250 images saved (114 MB).300 images saved (140 MB).350 images saved (166 MB).400 images saved (189 MB).450 images saved (213 MB).500 images saved (236 MB).550 images saved (257 MB).600 images saved (281 MB).650 images saved (302 MB).700 images saved (328 MB).750 images saved (352 MB).800 images saved (375 MB).850 images saved (398 MB).900 images saved (422 MB).950 images saved (444 MB).1000 images saved (471 MB).1011 images downloaded. Image size: 476 MB.Time cost: 147.884s. 3.219 MB/s.(base) 可以看到速度还是很快的！并且过程结果很清晰！ 爬取下来的结果： 使用方法项目通过命令行进行参数解析，因此不需要显式的修改代码。 参数的具体用途及用法如下： 123456789101112$ python Spider.py -h usage: Spider.py [-h] -q QIDS [QIDS ...] [--num_pic The number of pictures Default: 2000)] [--max_size The maximum size(KB) limitation of pictures (Default: 10000)] [--min_size The minimum size(KB) limitation of pictures (Default: 200)] [--num_workers The number of workers (Default: 20]This is a script that can download images from Zhihu.optional arguments: -h, --help show this help message and exit -q QIDS [QIDS ...], --qIDs QIDS [QIDS ...] --num_pic The number of pictures (Default: 2000) --max_size The maximum size(KB) limitation of pictures (Default: 10000) --min_size The minimum size(KB) limitation of pictures (Default: 200) --num_workers The number of workers (Default: 20)","link":"/2021/09/30/The-image-spider-of-Zhihu/"},{"title":"ZJOI2008-骑士","text":"题目luoguP2607 bzoj1040 题解基环树就是一颗多了一条边的树，多了这条边，就会产生一个环。 考虑找到这个环上的任意一条边，断掉这条边，然后图形就又变回了树。（可以证明，断环上的哪条边对结果并没有影响） 然后分别都被断掉的这条边的两个端点u、v，做树形动规。 $dp[i][0/1]$表示取不取第$i$个点的最大值。 这和luoguP1352，没有上司的舞会一样。 则这颗基环树的最大值为$max(dp[u][0], dp[v][0])$，当然因为树形动规的特点，一次动规是不能同时求出这两个值的，因此要分别对u、v进行动规。 ==两个注意事项== 非常重要的一点是，两个骑士可能互相憎恨，因此会存在重边，需要特判。 记得开long long。 处理重边的方法： 按照我的建图方式，如果存在重边&lt;u，v&gt;，那么u的可到点集合中会出现两次v。 根据这个特点就可以进行特判了。 另外，这份代码在最后一个测试点TLE了。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273// luogu-judger-enable-o2#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef pair&lt;int, int &gt; pii;inline ll qpow(ll a,ll b,ll mod){ll res=1;while(b){if(b&amp;1)res = (res*a)%mod;a=(a*a)%mod;b&gt;&gt;=1;}return res;}const int mod = 1e9 + 7;const int MAXN = 1e6 + 7;int curx, cury;bool vis[MAXN];vector&lt;int&gt; G[MAXN];ll dp[MAXN][2];int val[MAXN];void dfs(int x, int fa){ if(vis[x]){ curx = x; cury = fa; return; } vis[x] = 1; for(int i = 0; i &lt; G[x].size(); ++i){ int u = G[x][i]; if(u == fa) continue; dfs(u, x); }}void go(int x, int fa){ dp[x][0] = 0; dp[x][1] = val[x]; for(int i = 0; i &lt; G[x].size(); ++i){ int u = G[x][i]; if(u == fa) continue; if(x == curx &amp;&amp; u == cury) continue; if(u == curx &amp;&amp; x == cury) continue; go(u, x); dp[x][0] += max(dp[u][0], dp[u][1]); dp[x][1] += dp[u][0]; }}int main(){ #ifndef ONLINE_JUDGE freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin); freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout); #endif int n, x; scanf(&quot;%d&quot;, &amp;n); for(int i = 1; i &lt;= n; ++i){ scanf(&quot;%d %d&quot;, &amp;val[i], &amp;x); G[x].push_back(i); G[i].push_back(x); } ll res = 0, tmp; for(int i = 1; i &lt;= n; ++i){ if(vis[i]) continue; dfs(i, 0); // cout &lt;&lt; curx &lt;&lt; ' ' &lt;&lt; cury &lt;&lt; endl; // cout &lt;&lt; count(G[curx].begin(), G[curx].end(), cury) &lt;&lt; endl; if(count(G[curx].begin(), G[curx].end(), cury) == 2){ go(curx, 0); go(cury, 0); res += max(dp[curx][0] + dp[cury][1], dp[curx][1] + dp[cury][0]); continue; } go(curx, 0); tmp = dp[curx][0]; go(cury, 0); tmp = max(tmp, dp[cury][0]); res += tmp; } printf(&quot;%lld\\n&quot;, res); return 0;}","link":"/2019/06/11/ZJOI2008/"},{"title":"hexo博客搭建总结","text":"序言之前使用jekyll在github上搭建了一个博客。但是，原博客不支持归档和搜索功能，主题也不是特别喜欢，于是决定重新搭建自己的博客站点。这次放弃了jekyll，使用hexo搭建。主要原因是hexo支持很多插件，且性能强悍。(相中了一个特别好看的主题)。 背景本文代码均基于阿里云Centos7服务器，Manjaro Linux客户端，与hexo引擎。 选择主题在搭建博客之前当然要选择一个自己喜欢的主题了。 可以在hexo的主题官方上挑选一个。戳我 注意挑选的时候不仅要看颜值，还要看一下自己需要的功能这个主题是否支持，当然如果你自己会添加插件，那就挑你最喜欢的就好了。 客户机配置安装Git 下载Git. 修改用户名和邮箱。 12345# 将此处的&quot;yourname&quot;替换成自己的用户名git config --global user.name &quot;yourname&quot;# 将此处的&quot;youremail&quot;替换成自己的邮箱git config --global user.email &quot;youremail&quot; 创建SSH钥匙对 检查是否存在钥匙对。 $ cd ~/.ssh 若没有钥匙对，则创建钥匙对。 $ ssh-keygen -t rsa -C “youremail” 安装Nodejs 使用命令行下载Nodejs。 检查是否下载完成。 $ node -v $ npm -v 安装Hexo框架 使用npm下载hexo $ npm install -g hexo-cli 因为一下原因，npm的下载速度十分感人，建议更换 选择一个你想要存放文件的文件夹，初始化blog。 $ hexo init blog 初始化完毕之后，打开博客根目录的package.json文件，在dependencies的配置中，追加一项：&quot;hexo-deployer-git&quot;: &quot;^0.3.1&quot; 运行hexo $ hexo s 然后在浏览器输入：｀localhost:4000｀，如果出现hexo的界面就说明已经搭建成功了。 如果有包缺失，根据提示下载相应的包，再次尝试即可。 服务端配置首先，进行服务端的系统更新。 $ yum update -y 更新完系统后，输入一下代码查看系统版本。 $ cat /etc/centos-release 安装Nginx安装Nginx分为以下几步。第一，配置Nginx官方源。第二，安装Nginx。第三，配置Nginx配置文件。1、配置Nginx官方源输入以下代码，新建一个文件以配置Nginx源 1$ vi /etc/yum.repos.d/nginx.repo 在打开的文件中输入以下代码，输入完毕之后，按 “esc” 键退出编辑模式， 输入 “:wq” 保存退出。 12345[nginx]name=nginx repobaseurl=http://nginx.org/packages/mainline/centos/7/$basearch/gpgcheck=0enabled=1 2、安装Nginx输入以下代码进行安装。 1$ yum install nginx -y 3、启动Nginx并设置开机自启输入以下代码: 12$ systemctl start nginx$ systemctl enable nginx 进行到这里，你已经可以把服务器ip复制到浏览器就可以看到Nginx的欢迎界面了。 4、配置Nginx接下来，需要修改一下nginx的相关配置，包括设置网站根目录以及配置域名。输入以下代码，打开Nginx的配置文件。(注：此处假定读者已完成了域名备案以及域名解析。) 1$ vi /etc/nginx/conf.d/default.conf 依照下图进行修改，将“/usr/share/nginx/html”改为“/usr/share/nginx/html/blog”。 至此，Nginx的配置就基本完成了。 安装Nodejs输入以下代码进行Nodejs的安装。 1$ yum install nodejs 可输入node -v以及npm -v查看node的版本。至此，Nodejs的安装就完成了。 安装Git以及进行相关配置1、输入以下代码，进行Git的安装 1$ yum install git 2、创建git用户以及设置密码输入以下代码： 1234# 创建用户,用户名为git$ adduser git# 设置密码$ passwd git 3、把git用户添加到sudo用户组中输入以下代码sudo vi /etc/sudoers，打开sudoers文件，输入:/root进行搜索，搜索到代码行root ALL=(ALL) ALL,然后在这一行下添加以下代码git ALL=(ALL) ALL。输入完毕之后，按wq!强制保存退出vi。 4、切换到git用户，添加SSH Key文件并且设置相应的读写与执行权限。输入以下代码： 123456# 切换用户$ su git# 创建目录$ mkdir ~/.ssh# 新建文件$ vim ~/.ssh/authorized_keys 然后把之前在客户端设置的SSH Key,复制到authorized_keys文件中，保存后退出。 接下来设置文件权限，把authorized_keys文件设置成只有属主有读写权限，把ssh目录设置为只有属主有读、写、执行权限。代码如下： 12$ chmod 600 ~/.ssh/authorized_keys$ chmod 700 ~/.ssh 设置完后，返回客户端，打开Git Bash，输入以下代码，测试是否能连接上服务器： 12# ServerIP为你自己服务器的ip$ ssh -v git@ServerIP 注意 SSH使用非对称加密，服务端不需要生成密钥对，而只需要一个authorized_keys文件，里面存放的是你客户端的公钥。客户端应该有密钥对id_rsa和id_rsa.pub文件，客户端的authorized_keys文件应该和id_rsa.pub文件内容一致。如果SSH免密码登录失败，请反复确认上述两点。 5、重新回到服务器，在网站根目录新建一个blog文件夹，用于客户端上传文件，并且把该文件授权给git用户。代码如下： 123# 使用sudo指令，需要输入git用户的密码$ sudo mkdir -p /usr/share/nginx/html/blog$ sudo chown -R git:git /usr/share/nginx/html/blog 6、在服务器上初始化一个git裸库切换到git用户，然后切换到git用户目录，接着初始化裸库，代码如下： 123$ su git$ cd ~$ git init --bare blog.git 接着新建一个post-receive文件 1$ vim ~/blog.git/hooks/post-receive 然后在该文件中输入以下内容： 12#！/bin/shgit --work-tree=/usr/share/nginx/html/blog --git-dir=/home/git/blog.git checkout -f 保存退出之后，再输入以下代码，赋予该文件可执行权限。 1$ chmod +x ~/blog.git/hooks/post-receive 7、返回客户端，设置博客根目录下的_config.yml文件。 12345deploy: type: git repo: git@SERVER:/home/git/blog.git #此处的SERVER需改为你自己服务器的ip branch: master #这里填写分支 message: #提交的信息 保存后，在博客根目录打开Git Bash，输入以下命令： 123$ hexo clean$ hexo g$ hexo d 部署完毕之后，即可在浏览器输入你的服务器ip进行访问你的博客了。 引用fogcrane-基于CentOS搭建Hexo博客","link":"/2019/04/11/hexo_blog_construct_summary/"},{"title":"The deviation of cross entropy with softmax","text":"Softmax functionSoftmax function is used to regularize all number of a vector to [0, 1]. It is usual appeared in classification problems. By softmax, a vector with huge number can be projected to a small number range – from 0 to 1. That is useful to avoid gradient explosion &amp; vanishing. The formula of softmax as follows:$$z = [z_1, z_2, \\cdots, z_n] \\\\a = \\text{softmax}(z) = [\\frac{e^{z_1}}{\\sum{e^{z_k}}}, \\frac{e^{z_2}}{\\sum{e^{z_k}}}, \\cdots, \\frac{e^{z_n}}{\\sum{e^{z_k}}}]$$By the way, softmax function is considered as a high-dimension generalization of sigmoid function and sigmoid function is also cansidered as a 2-dim version of softmax function. The formula of sigmoid as follows:$$\\sigma(x) = \\frac{1}{1+e^{-x}}$$ Cross entropyThe cross-entropy of two probability distribution $p$ and $q$ is defined as follows:$$H(p, q) = -\\sum p_i\\log q_i$$In classification problems, $p$ is usual a one-hot vector, which have only one position is 1, and others are 0. So, the defintion of cross-entropy is simplified as follows:$$H(p, q)=-p_k\\log q_k = -\\log q_k$$We also use cross-entropy as loss function. It is very intuitive because, with the increase or decrease of $q_k$, the loss will change conversely. Calculate the derivative of loss functionThe simplest classification network as follows: Here $z$ is the output of the former neural network, $a$ is the result of softmax $z$, $\\hat y$ is the correct answer and $loss$ is the cross entropy of $a$ and $\\hat y$. The formulas as follows:$$\\begin{equation}\\begin{split}loss&amp; = \\text{cross entropy}(a, \\hat y)\\&amp; = \\text{cross entropy}(\\text{softmax}(z), \\hat y)\\end{split}\\end{equation}$$In order to make backpropagation, we need to calculate the deviation of $loss$:$$\\begin{equation}\\begin{split}\\frac{\\partial l}{\\partial \\mathbf z}&amp; = \\frac{\\partial l}{\\partial \\mathbf a}\\frac{\\partial \\mathbf a}{\\partial \\mathbf z}\\end{split}\\end{equation}$$Here $l$ is a scalar, $a$ and $z$ are vectors. First, we need to know how to calculate the derivative of a scalar $y$ by a vector $x$:$$\\frac{\\partial y}{\\partial \\mathbf x} = [\\frac{\\partial y}{\\partial x_1},\\frac{\\partial y}{\\partial x_2},\\cdots, \\frac{\\partial y}{\\partial x_n}]$$Second, how to calculate the derivative of a vector $y$ by a scalar $x$:$$\\frac{\\partial \\mathbf y}{\\partial x} =\\begin{bmatrix}\\frac{\\partial y_1}{\\partial x} \\\\ \\frac{\\partial y_2}{\\partial x}\\\\ \\vdots \\\\ \\frac{\\partial y_n}{\\partial x}\\end{bmatrix}$$ And, how to calculate the derivative of a vector $y$ by a vector $x$:$$\\frac{\\partial \\mathbf y}{\\partial \\mathbf x} =\\begin{bmatrix}\\frac{\\partial y_1}{\\partial x_1} &amp; \\frac{\\partial y_1}{\\partial x_2} &amp; \\cdots &amp; \\frac{\\partial y_1}{\\partial x_n}\\\\\\frac{\\partial y_2}{\\partial x_1} &amp; \\frac{\\partial y_2}{\\partial x_2} &amp; \\cdots &amp; \\frac{\\partial y_2}{\\partial x_n} \\\\\\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\\\frac{\\partial y_n}{\\partial x_1} &amp; \\frac{\\partial y_n}{\\partial x_2} &amp; \\cdots &amp; \\frac{\\partial y_n}{\\partial x_n}\\end{bmatrix}$$We can infer the former two by the last one. According to the above formula, we have this result as follows:$$\\begin{split}\\frac{\\partial l}{\\partial \\mathbf a}&amp; = [\\frac{\\partial l}{\\partial a_1},\\frac{\\partial l}{\\partial a_2},\\cdots, \\frac{\\partial l}{\\partial a_k}, \\cdots, \\frac{\\partial l}{\\partial a_n}] \\\\&amp; = [0, 0, \\cdots, -\\frac{1}{a_k}, \\cdots, 0]\\end{split}$$ $$\\frac{\\partial \\mathbf a}{\\partial \\mathbf z} =\\begin{bmatrix}\\frac{\\partial a_1}{\\partial z_1} &amp; \\frac{\\partial a_1}{\\partial z_2} &amp; \\cdots &amp; \\frac{\\partial a_1}{\\partial z_n}\\\\\\frac{\\partial a_2}{\\partial z_1} &amp; \\frac{\\partial a_2}{\\partial z_2} &amp; \\cdots &amp; \\frac{\\partial a_2}{\\partial z_n} \\\\\\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\\\frac{\\partial a_n}{\\partial z_1} &amp; \\frac{\\partial a_n}{\\partial z_2} &amp; \\cdots &amp; \\frac{\\partial a_n}{\\partial z_n}\\end{bmatrix}$$ Furthermore, when $i = j$,$$\\begin{split}\\frac{\\partial a_i}{\\partial z_j}&amp; = \\frac{\\partial \\frac{e^{z_i}}{\\sum{e^{z_k}}}}{\\partial z_j} \\\\&amp; = \\frac{e^{z_i}\\sum e^{z_k} - e^{z_i}e^{z_i}}{(\\sum e^{z_k})^2} \\\\&amp; = a_i - a_i^2 \\\\&amp; = a_i(1-a_i)\\end{split}$$When $i \\neq j$,$$\\begin{split}\\frac{\\partial a_i}{\\partial z_j}&amp; = \\frac{\\partial \\frac{e^{z_i}}{\\sum{e^{z_k}}}}{\\partial z_j} \\\\&amp; = \\frac{0-e^{z_i}e^{z_j}}{(\\sum{e^{z_k}})^2} \\\\&amp; = -a_ia_j\\end{split}$$So,$$\\frac{\\partial \\mathbf a}{\\partial \\mathbf z} =\\begin{bmatrix}a_1(1-a_1) &amp; -a_1a_2 &amp; \\cdots &amp; -a_1a_n\\\\-a_2a_1 &amp; a_2(1-a_2) &amp; \\cdots &amp; -a_2a_n \\\\\\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\-a_na_1 &amp; a_na_2 &amp; \\cdots &amp; a_n(1-a_n) \\\\\\end{bmatrix}$$But actually, due to only $\\frac{\\partial l}{\\partial a_k} = -\\frac{1}{a_k}$, and others are 0, we just need to calculate $\\frac{\\partial a_k}{\\partial \\mathbf z}$. Finally, the derivative of $l$ as follows:$$\\begin{equation}\\begin{split}\\frac{\\partial l}{\\partial \\mathbf z}&amp; = \\frac{\\partial l}{\\partial \\mathbf a}\\frac{\\partial \\mathbf a}{\\partial \\mathbf z} \\\\&amp; = [a_1, a_2, \\cdots, a_k-1, \\cdots, a_n] \\\\&amp; = \\mathbf a - \\mathbf y\\end{split}\\end{equation}$$What a beautiful answer! End.","link":"/2021/06/28/The-deviation-of-cross-entropy-with-softmax/"},{"title":"luogu-P1131","text":"题目时态同步 一道双 $dfs$ 的题目。 分析题意就是给出一棵树，可以增加任意一条边的权值，问最少增加多少可以让所有叶子节点到跟节点的距离相等。 先跑一边 $dfs$ 求出所有节点到根节点的距离，再统计出以每个节点为根的子树上的所有点到根节点的距离的最大值。 然后再做一次 $dfs$ ，当一棵子树中离根节点最远的那个节点到根节点的距离都小于所有树中的距离最大的那个的话就可以考虑增加当前子树的根节点与它父亲节点之间的距离了，因为子树中所有节点的距离都需要增大，增大这条边一定是消耗最少的，因为这条边被所有子树上的节点复用了。然后递归下去。 说起来有点复杂，举个例子吧： 比如对于： 5 1 1 2 1 1 3 5 2 4 2 2 5 3 先把图画出来，有三个叶子节点，3 4 5，你会发现 1 到 3 的距离是最远的，因此 4 5 到根节点需要增加，而它们到根节点的路径在 1 2 这条边上重合了，因此我们可以优先在这条边上加，加到子树上有些叶子节点已经达到的最大值。然后向下递归。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;bits/stdc++.h&gt;#define rep(i, a, b) for(int i = (a); i &lt;= (b); ++i)#define per(i, a, b) for(int i = (a); i &gt;= (b); --i)#define debug(x) cerr &lt;&lt; #x &lt;&lt; ' ' &lt;&lt; x &lt;&lt; endl;using namespace std;typedef long long ll;const int mod = 1e9+7;const int MAXN = 5e5 + 7;vector&lt;pair&lt;int, int&gt; &gt; G[MAXN];ll dis[MAXN], msd[MAXN], maxdis, ans;void dfs(int x, int fa) { for(auto p: G[x]) { int v = p.first, w = p.second; if(v == fa) continue; dis[v] = dis[x] + w; dfs(v, x); msd[x] = max(msd[x], msd[v] + w); }}void dfs2(int x, int fa) { for (auto p: G[x]) { int v = p.first, w = p.second; if(v == fa) continue; ans += msd[x] - msd[v] - w; dfs2(v, x); }}int main(int argc, char const *argv[]){ int n, rt; scanf(&quot;%d %d&quot;, &amp;n, &amp;rt); int u, v, w; rep(i, 1, n-1){ scanf(&quot;%d %d %d&quot;, &amp;u, &amp;v, &amp;w); G[u].push_back({v, w}); G[v].push_back({u, w}); } dfs(rt, 0); dfs2(rt, 0); printf(&quot;%lld\\n&quot;, ans); return 0;}","link":"/2019/09/18/luogu-P1131/"},{"title":"TJOI2013-松鼠聚会","text":"题目P3964 [TJOI2013]松鼠聚会 关于曼哈顿坐标系和切比雪夫坐标系之间的相互转换。 前置技能 曼哈顿坐标系是通过切比雪夫坐标系旋转$45 ^\\circ $后，再缩小到原来的一半得到的。 将一个点 $(x, y)$ 的坐标变为 $(x+y, x-y)$ 后，原坐标系中的曼哈顿距离等于新坐标系中的切比雪夫距离 将一个点 $(x, y)$ 的坐标变为 $(\\frac{x+y}{2}, \\frac{x-y}{2})$ 后，原坐标系中的切比雪夫距离等于新坐标系中的曼哈顿距离 分析首先，原题中定义的距离是切比雪夫距离，看着非常奇怪。 我们先考虑如果是曼哈顿距离怎么做。 考虑一些点： $$(x_1, y_1), (x_2, y_2), … , (x_n, y_n)$$ 只需求出： $$\\min_{j=1}^{n}\\sum_{i=1}^{n}|x_i-x_j|+|y_i-y_j|$$。 而： $$\\sum_{i=1}^{n}|x_i-x_j|+|y_i-y_j| = \\sum_{i=1}^{n}|x_i-x_j| + \\sum_{i=1}^{n}|y_i-y_j|$$ 发现这两个维度互不影响，可以分别求出 $x, y$ 轴的。 先对 $x$ 从小到大排序，设 $pre_i$ 前 $i-1$ 个点到点 $i$ 的 $x$ 轴距离前缀和，即： $$pre_i = \\sum_{j=1}^{i-1}|x_i - x_j|$$ 同理做后缀和： $$suf_i = \\sum_{j=i+1}^{n}|x_i - x_j|$$ 则： $$\\sum_{i=1}^{n}|x_i-x_j| = pre_i + suf_i$$ $y$ 轴同理。 所以只需要先将原切比雪夫坐标系转化为曼哈顿左边系就行了。 注意转化的时候先不要除 $2$，最后在除 $2$，可以防止产生小数。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;bits/stdc++.h&gt;#define rep(i, a, b) for(int i = (a); i &lt;= (b); ++i)#define per(i, a, b) for(int i = (a); i &gt;= (b); --i)using namespace std;typedef long long ll;const int MAXN = 2e5 + 7;ll suf[MAXN], pre[MAXN];struct node{ int x, y, id; ll ansx, ansy;}s[MAXN];int main() { int n, a, b; scanf(&quot;%d&quot;, &amp;n); rep(i, 1, n){ scanf(&quot;%d %d&quot;, &amp;a, &amp;b); s[i].x = a + b; s[i].y = a - b; s[i].id = i; } sort(s + 1, s + 1 + n, [](const node &amp;a, const node &amp;b){return a.x &lt; b.x;}); suf[1] = 0; pre[n] = 0; rep(i, 2, n) suf[i] = suf[i-1] + 1ll * (i-1) * (s[i].x - s[i-1].x); per(i, n-1, 1) pre[i] = pre[i+1] + 1ll * (n-i) * (s[i+1].x - s[i].x); rep(i, 1, n) s[i].ansx = suf[i] + pre[i]; sort(s + 1, s + 1 + n, [](const node &amp;a, const node &amp;b){return a.y &lt; b.y;}); suf[1] = 0; pre[n] = 0; rep(i, 2, n) suf[i] = suf[i-1] + 1ll * (i-1) * (s[i].y - s[i-1].y); per(i, n-1, 1) pre[i] = pre[i+1] + 1ll * (n-i) * (s[i+1].y - s[i].y); rep(i, 1, n) s[i].ansy = suf[i] + pre[i]; ll ans = 1ll&lt;&lt;60; rep(i, 1, n) ans = min(ans, s[i].ansx + s[i].ansy); printf(&quot;%lld\\n&quot;, ans/2); return 0;}","link":"/2019/09/05/TJOI2013-songshujuhui/"},{"title":"洛谷P1879 &amp; P2051","text":"题目中国象棋 玉米田Corn Fields 两道DP。 中国象棋以为是状压DP，但是不知道怎么做。 换了另一种做法。 显然，每列不可能有两个以上的炮，设 $f[i][j][k]$ 表示第 $i$ 行有 $j$ 列有一个炮车，有 $k$ 列有两个炮车。那么一个炮车也没有个列数就是 $m-j-k$。 定义完状态，再来想怎么转移。考虑从 $i-1$ 行向 $i$ 行转移。第 $i$ 行最多只能有两个炮车分情况讨论： 不放炮车，$f[i][j][k] = f[i-1][j][k]$ 放一个炮车，放在没有跑车的列或者有一个炮车列：$f[i][j+1][k] = f[j-1][j][k] * (m-j-k), f[i][j][k+1] = f[i-1][j][k]*j$ 放两个炮车的情况，讨论一下就好了，看代码吧。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;bits/stdc++.h&gt;#define rep(i, a, b) for(int i = (a); i &lt;= (b); ++i)#define per(i, a, b) for(int i = (a); i &gt;= (b); --i)#define debug(x) cerr &lt;&lt; #x &lt;&lt; ' ' &lt;&lt; x &lt;&lt; endl;using namespace std;typedef long long ll;const int MOD = 9999973;const int MAXN = 2e5 + 7;//第i行有j个单跑k个双炮ll f[105][105][105];ll C[105][105];void init(){ C[0][0] = 1; rep(i, 1, 100){ rep(j, 0, i){ C[i][j] = C[i-1][j] + C[i-1][j-1]; } }}int main(int argc, char const *argv[]){ init(); int n, m; scanf(&quot;%d %d&quot;, &amp;n, &amp;m); f[0][0][0] = 1; rep(i, 1, n){ rep(j, 0, m){ rep(k, 0, m){ if(j + k &gt; m) continue; //不选 f[i][j][k] += f[i-1][j][k]; f[i][j][k] %= MOD; //选一个 选在空列 f[i][j+1][k] += f[i-1][j][k] * (m - j - k); f[i][j+1][k] %= MOD; // 选一个 选在单炮列 f[i][j-1][k+1] += f[i-1][j][k] * j; f[i][j-1][k+1] %= MOD; // 选两个 都选在空列 f[i][j+2][k] += f[i-1][j][k] * C[m - j - k][2]; f[i][j+2][k] %= MOD; // 选两个 都选在单炮列 f[i][j-2][k+2] += f[i-1][j][k] * C[j][2]; f[i][j-2][k+2] %= MOD; // 选两个 一个在空列一个在单炮列 f[i][j][k+1] += f[i-1][j][k] * (m - j - k) * j; f[i][j][k+1] %= MOD; } } } ll ans = 0; rep(i, 0, m) rep(j, 0, m) { ans += f[n][i][j]; ans %= MOD; } printf(&quot;%lld\\n&quot;, ans); return 0;} 玉米田状压DP，先保存每一行的状态，在求出有效的状态。 枚举有效的状态，判断是否和土地状况冲突，不冲突再枚举上一行的状态，如果和当前行不冲突，那么就是有效的转移。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;bits/stdc++.h&gt;#define rep(i, a, b) for(int i = (a); i &lt;= (b); ++i)#define per(i, a, b) for(int i = (a); i &gt;= (b); --i)#define debug(x) cerr &lt;&lt; #x &lt;&lt; ' ' &lt;&lt; x &lt;&lt; endl;using namespace std;typedef long long ll;const int MOD = 1e9;const int MAXN = 2e5 + 7;ll f[15][5005];bool g[5005];int mp[15][15];int field[15];int main(int argc, char const *argv[]){ int n, m; scanf(&quot;%d %d&quot;, &amp;n, &amp;m); rep(i, 1, n){ rep(j, 1, m){ scanf(&quot;%d&quot;, &amp;mp[i][j]); field[i] &lt;&lt;= 1; field[i] |= mp[i][j]; } } //求出可行状态集 vector&lt;int&gt; sta; rep(i, 0, (1&lt;&lt;m)-1) if(!((i &amp; i&gt;&gt;1)||(i &amp; i&lt;&lt;1))) sta.push_back(i); f[0][0] = 1; rep(i, 1, n) { //枚举当前行的状态 for(int j: sta) { //如果和土地状况不冲突 if((j &amp; field[i]) == j) { //枚举上一行的状态 for(int k: sta) { //如果也不冲突 if((j &amp; k) == 0) { //可行的转移 f[i][j] += f[i-1][k], f[i][j] %= MOD; } } } } } ll ans = 0; rep(i, 0, (1&lt;&lt;m)-1) { ans += f[n][i]; ans %= MOD; } printf(&quot;%lld\\n&quot;, ans); return 0;}","link":"/2019/09/18/luogu-P1879-P2051/"},{"title":"洛谷-P3806","text":"题目洛谷P3806 点分治模板题。 求边权树上距离为 $k$ 的点对。 分析第一眼没看到边带权，以为直接判断树的直径是否大于等于 $k$ 就行了。233333。 一道经典的点分治的题目，点分治是一种高效的求树上路径满足一定条件的路径个数，当然一条路径，对应两个端点，说成点对数也可以。 这道题目本来写成了在线，有一个点 $1.02s$ 过不去，本来想着卡卡就能过去了，可是去看了看别人的代码，发现总共只需要 $200+ms$ 就够了。想着是自己写搓了，然后翻开了题解，发现可以同时对所有的询问进行查询，没有必要一个一个查。改了改，就过了。 点分治还是比较考验对 $dfs$ 的理解的，因为这道题就有三个 $dfs$ ，甚至还有一个换根 $DP$ 求重心。 然后就是比较考验细节，今天两道模板题都是因为几个变量名弄混了，调了几个小时的 $BUG$ 。 讲一下思路吧。点分治最重要的两点，一是找重心，这样可以降低复杂度，二是统计和去重。 找重心每道题目都是一样的，就不说了。 这道题的统计就是，对于每一个重心树，先统计所有节点到根节点的距离，因为距离范围不超过 $1e7$ 可以用数组保存，剩下一个 $map$ 的 $log$ ，比较重要的是统计数组不能直接清空，我们考虑将所有距离先存起来，统计一下，然后再删除就好了。去重的话，就是很常规的去重。 我统计的直接就是距离为 $k$ 的点对数。 时间复杂度： $O(n\\cdot m \\log n)$ 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include&lt;bits/stdc++.h&gt;#define rep(i, a, b) for(int i = (a); i &lt;= (b); ++i)#define per(i, a, b) for(int i = (a); i &gt;= (b); --i)#define debug(x) cerr &lt;&lt; #x &lt;&lt; ' ' &lt;&lt; x &lt;&lt; endl#define size sizeeeeeeeusing namespace std;typedef long long ll;const int MAXN = 1e4 + 7;const int MAXM = 1e7 + 7;const int MOD = 1e9 + 7;vector&lt;pair&lt;int, int&gt; &gt; G[MAXN];int son[MAXN], dep[MAXN], f[MAXN], q[MAXN], ans[MAXN], k;int root, size; int cnt[MAXM], n, m;bool vis[MAXN];void get_rt(int x, int fa) { son[x] = 1; f[x] = 0; for(auto p: G[x]) { int u = p.first; if(u == fa || vis[u]) continue; get_rt(u, x); son[x] += son[u]; f[x] = max(f[x], son[u]); } f[x] = max(f[x], size - son[x]); if(f[x] &lt; f[root]) root = x;}vector&lt;int&gt; v;void get_dep(int x, int fa) { v.push_back(dep[x]); for(auto p: G[x]) { int u = p.first, w = p.second; if(u == fa || vis[u]) continue; dep[u] = dep[x] + w; get_dep(u, x); }}void calc(int x, int w, int op) { v.clear(); dep[x] = w; get_dep(x, 0); for(int p: v) { rep(i, 1, m) if(p &lt;= q[i]) ans[i] += op * cnt[q[i] - p]; cnt[p]++; } for(int p: v) cnt[p]--;}void solve(int x) { calc(x, 0, 1); vis[x] = 1; for(auto p: G[x]) { int u = p.first, w = p.second; if(vis[u]) continue; calc(u, w, -1); root = 0; size = son[u]; get_rt(u, 0); solve(root); }}int main() { scanf(&quot;%d %d&quot;, &amp;n, &amp;m); int u, v, w; rep(i, 1, n-1) { scanf(&quot;%d %d %d&quot;, &amp;u, &amp;v, &amp;w); G[u].push_back({v, w}); G[v].push_back({u, w}); } rep(i, 1, m) scanf(&quot;%d&quot;, &amp;q[i]); f[0] = INT_MAX; size = n; root = 0; get_rt(1, 0); solve(root); rep(i, 1, m) { if(ans[i]) printf(&quot;AYE\\n&quot;); else printf(&quot;NAY\\n&quot;); } return 0;}","link":"/2019/09/28/luogu-P3806/"},{"title":"牛客练习赛-53B","text":"题目题目链接 题意求和式： $$\\sum_{i=1}^{n}{\\sum_{j=1}^{i}{i \\lfloor {\\frac{i}{j}} \\rfloor ^j}}$$ 分析更换一下枚举顺序： $$\\sum_{j=1}^{n}\\sum_{i=j}^{n}{i \\lfloor \\frac{i}{j} \\rfloor ^ j}$$ 可以发现 $i$ 在 区间 $[k\\cdot j, (k+1)\\cdot j-1]$ 内 $\\lfloor \\frac{i}{j} \\rfloor = k$ ，因此可以对每个 $j$ 做分段处理，另外 $\\lfloor \\frac{i}{j} \\rfloor ^ j$ 可以从上一个状态转移过来。 时间复杂度： $O(n \\log n)$ 代码12345678910111213141516171819202122232425#include &lt;bits/stdc++.h&gt; using namespace std; typedef long long ll;const int MAXN = 3e6 + 7;const int MOD = 1e9 + 7;ll p[MAXN]; int main () { for (int i = 1; i &lt;= 3000000; ++i) p[i] = 1; ll n; cin &gt;&gt; n; ll ans = 0; for(ll j = 1; j &lt;= n; ++j) { ll lim = n/j, l = j, r = min(2 * j - 1, n); for (ll i = 1; i &lt;= lim; ++i) { p[i] = p[i] * i % MOD; ans += (l+r)*(r-l+1)/2%MOD*p[i]%MOD; ans %= MOD; l += j; r = min(r + j, n); } } cout &lt;&lt; ans &lt;&lt; endl; return 0;}","link":"/2019/10/12/niuke-exercise-53/"},{"title":"牛客小白赛15","text":"题目牛客小白赛15 题解E. 希望希望是什么，希望是我们这个时代最珍贵的东西。 直接用一颗线段树维护区间最小值就可以了。 然后在做一个背包。 H.数据结构题一个很神奇的思路。 我们将每一个出现x的位置，放进G[x]中，然后查找第一个比r大的位置，和第一个大于定于l的位置，然后这两个位置做差就可以得到x在这段区间中的出现次数了。 代码E. 希望123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081/*--------------------------------- @Author: Dicer @DateTime: 2019-06-16 11:54:32---------------------------------*/#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef pair&lt;int, int&gt; pii;inline ll qpow(ll a,ll b,ll mod){ll res=1;while(b){if(b&amp;1)res = (res*a)%mod;a=(a*a)%mod;b&gt;&gt;=1;}return res;}const double eps = 1e-8;const int INF = 0x3f3f3f3f;const int mod = 1e9+7;const int MAXN = 2e5 + 7;struct node{ int l, r; int mid(){return (l+r)&gt;&gt;1;} int val;}s[MAXN&lt;&lt;1];ll a[MAXN], b[MAXN], dp[MAXN];void build(int l, int r, int x){ s[x].l = l; s[x].r = r; s[x].val = 500; int mid = (l+r)&gt;&gt;1; if(l == r) return; build(l, mid, x&lt;&lt;1); build(mid+1, r, x&lt;&lt;1|1);}inline void upd(int l, int r, int x, int v){ // cout &lt;&lt; l &lt;&lt; ' ' &lt;&lt; r &lt;&lt; ' ' &lt;&lt; s[x].l &lt;&lt; ' ' &lt;&lt; s[x].r &lt;&lt; ' ' &lt;&lt; v &lt;&lt; endl; if(s[x].l &gt;= l &amp;&amp; s[x].r &lt;= r){ s[x].val = min(s[x].val, v); return; } int mid = s[x].mid(); if(r &gt; mid) upd(l, r, x&lt;&lt;1|1, v); if(l &lt;= mid) upd(l, r, x&lt;&lt;1, v);}inline void pushdown(int x){ if(s[x].l == s[x].r){ a[s[x].l] = s[x].val; return; } s[x&lt;&lt;1].val = min(s[x&lt;&lt;1].val, s[x].val); s[x&lt;&lt;1|1].val = min(s[x&lt;&lt;1|1].val, s[x].val); pushdown(x&lt;&lt;1); pushdown(x&lt;&lt;1|1);}int main(int argc, char const *argv[]){ #ifndef ONLINE_JUDGE freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin); freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout); #endif int n, k, m; cin &gt;&gt; n &gt;&gt; k &gt;&gt; m; for(int i = 1; i &lt;= n; ++i) cin &gt;&gt; b[i]; build(1, n, 1); int l, r; ll c; for(int i = 1; i &lt;= m; ++i){ cin &gt;&gt; l &gt;&gt; r &gt;&gt; c; upd(l, r, 1, c); } pushdown(1); // for(int i = 1; i &lt;= n; ++i) cout &lt;&lt; a[i] &lt;&lt; ' '; // cout &lt;&lt; endl; //dp ll sum = 0; for(int i = 1; i &lt;= n; ++i){ sum += b[i]; if(b[i] &gt;= 0) continue; for(int j = k; j &gt;= a[i]; --j){ dp[j] = max(dp[j], dp[j-a[i]] - b[i]); } } cout &lt;&lt; sum+dp[k] &lt;&lt; endl; return 0;} H.数据结构题123456789101112131415161718192021222324252627282930313233343536373839404142434445/*--------------------------------- @Author: Dicer @DateTime: 2019-06-16 01:55:25---------------------------------*/#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef pair&lt;int, int&gt; pii;inline ll qpow(ll a,ll b,ll mod){ll res=1;while(b){if(b&amp;1)res = (res*a)%mod;a=(a*a)%mod;b&gt;&gt;=1;}return res;}const double eps = 1e-8;const int INF = 0x3f3f3f3f;const int mod = 20180623;const int MAXN = 2e5 + 7;int a[MAXN];vector&lt;int&gt; G[MAXN];int main(int argc, char const *argv[]){ #ifndef ONLINE_JUDGE freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin); freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout); #endif int n, m; cin &gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt;= n; ++i){ cin &gt;&gt; a[i]; G[a[i]].push_back(i); } ll x, a, b, l1, l2, r1, r2; for(int i = 1; i &lt;= m; ++i){ cin &gt;&gt; l1 &gt;&gt; r1 &gt;&gt; l2 &gt;&gt; r2 &gt;&gt; x; if(l1 &gt; r1) swap(l1, r1); if(l2 &gt; r2) swap(l2, r2); a = upper_bound(G[x].begin(), G[x].end(), r1) - lower_bound(G[x].begin(), G[x].end(), l1); b = upper_bound(G[x].begin(), G[x].end(), r2) - lower_bound(G[x].begin(), G[x].end(), l2); cout &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; b &lt;&lt; endl; cout &lt;&lt; (a%mod)*(b%mod)%mod &lt;&lt; endl; } return 0;}","link":"/2019/06/16/niukexiaobai15/"},{"title":"红楼梦札记","text":"小记昨天晚上看了一集木鱼水心做的87版红楼梦讲解，颇有兴趣，于是决定写一篇博客，记录个人感受。 说起来，曾经多次想要认真读完红楼梦原著却都不了了之，究其根本可能是我本人对其中复杂人物关系招架不住，毕竟在生活中我就不擅长这些事情。还有可能是因为书中前篇铺垫冗长，这种慢热的写法导致我还没看到精彩的部分就已经没了耐心。 确实如木鱼水心在第一篇中所说的那样，虽然同为四大名著，红楼梦却没用其他三本书那样人尽皆知。 至于我为什么想读这本书，可能因为高中的时候同学老师的不经意提起，对为何它能被评为“小说的巅峰”感到好奇，还有就是对书中所描述的美食十分感兴趣。 我为何不选择自己品读名著，观看电视剧？ 原因有二：１、没有太多的时间。２、觉得自己品读原著读不出来什么东西，很可能很快就放弃了。 本篇博客小标题与木鱼水心分p标题相同。 通灵宝玉入红尘，宝黛初会续前盟抄录 满纸荒唐言，一把辛酸泪。 都云作者痴，谁解其中味。 红尘之中美中不足且好事多磨，乐极生悲之时又人非物换，不过是到头一梦，万境归空。 好了歌 世人都道神仙好 惟有功名忘不了 古今将相在何方 荒冢一堆草末了","link":"/2019/04/23/reading-Dream-of-the-Red-Chamber/"},{"title":"sklearn踩坑","text":"这几天在做毕业设计，想做一个微博的情感分析，想着实现两种方式，一是朴素贝叶斯，二是用LSTM。 在做朴素贝叶斯的时候，据网上看到的一些文章说，训练的速度应该是很快的。但是我的训练速度却很慢，分析了一下发现是文本分词、清洗占去了大量的时间。我的语料大概12w行，20MB左右。文本处理需要一分多钟，而朴素贝叶斯的训练时间只需要一秒钟左右。 于是想把文本处理的结果，保存起来，下次直接使用，就不需要每次都多等一分钟了。 持久化原始文本的格式（csv格式）： 12345label,review1,更博了，爆照了，帅的呀，就是越来越爱你！生快傻缺[爱你][爱你][爱你]1,@张晓鹏jonathan 土耳其的事要认真对待[哈哈]，否则直接开除。@丁丁看世界 很是细心，酒店都全部OK啦。1,姑娘都羡慕你呢…还有招财猫高兴……//@爱在蔓延-JC:[哈哈]小学徒一枚，等着明天见您呢//@李欣芸SharonLee:大佬范儿[书呆子]1,美~~~~~[爱你] 处理后的文件（csv格式）： 12345label,review1,更博 爆照 帅 的 呀 越来越 爱 生快 傻 缺 [爱你] [爱你] [爱你]1,土耳其 的 事要 认真对待 [哈哈] 直接 开除 是 细心 酒店 都 全部1,姑娘 都 羡慕 呢 招财猫 高兴 [哈哈] 小 学徒 一枚 等 着 明天 见 呢 大佬 范儿 [书呆子]1,美 [爱你] 处理文件的脚本： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091import randomimport reimport jiebaimport pandas as pddef trim(text): &quot;&quot;&quot; 带有语料清洗功能的分词函数, 包含数据预处理, 可以根据自己的需求重载 使用re保证了一些本来可能会分开的表情图标不分开 return: [str] &quot;&quot;&quot; text = re.sub(&quot;\\{%.+?%\\}&quot;, &quot; &quot;, text) # 去除 {%xxx%} (地理定位, 微博话题等) # text = re.sub(&quot;@.+?( |$)&quot;, &quot; &quot;, text) # 去除 @xxx (用户名) text = re.sub(&quot;@.+?( |:)&quot;, &quot; &quot;, text) # 去除 @xxx (用户名) text = re.sub(&quot;【.+?】&quot;, &quot; &quot;, text) # 去除 【xx】 (里面的内容通常都不是用户自己写的) text = re.sub(&quot;[a-zA-Z0-9]&quot;, &quot; &quot;, text) # 去除字母和数字 icons = re.findall(&quot;\\[.+?\\]&quot;, text) # 提取出所有表情图标 text = re.sub(&quot;\\[.+?\\]&quot;, &quot;IconMark&quot;, text) # 将文本中的图标替换为`IconMark` tokens = [] # for k, w in enumerate(jieba.lcut(text)): jieba.load_userdict('./data/user_dict.txt') for w in jieba.cut(text): w = w.strip() if &quot;IconMark&quot; in w: # 将IconMark替换为原图标 for i in range(w.count(&quot;IconMark&quot;)): tokens.append(icons.pop(0)) elif w and w != '\\u200b' and w.isalpha(): # 只保留有效文本 tokens.append(w) return tokensdef load_corpus(csvFilePath, stopwordPath): &quot;&quot;&quot; 加载语料库，并进行分词，数据清洗，去除停用词 &quot;&quot;&quot; # 数据读取 df = pd.read_csv(csvFilePath) stopword = load_stopword(stopwordPath) labels, reviews = df['label'].to_list(), df['review'].to_list() trimedReviews = [] for review in reviews: # 数据清洗 trimedReview = trim(review) # 去除停用词 finalReview = [] for word in trimedReview: if word not in stopword: finalReview.append(word) trimedReviews.append(finalReview) return labels, trimedReviewsdef load_reviews(csvFilePath): df = pd.read_csv(csvFilePath) return df['label'], df['review']def load_stopword(filePath): &quot;&quot;&quot; 加载停用词 &quot;&quot;&quot; with open(filePath, encoding='UTF-8') as words: stopword = [word.strip() for word in words] return stopworddef data_suffle(labels, reviews): &quot;&quot;&quot; 打乱数据 &quot;&quot;&quot; join = list(zip(labels, reviews)) random.shuffle(join) labels, reviews = zip(*join) return list(labels), list(reviews)def pre_trim(csvFilePath, stopwordPath): &quot;&quot;&quot; 预处理csv文本，并持久化 &quot;&quot;&quot; df = pd.read_csv(csvFilePath) _, reviews = load_corpus(csvFilePath, stopwordPath) for index in range(len(reviews)): reviews[index] = ' '.join(reviews[index]) df['review'] = reviews df.to_csv(csvFilePath[:-4] + 'Trimed.csv', index=False)if __name__ == '__main__': csvFilePath = '../../corpus/100k/all.csv' stopwordPath = './data/stopword.txt' pre_trim(csvFilePath, stopwordPath) 读取文件读取文件并分割数据集123456789101112131415161718192021222324252627import timeimport pickleimport numpy as npfrom sklearn.feature_extraction.text import CountVectorizer, TfidfTransformerfrom sklearn.naive_bayes import MultinomialNBfrom sklearn.pipeline import Pipelinefrom utils import load_reviews, data_suffle# stopwordPath = './data/stopword.txt'# userDictPath = './data/user_dict.txt'csvFilePath = '../../corpus/100k/allTrimed.csv'modelPath = './data/bayes.model'# 载入自定义字典# jieba.load_userdict(userDictPath)time_start = time.time()labels, reviews = load_reviews(csvFilePath)labels, reviews = data_suffle(labels, reviews)# 1/4 分割数据集n = len(labels) // 5labels_train, reviews_train = labels[n:], reviews[n:]labels_test, reviews_test = labels[:n], reviews[:n]print(f'Load Corpus Cost {time.time() - time_start:.4f} Sec') 训练模型12345678time_start = time.time()vectorizer = CountVectorizer(max_df=0.8, min_df=5)# ⚠️坑点vec_train = vectorizer.fit_transform([np.str_(review) for review in reviews_train])clf = MultinomialNB().fit(vec_train, labels_train)print(f'Train Model Cost {time.time() - time_start:.4f} Sec') 这个地方就是我遇到的问题，如果不将reviews全部转为np.string的话，会报ValueError: np.nan is an invalid document, expected byte or unicode string.错误，但是根据sklearn的文档，似乎并没有说不能传入str类型。 测试模型12345vec_test = vectorizer.transform([np.str_(review) for review in reviews_test])pred = clf.predict(vec_test)from sklearn import metricsprint(metrics.classification_report(labels_test, pred))print(&quot;准确率:&quot;, metrics.accuracy_score(labels_test, pred)) 预测的准确率还不错，能达到85%以上。","link":"/2021/05/05/sklearn%E8%B8%A9%E5%9D%91/"},{"title":"基于高德地图 API 的 Web 课程设计","text":"Web课程设计说好的考试突然就变成了课程设计，竟然还要写一个多达20页的论文，实在是不知如何是好。 Web 考试本来应该是最简单的了，想着随便看看就过了，现在可倒好，就算是把我肚子里的东西都倒出来也凑不够20页的论文。 话虽然这样说，不过还是认真的做了一个网页的。主要基于高德地图的开放API，此处给阿里点个赞，高德地图应该是有口皆碑，用过的都知道很好。 页面随便搞了搞，做了一个大色块撞色的设计，感觉还挺好看的。排版就是简单的几个 div 布局。 然后提供了三个小功能，包括经纬度查询，地点联想查询和点击获得经纬度。都是通过 js 和提供的 API 实现的。 项目演示 HTML 部分在 head 标签里面引入高德地图的 API 和自己写好的 js 以及 css 文件。 body 里面有一个项目的名称和简介，然后就是三个显眼的功能方块，对应着三个小功能。下面就是地图本身了，直接调用 API 给出一个默认地址就可以加载了。 第一个功能方块提供了经纬度地图查询，默认为我校的地址。通过输入经纬度，然后点击确认按钮，通过按钮的 onclick 事件连接到一个 js 函数，实现地图查询。 第二个功能方块是最复杂的一个，使用了关键字补全 API，通过检测选择事件来实现地图的重新加载。 第三个功能方块分为两个部分，一个是通过监听 click 事件来实现获取点击处的经纬度，并将其填入 input 标签的内容中。然后复制按钮使用了 DOM 的 execCommand 函数进行复制。 CSS 部分地图主题用 container id 标记，通过百分比布局实现多设备自适应。 三个功能方块通过简单的媒体查询实现移动端，PC端的适应布局，个人感觉效果还是挺好的，就是在 iPad 上看有点歪，没有居中，实在是不知道是什么原因。 颜色是在网上找的一套颜色，看着也还行，也可能还有更好看的配色，不过实在是懒得调了，没有太大的意义。 JAVASCRIPT 部分三个功能方块都是 js 实现的，效果还是挺好的。工作的挺正常，有一个小 bug 是第二个功能方块在你操作过地图之后可能会失灵，我也不清楚是什么原因。 还有可以提升用户体验的方法，页面刷新前应该保存地图当前的位置，防止刷新之后地图更改，可能会造成用户不必要的麻烦。 总结最后说一说总结吧。整个东西做下来还是挺有意思的，好多功能不知道怎么实现就一直在 google ，看 API 的文档和样例。基本功能实现了之后就是不断的调样式，怎么才能更好看一点。虽然是一个很简单的项目，自己一个人做下来感觉还是很有成就感的。","link":"/2019/12/28/webProject-base-on-gaode-map/"},{"title":"使用HTTP协议实现内网文件传输","text":"需求虽然说现在各种网盘、QQ，已经可以满足我们日常基本的小文件传输的需要了，但是当文件比较大的时候还是很慢，因此我们需要一种更快的，更简洁的传输方式来做局域网内的文件传输。 解决方案考虑使用本地的一台主机做服务器，为其他同局域网内的设备（如：手机、平板电脑）提供文件传输服务，使用http协议。 工具MobaXterm、python3。 下载MobaXterm（Windows） 步骤使用MobaXterm 打开Xterm的Servers，选择http。 设置端口号、文件所在地址和开启时间。 开启服务。 使用Python 打开cmd 输入 $ python -m http.server # python3 $ python -m SimpleHTTPServers # python2 如果想要选择端口号的话，可以直接在后面添加。 Tippython方法对中文路径很不友好，不建议使用中文文件名，可能会访问不了。MobaXterm没有问题，中文文件也可以正常访问。 浏览器访问经过上述步骤，你已经可以在其他设备上访问你服务器上的文件了。 在浏览器输入你服务器的本地IP即可（如果不是80端口，则需要自己手动输入）。 经测试，网页直接下载速度约为30Mb/s。 另外，意想不到的一点是，视频文件（MP4）可以直接播放，而且丝毫没有卡顿，因此，我们还可以把它当作视频服务器，下载到电脑上的视频可以在手机📱、平板上看啦。","link":"/2019/06/25/transfer-file-use-http/"},{"title":"学期总结","text":"这个学期应该算是过的最丰富多彩的一个学期。 出去打了三场比赛，秦皇岛，银川，西安。有得有失。 秦皇岛含泪铁首，银川惊险夺金，西安奇妙得铜，这里面的一个个惊险刺激、趣味横生的故事，只有真正经历过才能体会得到吧。 在期末考试来临前的两周里，完成了两门课程设计以及五门课程的自学，希望能够得到一个好成绩。 三场比赛秦皇岛这是一场CCPC的比赛，可能是我第一次也是最后一次参加CCPC的区域赛了。 秦皇岛离学校很远，坐了一天一夜的火车，舟车劳顿。 周六的晚上吃了宾馆楼下的一家饭店，主打鱼头。本着来都来了的消费观，点了一个鱼头，一个炒三丝，还有一个记不得了，也可能是就点了这两个菜。鱼头的吃法是泡馍，鱼头特别大，我第一次见到那么大的鱼头。鱼肉一般，汤汁特别浓郁，不过好像勾的欠有点多，导致泡馍的时候馍没有很洗汤。在我们把鱼肉吃完了之后，店家看见我们鱼头都没打开，给我们说“把鱼头翻开啊，里面才是精华”。打开一看，果然，里面都是一些软糯的肉，跟鱼身子上的肉完全不一样，非常的鲜，要不是店家提醒，我们可能就要错过这美食了。炒三丝里面有一个是海参丝，这也是我第一次吃海参，口感Q弹，但是没什么自己味道，都是汤汁的味道。 比赛当天有点炸裂，签到题挂了一次，一道 tarjan 的裸题因为没学过想了很久，因此一道比较简单的 DP 很久之后才看到。决策失误，不然应该不至于成绩这么差。 比赛结束之后去了心心念念的海边，光着脚踩水踩沙子，感受着海浪扑到自己的腿上，感受着脚底的沙子随着海水一起流走。所有的失意也一起流走了，剩下了金子一样的坚韧。 银川由于银川网赛接二连三的出现问题，很多高校都拒绝参加现场赛，因此给了很多弱校偷鸡的机会，比如我校。 银川那可是相当我远了，火车又是咣当咣当不停的运行了近乎一天的时间。不过幸好这次去的人比较多，路上也不是很落寞。透过火车的窗户，看到了戈壁滩上的落日。 说是银川，实际上比赛是在石嘴山举办的。按照惯例周六去大吃了一顿，吃的是当地一个比较出名的羊肉店，确实很好吃。除了羊肉之外，还有一个花茶特别的好喝。 比赛前夕 q 神熬夜补锅，才使得现场赛顺顺利利的进行。 比赛题目确实简单，前40金，我们第四十。 然后就愉快的返程了。 西安EC 正好和四六级在同一个周末，只能周六考四六级，晚上坐一夜火车去西安，然后早上正好到赛场直接开始比赛，直接就开始比赛了。 题很难，二十多分钟签上到，然后挂机了快三个小时才写出第二道题。第三道题比赛前十几分钟才交上第一发，然后 TLE 了，发现是结构体里写了个 vector ，赶紧把 vector 提出来，改到结束前20s才改好，提交，返回了 too late，很绝望。这个时候大屏幕上时间显示还有 20s ，但是比赛却已经结束了。 学弟们三题拿到了铜，于是一起去领奖。颁发铜奖的时候突然听到了我们的队名，原来是重测了还通过了。惊喜。 期末这个学期没有怎么上课，能逃的课都逃了。就导致期末考试很难过。还有两篇课程设计是真的麻烦。拼命搞了两个星期总算是复习了个差不多，课设也做好了。等着出成绩。 2020-1-19 update:成绩都出来了，有几科分数十分不科学，低的就离谱，不知道这些老师怎么想的。 总的来说还可以，绩点3.35，总评可算进前50了。 Thumbnail by Roman Kraft on Unsplash","link":"/2020/01/11/winter-holiday-summary/"},{"title":"一个简易的Go Pool的设计与实现","text":"Goroutine 的优势和缺陷Goroutine 是 Go 语言内部实现的高并发协程模型，并且可以通过 Channel 进行快捷便利的通信。 但是也有一些缺陷：一，不支持限制 Goroutine 的数量。二，在运行完毕之后不会立即被GC（Garbage Collection）回收。 👉More About Goroutine Go Pool Pool 中主要包含三种部件： Worker - 实际执行函数 JobsChan - 将 job 提交给 Worker TasksChan - 用户将任务提交到 TasksChan，Pool 再将任务提交到 JobsChan。 另外需要定义 Task 结构，至少应该包含需要执行的函数。一个样例如下: fn - 需要执行的函数 submitTime - 提交时间 User - 提交用户 taskId - 任务ID … 通过Pool，我们可以限制goroutine的数量，并且可以复用goroutine。在一些并发量极大，单个goroutine执行任务并不繁重的情况下，可以节约很多内存。 因为虽然goroutine的初始内存只有2kb，但是如果并发量达到十万、百万级别，内存的消耗也是不容小觑的。当任务并不繁重时，一些goroutine可能被初始化之后，只执行了几行代码就被搁置了，但没有及时的GC。大量的died goroutine不必要地占用了大量内存资源。池化后，可以达到线程复用，从而节约内存。 Implementation12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788// The implementaion of a simple goroutines pool with fixed capacity// By dicer 2/25/2021package mainimport ( &quot;fmt&quot; &quot;time&quot;)// Define Tasktype Task struct{ fn func() error submitTime time.Time // Alternative property // #user // #taskID}// Return a new task with a function argFnfunc NewTask(argFn func() error) *Task { t := Task{ fn: argFn, submitTime: time.Now(), } return &amp;t}// Execute the fn of a Taskfunc (t *Task) Execute() { t.fn()}// Define Pooltype Pool struct { TasksChan chan *Task JobsChan chan *Task Cap uint}// Return a new pool with fixed capacityfunc NewPool(cap uint) *Pool { p := Pool{ TasksChan: make(chan *Task, cap), JobsChan: make(chan *Task, cap), Cap: cap, } return &amp;p}// Generate a worker entity used as a coroutinefunc (p *Pool) Worker(WorkerID int) { // take a task from JobsChan for t := range p.JobsChan { // execute this task t.Execute() // print info fmt.Printf(&quot;Worker %d has finished a task submited at %v.\\n&quot;, WorkerID, t.submitTime) }}// Run the pool with cap_size workerfunc (p *Pool) Run() { for i := 0; uint(i) &lt; p.Cap; i++ { go p.Worker(i) } for { p.JobsChan &lt;- &lt;- p.TasksChan } fmt.Println(&quot;Debug&quot;)}// Test the Poolfunc main() { t := NewTask(func() error { _, err := fmt.Println(time.Now()) return err }) p := NewPool(5) go p.Run() for { p.TasksChan &lt;- t }}","link":"/2021/02/25/%E4%B8%80%E4%B8%AA%E7%AE%80%E6%98%93%E7%9A%84Go-Pool%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/"},{"title":"考研总结","text":"虽然说是考研总结，但其实大概想写一下我去年都做了些什么，做一个年度复盘，其中最重要的就是考研了，占据了去年大概八九个月的时间。 决定考研大三的人，无非几种选择：考研，考公，工作，出国。 我以前只是纠结是考研还是工作。但是因为一个奇怪的想法：考研没考上还能去工作。说起来也好笑，这句话已经默认了考研就一定考不上，严密的逻辑应该是：考研没考上，还能找工作；考上了，读完研也能找工作；工作的时候也可以考研。因为身边的人的选择和一些信息，最后还是放弃了找工作，选择了考研。 选择其实工作还是考研，其实也没有那么重要，有价值的人在什么地方都可以发挥自己的价值。相比选择，更重要的是坚持。但是选择有很重要，在这个时代，做互联网相关，可以说站在了风口上。 我爱说一句话：尽人事，听天命。就像某地某年的语文作文题目说的一样：成功不只是努力，还有机遇也很重要。蛤曾经说过，自己不知道为什么，就坐在了现在的位子上，“组织上安排好了” 一个机遇大概从二三月份开始初步进入复习吧，这个时候还是寒假，自己也不清楚复习的方法，只是在背单词，然后就是看书。 看书，没错。这段时期疫情很严重，我没有地方去，家里也没有人，只有我自己在家。不知道是什么时候，偶尔打开了微信读书，看到了大刘的三体，鬼使神差的读了起来，上了瘾，三四天读完了三部曲。这是我第一次读长篇，很长很长，接近一百万字的书，但是读的酣畅淋漓。我迷上了书中构建的那个世界。 有人说，世界上有两种人，一种是看过三体的，另一种没有。一本书可以快速打破你和另陌生人的隔阂，只需要几个字词。三体中这样的词很多：二向箔，智子，面壁人，执剑人，黑暗森林法则。不得不佩服大刘的脑洞，一本书中充斥着极致的幻想，而且逻辑严密。 有传言说，大刘是误以为自己得了癌症，以为自己命不久矣，想在临死之前，把自己的巧思都留下了。最后得知是误诊。一个美好的巧合，也可以说是：机遇。为人类文明留下了如此璀璨的书籍。虽然有人说，三体中的许多巧思都可以拆成一本书，够大刘慢慢写一辈子了，但我还是觉得，那绝对抵不上一套三体，流芳百世。 三体之后，就开始读各种各样的书，许多经典：1984、娱乐至死，不算有趣，也不丰富，只是符合这个时代；数学之美、从一到无穷大、上帝掷骰子吗？意外的有趣，引人深思。一只特立独行的猪、活着，名家经典，值得一读，但我觉得富贵的故事并没有多么可怜，只是一个纨绔子弟，散尽家财，幡然悔悟，命运多舛的故事。 另一本大部头就是红楼梦了，看的时候废寝忘食，夜不能寐，辗转反侧。叹书中女子，义气刚节；怜书中女子，难逃时代命运；惜书中女子，终落凡尘。 时常思考读书的意义，其实主要是文学作品，时间长了，书中的内容多已淡忘，读书时的感人肺腑、肝肠寸断也已忘记。只记得只言片语，大致情景。没有什么感觉了。 太久没读书了，最近在忙找工作，之前考研也是忙得没有时间，读研的时候如果科研压力没那么大，还是希望能多读一些书籍。 无它，唯手熟而四五月份是数学的时间，题海战术，一点一点的扣。我就记得自己看了张宇的基础班，刷了两边1800。 这段时间过的很快，每天就只是做题。一杯茶一包烟，一道积分做一天。这话一点都不假，积分不会做是真的很久都做不出来。每天都把自己关在家里，屋子里窗户太小了，不知白天黑夜，不知雨雪风霜。 感觉没能总结点东西，现在想起来，自己数学复习的太没有章法了，无章可循，别人学什么就跟着学什么。缺乏合理的规划，不过那个时候的我，也没有人能给我指点一二。 数学学得慢，忘得可一点都不慢，距离考完试还不到一个月，我已经不知道自己当初学了什么了。痛心疾首。 408时间暑假的重头戏是专业课，另一个150分。408综合科目多、知识点多、考察深入，难度很大。好在数据结构有一点基础，重难点是组成原理。 在知乎上看推荐买了一本CS：APP，不到一百的价格，都说是神书。确实名不虚传，计算机中的数值表示用图表示得清清楚楚，Cache、段页式存储、虚拟内存讲的头头是道，很是受用。 王道四本书看了两遍，真题没做完，只做了十几年的题目，但是因为王道后面的课后题大部分都出自真题，也算是都看过了，也正因为如此，导致我做零几年的真题总觉得在背答案，就不想写了。王道配套的模拟题也好挺好的，主要是题目很新，课后题没有出现过，做起来比较舒服。 现在想想，这四本书确实让我对计算机有了更深刻的理解，但这却只是开始，还有浩如烟海的技术等着我去了解学习。 英语学习英语是伴随考研始终的，单词一直要背，长难句一直要看，文章每天都要读。 可能是因为我英语原来比较差吧，个人感觉英语提升对我的帮助是最大的，英文文章虽然说读起来还是比较费劲，但却没有以前的那种想读都读不懂的感觉了。挺好的。 英语的学习也是伴随一生的。考研只考了读写译，还有听说需要自己学，这两点对交流来说是更重要的。 最后考研让我懂了许多的知识，也磨砺了我的品格。 宝剑锋从磨砺出，梅花香自苦寒来。 一个更好的学位，不是终点，而是新的起点。复试加油。 2021/1/23 Dicer，于焦作","link":"/2021/01/23/%E8%80%83%E7%A0%94%E6%80%BB%E7%BB%93/"},{"title":"博客迁移","text":"白嫖的阿里云服务器今年七月份就要到期了，又白嫖了两年的腾讯云，于是想着把自己的博客迁移到腾讯云上。 之前在阿里云上部署hexo博客的时候什么都不懂，是一篇篇教程试出来的。这次在部署写一份详细一点的教程记录一下部署过程。 原理我们写博客用的是markdown格式，使用nodejs管理hexo，通过hexo渲染成html格式的静态网页，然后通过git将静态网页推送到linux服务器上，并用nginx驱动网页，然后就可以通过IP地址访问我们的博客啦，如果需要的话可以做一下域名解析。 需要的部件客户端12345$ node -vv13.14.0$ hexo versionhexo: 5.4.0hexo-cli: 4.2.0 服务器端12$ nginx -vnginx version: nginx/1.14.0 配置客户端在hexo博客的__config.yml中添加以下内容： 12345deploy: type: git repo: 'yourUsername@yourIP:yourRepoPath' branch: master message: '爷爷奶奶你关注的博主更新啦！' 服务器端创建git用户git用户专门用于管理hexo博客。 1$ useradd -m git # -m 参数可以为git用户创建一个/home/git 文件夹 创建git私有repo用于与客户端连接。 1$ git init --bare hexo_blog # hexo_blog 可以替换成任何名称，但是注意⚠️__config.yml文件中的yourRepoPath 创建post-receive⚠️该文件用于在上传时更新文件。 1$ mkdir /home/git/hexo_blog/hooks/post-receive 写入如下内容： 1234#！/bin/shgit --work-tree=/usr/share/nginx/html/blog --git-dir=/home/git/hexo_blog checkout -f# /usr/share/nginx/html/blog 可以修改为你想要存放静态网页的文件夹# /home/git/hexo_blog 注意要和你的上面👆的文件名同步 为post-receive添加执行权限，否则在执行hexo d指令时，post-receive无法执行。 另外需要将--work-tree文件的拥有者修改为git 12$ chmod +x /home/git/hexo_blog/hooks/post-receive$ chown -R git:git /usr/share/nginx/html/blog 修改nginx配置信息修改/etc/nginx/nginx.conf 1$ sudo vim /etc/nginx/nginx.conf 写入如下内容： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081# For more information on configuration, see:# * Official English Documentation: http://nginx.org/en/docs/# * Official Russian Documentation: http://nginx.org/ru/docs/user nginx;worker_processes auto;error_log /var/log/nginx/error.log;pid /run/nginx.pid;# Load dynamic modules. See /usr/share/nginx/README.dynamic.include /usr/share/nginx/modules/*.conf;events { worker_connections 1024;}http { log_format main '$remote_addr - $remote_user [$time_local] &quot;$request&quot; ' '$status $body_bytes_sent &quot;$http_referer&quot; ' '&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;'; access_log /var/log/nginx/access.log main; sendfile on; tcp_nopush on; tcp_nodelay on; keepalive_timeout 65; types_hash_max_size 2048; include /etc/nginx/mime.types; default_type application/octet-stream; # Load modular configuration files from the /etc/nginx/conf.d directory. # See http://nginx.org/en/docs/ngx_core_module.html#include # for more information. include /etc/nginx/conf.d/*.conf; server { listen 80 default_server; listen [::]:80 default_server; server_name yourDomainName; # 修改为你对应的文件名 root /usr/share/nginx/html/blog; return 301 https://$server_name$request_uri; # Load configuration files for the default server block. include /etc/nginx/default.d/*.conf; location / { } error_page 404 /404.html; location = /40x.html { } error_page 500 502 503 504 /50x.html; location = /50x.html { } } # Settings for a TLS enabled server. # server { listen 443 ssl; listen [::]:443 ssl; server_name yourDomainName; # 修改为你对应的文件名 root /usr/share/nginx/html/blog; # Load configuration files for the default server block. include /etc/nginx/default.d/*.conf; location / { } error_page 404 /404.html; location = /40x.html { } error_page 500 502 503 504 /50x.html; location = /50x.html { } }} 验证nginx.conf配置是否有误： 123$ sudo nginx -tnginx: the configuration file /etc/nginx/nginx.conf syntax is oknginx: configuration file /etc/nginx/nginx.conf test is successful 启动nginx服务12$ sudo service nginx start$ sudo service nginx restart # 重启命令 推送博客在客户端的hexo文件夹内： 12$ hexo clean &amp;&amp; hexo g &amp;&amp; hexo d# 静态网页文件生成之后，输入服务器密码 然后在yourIP:80即可访问你的博客啦。","link":"/2021/04/25/%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BB/"},{"title":"基于word2vec的红楼梦人物关系分析","text":"word2vec是Google公司在2013年提出的一种词嵌入算法。使用word2vec算法对词汇进行向量化后，原来的近义词在向量空间中是邻近的，因此word2vec可以很好的保留原来词汇之间的相似性。 本文使用gensim库实现的word2vec算法，对红楼梦中的人物关系进行分析，得到了许多有趣的结论。 获取文本首先我们需要获取原著的本文文件，并且需要保证文本文件足够「纯净」，可以减少文本处理的工作量。 可以通过爬虫，从http://www.purepen.com获取原始文本。 爬虫代码如下： 123456789101112131415161718192021222324252627282930import requestsimport randomimport timefrom bs4 import BeautifulSoupdef crawler(): ''' 爬取红楼梦 :url :return ''' path = 'http://www.purepen.com/hlm/' file = open('./data/红楼梦.txt', 'w+') for page in range(1, 121): url = path + ('000'+str(page))[-3:] + '.htm' print(url) html = requests.get(url) html.encoding = html.apparent_encoding soup = BeautifulSoup(html.text, 'lxml') title = soup.find(align = 'center').text print(title) content = soup.find(face = '宋体').text file.write(title + '\\t\\n') file.write(content + '\\t\\n') sec = random.randint(0, 3) print(&quot;Sleep %d sconds.&quot; % sec) time.sleep(sec)if __name__ == '__main__': crawler() 代码中通过sleep机制简单的避免了被反爬。 文本处理首先需要使用正则表达式将所有的标点符号去掉。红楼梦属于半白话文半文言文的问题，因此其中许多词语分词系统是不能识别的，但是因为我们这次做的只是人物关系，所以只需要把所有的人名写入用户字典就可以保证所有的人名都能被准确地识别出来。 12345678910def segment(): start = time.time() content = open('./data/红楼梦.txt', 'r').read() trimed = re.sub(r'[^\\u4e00-\\u9fa5]', ' ', content) jieba.load_userdict('./data/dict.txt') result = ' '.join(jieba.cut(trimed)) file = open('./data/cut_result.txt', 'w+') file.write(' '.join(result.split())) cost = time.time() - start print(f&quot;Segment cost: {cost:.4f}&quot;) 按道理应该是要去掉停用词的，不过我不想做，偷个懒。😛 模型训练使用gensim实现的word2vec算法进行向量化，因为文本不是很大，所以向量长度我选择的200，window大小选择的3。 123456789def train_model(): start = time.time() sentencePath = './data/cut_result.txt' modelPath = './data/hlm_model' sentence = word2vec.LineSentence(sentencePath) model = word2vec.Word2Vec(sentence, vector_size=200, window=3) model.save(modelPath) cost = time.time() - start print(f'Word2Vec model training cost: {cost:.4f}') 训练起来还是很快的，大概一秒钟就好了。 PCA降维因为原始的向量长度太大，所以我们可以先用PCA（主成分分析）将向量降到二维，然后在坐标系中画出来。 12345678910111213141516171819202122232425from gensim.models import word2vecfrom sklearn.decomposition import PCAfrom matplotlib import pyplotpyplot.rcParams['font.sans-serif'] = ['Arial Unicode MS']model = word2vec.Word2Vec.load('./data/hlm_model')allNames = [x.strip('\\n') for x in open('./data/name.txt', 'r').readlines()]X, names = [], []for name in allNames: try: X.append(model.wv[name]) names.append(name) except: print(&quot;missed name: &quot;, name)pca = PCA(n_components=2)result = pca.fit_transform(X)pyplot.scatter(result[:, 0], result[:, 1])for i, name in enumerate(names): pyplot.annotate(name, xy=(result[i, 0], result[i, 1]))# pyplot.show()pyplot.savefig('./data/relation.png', transparent=True) 因为word2vec会忽略掉频次比较小的词语，所以我们在获取词向量时需要进行异常捕捉。 让我们看一下效果吧！ 因为名字有点多，整体看起来有点拥挤。我们把焦点放在又下角，可以看到宝黛钗三个人都在，我们放大一下。 我们可以看到宝玉和黛玉紧紧挨着一起，宝黛一生吹好吧！ 最相似分析word2vec中提供了几个有趣的方法，我们可以用这些方法进一步分析一下人物关系。 代码如下： 12345678910111213141516171819202122232425262728293031from gensim.models import word2vecdef analyse(): model = word2vec.Word2Vec.load('./data/hlm_model') print('Nearest 宝玉:',model.wv.most_similar(['宝玉'])) print('Nearest 黛玉:',model.wv.most_similar(['黛玉'])) print('Nearest 宝钗:',model.wv.most_similar(['宝钗'])) print('Nearest 晴雯:',model.wv.most_similar(['晴雯'])) print('Nearest 袭人:',model.wv.most_similar(['袭人'])) print('Nearest 贾母:',model.wv.most_similar(['贾母'])) print(model.wv.doesnt_match(u&quot;贾宝玉 薛宝钗 林黛玉 史湘云&quot;.split())) print(model.wv.doesnt_match(u&quot;黛玉 元春 探春 迎春 惜春&quot;.split())) print(model.wv.doesnt_match(u&quot;贾琏 贾政 贾赦 贾敬&quot;.split())) print(model.wv.similarity('贾宝玉','林黛玉')) print(model.wv.similarity('林黛玉','薛宝钗')) print(model.wv.similarity('晴雯', '袭人')) print(model.wv.similarity('林黛玉','薛宝钗')) print(model.wv.similarity('林黛玉','宝钗')) print(model.wv.similarity('黛玉','薛宝钗')) print(model.wv.similarity('黛玉','宝钗')) who = model.wv['宝玉'] - model.wv['宝钗'] + model.wv['黛玉'] print(model.wv.most_similar(positive=[who])) who = model.wv['宝玉'] - model.wv['黛玉'] + model.wv['宝钗'] print(model.wv.most_similar(positive=[who])) if __name__ == '__main__': analyse() 结果如下： 123456789101112131415161718Nearest 宝玉: [('黛玉', 0.9654377102851868), ('袭人', 0.9432756304740906), ('贾琏', 0.9404013156890869), ('紫鹃', 0.9312815070152283), ('晴雯', 0.9278832674026489), ('鸳鸯', 0.9248123168945312), ('湘云', 0.9108842015266418), ('凤姐', 0.9095652103424072), ('宝钗', 0.9087227582931519), ('薛姨妈', 0.9083631634712219)]Nearest 黛玉: [('宝玉', 0.9654375910758972), ('宝钗', 0.9516232013702393), ('湘云', 0.9490573406219482), ('贾琏', 0.9195422530174255), ('喜不自胜', 0.9156811237335205), ('晴雯', 0.9114517569541931), ('雨村', 0.9069087505340576), ('鸳鸯', 0.9047612547874451), ('紫鹃', 0.9041048884391785), ('杜撰', 0.9008530974388123)]Nearest 宝钗: [('探春', 0.958204448223114), ('湘云', 0.9580698609352112), ('黛玉', 0.9516231417655945), ('贾琏', 0.9483581185340881), ('惜春', 0.9394745826721191), ('薛姨妈', 0.9329902529716492), ('雨村', 0.9322482943534851), ('杜撰', 0.9264885783195496), ('紫鹃', 0.9231323003768921), ('喜不自胜', 0.9216738939285278)]Nearest 晴雯: [('紫鹃', 0.9769253730773926), ('袭人', 0.9697536826133728), ('凤姐儿', 0.9683317542076111), ('香菱', 0.9670401215553284), ('鸳鸯', 0.9620832800865173), ('拍手', 0.9574575424194336), ('薛姨妈', 0.956330418586731), ('贾琏', 0.9559655785560608), ('陪笑', 0.9534842371940613), ('湘云', 0.9519651532173157)]Nearest 袭人: [('紫鹃', 0.9749440550804138), ('晴雯', 0.9697537422180176), ('凤姐儿', 0.9651725888252258), ('鸳鸯', 0.9604008793830872), ('平儿', 0.9592967629432678), ('凤姐', 0.9534151554107666), ('贾琏', 0.9518244862556458), ('薛姨妈', 0.9457788467407227), ('宝玉', 0.9432753920555115), ('香菱', 0.9285346269607544)]Nearest 贾母: [('王夫人', 0.9712321162223816), ('尤氏', 0.9515039324760437), ('贾珍', 0.9488133192062378), ('贾琏', 0.9456284046173096), ('薛姨妈', 0.937038779258728), ('凤姐', 0.9299778938293457), ('鸳鸯', 0.9244546890258789), ('邢夫人', 0.9219790101051331), ('贾蓉', 0.9125443696975708), ('雪雁', 0.9032955765724182)]史湘云元春贾敬0.98300960.98921980.969753740.98921980.69311820.646155950.95162314[('宝玉', 0.9627019166946411), ('黛玉', 0.9240608215332031), ('袭人', 0.8599908351898193), ('晴雯', 0.8383870720863342), ('紫鹃', 0.8329888582229614), ('贾琏', 0.8326756954193115), ('鸳鸯', 0.829352080821991), ('湘云', 0.8235012292861938), ('一想', 0.8234348297119141), ('香菱', 0.8150357007980347)][('贾琏', 0.9775873422622681), ('宝钗', 0.964641809463501), ('紫鹃', 0.958747923374176), ('薛姨妈', 0.9540018439292908), ('宝玉', 0.9533487558364868), ('袭人', 0.9529389142990112), ('鸳鸯', 0.9496896266937256), ('凤姐', 0.9492440223693848), ('晴雯', 0.9458354115486145), ('凤姐儿', 0.9457259178161621)] 从上面的结果可以看到，宝玉最相似的是黛玉，黛玉最相似的是宝玉，而宝钗最相似的是探春。 并且可以看到「宝玉」和「黛玉」的相似度比「贾宝玉」和「黛玉」的相似度更高，说明在文中前者往往是成对出现的。 另外，我们还得到了两个有趣的式子：$$宝玉 - 宝钗 + 黛玉 \\approx 宝玉$$ $$宝玉 - 黛玉 + 宝钗 \\approx 贾琏$$ 很有意思😂","link":"/2021/05/18/%E5%9F%BA%E4%BA%8Eword2vec%E7%9A%84%E7%BA%A2%E6%A5%BC%E6%A2%A6%E4%BA%BA%E7%89%A9%E5%85%B3%E7%B3%BB%E5%88%86%E6%9E%90/"},{"title":"2019-蓝桥杯国赛","text":"碎碎念 Day1第一年没比赛，本来以为是需要去报道的，结果不用。也没有其他的安排，就去故宫了。下午还去了北大，自己瞎逛没见到图书馆。 Day2上午在宾馆宅了一上午，下午比赛。 比赛题目突变，暴力能过杯变成了暴力骗分杯。 DP、搜索很多，甚至还有一道复杂的数据结构，蓝桥杯真的转型了。 写的很差，对答案的时候发现就没写对几道题，大概三四十分，心想凉凉。 Day3早上出了成绩发现竟然国一，激动得不行。也发现蓝桥杯还是那么水，这都能国一。 早上的招聘会约了但是没起来没去，只去了下午的颁奖，本来以后国一还能有个U盘，结果什么都没有。 颁奖典礼是真的体面，表白民族大学的小姐姐。魔术师贼帅。蓝桥大气，羡慕国特笔记本+手机。 因为是晚上十点的车，颁完奖才四点多，又去逛了逛圆明园，当天下了雨，圆明园是真的好看。 完。","link":"/2019/05/30/2019-lanqiao-guosai/"},{"title":"基本操作","text":"2021/5/22 下午九点，基本操作公众号发了一篇推送：解开谜题，获取基本操作的最新进展。原文链接 文章是一串不明所以的字符，因为公众号的排版存在许多的-，本身是不存在的。 原字符串： 1SULYDFBLVQHFHVVDUBIRUDQRSHQVRFLHWBLQWKHHOHFWURQLFDJHSULYDFBLVQRWVHFUHFBDSULYDWHPDWWHULVVRPHWKLQJRQHGRHVQWZDQWWKHZKROHZRUOGWRNQRZEXWDVHFUHWPDWWHULVVRPHWKLQJRQHGRHVQWZDQWDQBERGBWRNQRZSULYDFBLVWKHSRZHUWRVHOHFWLYHOBUHYHDORQHVHOIWRWKHZRUOGLIWZRSDUWLHVKDYHVRPHVRUWRIGHDOLQJVWKHQHDFKKDVDPHPRUBRIWKHLULQWHUDFWLRQHDFKSDUWBFDQVSHDNDERXWWKHLURZQPHPRUBRIWKLVKRZFRXOGDQBRQHSUHYHQWLWRQHFRXOGSDVVODZVDJDLQVWLWEXWWKHIUHHGRPRIVSHHFKHYHQPRUHWKDQSULYDFBLVIXQGDPHQWDOWRDQRSHQVRFLHWBZHVHHNQRWWRUHVWULFWDQBVSHHFKDWDOOLIPDQBSDUWLHVVSHDNWRJHWKHULQWKHVDPHIRUXPHDFKFDQVSHDNWRDOOWKHRWKHUVDQGDJJUHJDWHWRJHWKHUNQRZOHGJHDERXWLQGLYLGXDOVDQGRWKHUSDUWLHVWKHSRZHURIHOHFWURQLFFRPPXQLFDWLRQVKDVHQDEOHGVXFKJURXSVSHHFKDQGLWZLOOQRWJRDZDBPHUHOBEHFDXVHZHPLJKWZDQWLWWRVLQFHZHGHVLUHSULYDFBZHPXVWHQVXUHWKDWHDFKSDUWBWRDWUDQVDFWLRQKDYHNQRZOHGJHRQOBRIWKDWZKLFKLVGLUHFWOBQHFHVVDUBIRUWKDWWUDQVDFWLRQVLQFHDQBLQIRUPDWLRQFDQEHVSRNHQRIZHPXVWHQVXUHWKDWZHUHYHDODVOLWWOHDVSRVVLEOHLQPRVWFDVHVSHUVRQDOLGHQWLWBLVQRWVDOLHQWZKHQLSXUFKDVHDPDJDCLQHDWDVWRUHDQGKDQGFDVKWRWKHFOHUNWKHUHLVQRQHHGWRNQRZZKRLDPZKHQLDVNPBHOHFWURQLFPDLOSURYLGHUWRVHQGDQGUHFHLYHPHVVDJHVPBSURYLGHUQHHGQRWNQRZWRZKRPLDPVSHDNLQJRUZKDWLDPVDBLQJRUZKDWRWKHUVDUHVDBLQJWRPHPBSURYLGHURQOBQHHGNQRZKRZWRJHWWKHPHVVDJHWKHUHDQGKRZPXFKLRZHWKHPLQIHHVZKHQPBLGHQWLWBLVUHYHDOHGEBWKHXQGHUOBLQJPHFKDQLVPRIWKHWUDQVDFWLRQLKDYHQRSULYDFBLFDQQRWKHUHVHOHFWLYHOBUHYHDOPBVHOILPXVWDOZDBVUHYHDOPBVHOIWKHUHIRUHSULYDFBLQDQRSHQVRFLHWBUHTXLUHVDQRQBPRXVWUDQVDFWLRQVBVWHPVXQWLOQRZFDVKKDVEHHQWKHSULPDUBVXFKVBVWHPDQDQRQBPRXVWUDQVDFWLRQVBVWHPLVQRWDVHFUHWWUDQVDFWLRQVBVWHPDQDQRQBPRXVVBVWHPHPSRZHUVLQGLYLGXDOVWRUHYHDOWKHLULGHQWLWBZKHQGHVLUHGDQGRQOBZKHQGHVLUHGWKLVLVWKHHVVHQFHRISULYDFBSULYDFBLQDQRSHQVRFLHWBDOVRUHTXLUHVFUBSWRJUDSKBLILVDBVRPHWKLQJLZDQWLWKHDUGRQOBEBWKRVHIRUZKRPLLQWHQGLWLIWKHFRQWHQWRIPBVSHHFKLVDYDLODEOHWRWKHZRUOGLKDYHQRSULYDFBWRHQFUBSWLVWRLQGLFDWHWKHGHVLUHIRUSULYDFBDQGWRHQFUBSWZLWKZHDNFUBSWRJUDSKBLVWRLQGLFDWHQRWWRRPXFKGHVLUHIRUSULYDFBIXUWKHUPRUHWRUHYHDORQHVLGHQWLWBZLWKDVVXUDQFHZKHQWKHGHIDXOWLVDQRQBPLWBUHTXLUHVWKHFUBSWRJUDSKLFVLJQDWXUHZHFDQQRWHASHFWJRYHUQPHQWVFRUSRUDWLRQVRURWKHUODUJHIDFHOHVVRUJDQLCDWLRQVWRJUDQWXVSULYDFBRXWRIWKHLUEHQHILFHQFHLWLVWRWKHLUDGYDQWDJHWRVSHDNRIXVDQGZHVKRXOGHASHFWWKDWWKHBZLOOVSHDNWRWUBWRSUHYHQWWKHLUVSHHFKLVWRILJKWDJDLQVWWKHUHDOLWLHVRILQIRUPDWLRQLQIRUPDWLRQGRHVQRWMXVWZDQWWREHIUHHLWORQJVWREHIUHHLQIRUPDWLRQHASDQGVWRILOOWKHDYDLODEOHVWRUDJHVSDFHLQIRUPDWLRQLVUXPRUVBRXQJHUVWURQJHUFRXVLQLQIRUPDWLRQLVIOHHWHURIIRRWKDVPRUHHBHVNQRZVPRUHDQGXQGHUVWDQGVOHVVWKDQUXPRUZHPXVWGHIHQGRXURZQSULYDFBLIZHHASHFWWRKDYHDQBZHPXVWFRPHWRJHWKHUDQGFUHDWHVBVWHPVZKLFKDOORZDQRQBPRXVWUDQVDFWLRQVWRWDNHSODFHSHRSOHKDYHEHHQGHIHQGLQJWKHLURZQSULYDFBIRUFHQWXULHVZLWKZKLVSHUVGDUNQHVVHQYHORSHVFORVHGGRRUVVHFUHWKDQGVKDNHVDQGFRXULHUVWKHWHFKQRORJLHVRIWKHSDVWGLGQRWDOORZIRUVWURQJSULYDFBEXWHOHFWURQLFWHFKQRORJLHVGRZHWKHFBSKHUSXQNVDUHGHGLFDWHGWREXLOGLQJDQRQBPRXVVBVWHPVZHDUHGHIHQGLQJRXUSULYDFBZLWKFUBSWRJUDSKBZLWKDQRQBPRXVPDLOIRUZDUGLQJVBVWHPVZLWKGLJLWDOVLJQDWXUHVDQGZLWKHOHFWURQLFPRQHBFBSKHUSXQNVZULWHFRGHZHNQRZWKDWVRPHRQHKDVWRZULWHVRIWZDUHWRGHIHQGSULYDFBDQGVLQFHZHFDQWJHWSULYDFBXQOHVVZHDOOGRZHUHJRLQJWRZULWHLWZHSXEOLVKRXUFRGHVRWKDWRXUIHOORZFBSKHUSXQNVPDBSUDFWLFHDQGSODBZLWKLWRXUFRGHLVIUHHIRUDOOWRXVHZRUOGZLGHZHGRQWPXFKFDUHLIBRXGRQWDSSURYHRIWKHVRIWZDUHZHZULWHZHNQRZWKDWVRIWZDUHFDQWEHGHVWURBHGDQGWKDWDZLGHOBGLVSHUVHGVBVWHPFDQWEHVKXWGRZQFBSKHUSXQNVGHSORUHUHJXODWLRQVRQFUBSWRJUDSKBIRUHQFUBSWLRQLVIXQGDPHQWDOOBDSULYDWHDFWWKHDFWRIHQFUBSWLRQLQIDFWUHPRYHVLQIRUPDWLRQIURPWKHSXEOLFUHDOPHYHQODZVDJDLQVWFUBSWRJUDSKBUHDFKRQOBVRIDUDVDQDWLRQVERUGHUDQGWKHDUPRILWVYLROHQFHFUBSWRJUDSKBZLOOLQHOXFWDEOBVSUHDGRYHUWKHZKROHJOREHDQGZLWKLWWKHDQRQBPRXVWUDQVDFWLRQVVBVWHPVWKDWLWPDNHVSRVVLEOHIRUSULYDFBWREHZLGHVSUHDGLWPXVWEHSDUWRIDVRFLDOFRQWUDFWSHRSOHPXVWFRPHDQGWRJHWKHUGHSORBWKHVHVBVWHPVIRUWKHFRPPRQJRRGSULYDFBRQOBHAWHQGVVRIDUDVWKHFRRSHUDWLRQRIRQHVIHOORZVLQVRFLHWBZHWKHFBSKHUSXQNVVHHNBRXUTXHVWLRQVDQGBRXUFRQFHUQVDQGKRSHZHPDBHQJDJHBRXVRWKDWZHGRQRWGHFHLYHRXUVHOYHVZHZLOOQRWKRZHYHUEHPRYHGRXWRIRXUFRXUVHEHFDXVHVRPHPDBGLVDJUHHZLWKRXUJRDOVWKHFBSKHUSXQNVDUHDFWLYHOBHQJDJHGLQPDNLQJWKHQHWZRUNVVDIHUIRUSULYDFBOHWXVSURFHHGWRJHWKHUDSDFH 简单猜测是用的凯撒编码，然后就需要判断具体的偏移是多少了，有两种方法。 方法一根据维基百科中的字母频率，可以知道英文中出现次数最多的是字母e,因此如果这个字符串使用了凯撒编码，那么出现次数最多的字母代表的就应该是字母e，统计结果如下图。 由图可见，出现次数最多的是字母h，可知偏移为3。 方法二可以直接遍历所有的情况，然后观察一下。也可以得到相同的结果。 12345string = 'SULYDFBLVQHFHVVDUBIRUDQRSHQVRFLHWBLQWKHHOHFWURQLFDJHSULYDFBLVQRWVHFUHFBDSULYDWHPDWWHULVVRPHWKLQJRQHGRHVQWZDQWWKHZKROHZRUOGWRNQRZEXWDVHFUHWPDWWHULVVRPHWKLQJRQHGRHVQWZDQWDQBERGBWRNQRZSULYDFBLVWKHSRZHUWRVHOHFWLYHOBUHYHDORQHVHOIWRWKHZRUOGLIWZRSDUWLHVKDYHVRPHVRUWRIGHDOLQJVWKHQHDFKKDVDPHPRUBRIWKHLULQWHUDFWLRQHDFKSDUWBFDQVSHDNDERXWWKHLURZQPHPRUBRIWKLVKRZFRXOGDQBRQHSUHYHQWLWRQHFRXOGSDVVODZVDJDLQVWLWEXWWKHIUHHGRPRIVSHHFKHYHQPRUHWKDQSULYDFBLVIXQGDPHQWDOWRDQRSHQVRFLHWBZHVHHNQRWWRUHVWULFWDQBVSHHFKDWDOOLIPDQBSDUWLHVVSHDNWRJHWKHULQWKHVDPHIRUXPHDFKFDQVSHDNWRDOOWKHRWKHUVDQGDJJUHJDWHWRJHWKHUNQRZOHGJHDERXWLQGLYLGXDOVDQGRWKHUSDUWLHVWKHSRZHURIHOHFWURQLFFRPPXQLFDWLRQVKDVHQDEOHGVXFKJURXSVSHHFKDQGLWZLOOQRWJRDZDBPHUHOBEHFDXVHZHPLJKWZDQWLWWRVLQFHZHGHVLUHSULYDFBZHPXVWHQVXUHWKDWHDFKSDUWBWRDWUDQVDFWLRQKDYHNQRZOHGJHRQOBRIWKDWZKLFKLVGLUHFWOBQHFHVVDUBIRUWKDWWUDQVDFWLRQVLQFHDQBLQIRUPDWLRQFDQEHVSRNHQRIZHPXVWHQVXUHWKDWZHUHYHDODVOLWWOHDVSRVVLEOHLQPRVWFDVHVSHUVRQDOLGHQWLWBLVQRWVDOLHQWZKHQLSXUFKDVHDPDJDCLQHDWDVWRUHDQGKDQGFDVKWRWKHFOHUNWKHUHLVQRQHHGWRNQRZZKRLDPZKHQLDVNPBHOHFWURQLFPDLOSURYLGHUWRVHQGDQGUHFHLYHPHVVDJHVPBSURYLGHUQHHGQRWNQRZWRZKRPLDPVSHDNLQJRUZKDWLDPVDBLQJRUZKDWRWKHUVDUHVDBLQJWRPHPBSURYLGHURQOBQHHGNQRZKRZWRJHWWKHPHVVDJHWKHUHDQGKRZPXFKLRZHWKHPLQIHHVZKHQPBLGHQWLWBLVUHYHDOHGEBWKHXQGHUOBLQJPHFKDQLVPRIWKHWUDQVDFWLRQLKDYHQRSULYDFBLFDQQRWKHUHVHOHFWLYHOBUHYHDOPBVHOILPXVWDOZDBVUHYHDOPBVHOIWKHUHIRUHSULYDFBLQDQRSHQVRFLHWBUHTXLUHVDQRQBPRXVWUDQVDFWLRQVBVWHPVXQWLOQRZFDVKKDVEHHQWKHSULPDUBVXFKVBVWHPDQDQRQBPRXVWUDQVDFWLRQVBVWHPLVQRWDVHFUHWWUDQVDFWLRQVBVWHPDQDQRQBPRXVVBVWHPHPSRZHUVLQGLYLGXDOVWRUHYHDOWKHLULGHQWLWBZKHQGHVLUHGDQGRQOBZKHQGHVLUHGWKLVLVWKHHVVHQFHRISULYDFBSULYDFBLQDQRSHQVRFLHWBDOVRUHTXLUHVFUBSWRJUDSKBLILVDBVRPHWKLQJLZDQWLWKHDUGRQOBEBWKRVHIRUZKRPLLQWHQGLWLIWKHFRQWHQWRIPBVSHHFKLVDYDLODEOHWRWKHZRUOGLKDYHQRSULYDFBWRHQFUBSWLVWRLQGLFDWHWKHGHVLUHIRUSULYDFBDQGWRHQFUBSWZLWKZHDNFUBSWRJUDSKBLVWRLQGLFDWHQRWWRRPXFKGHVLUHIRUSULYDFBIXUWKHUPRUHWRUHYHDORQHVLGHQWLWBZLWKDVVXUDQFHZKHQWKHGHIDXOWLVDQRQBPLWBUHTXLUHVWKHFUBSWRJUDSKLFVLJQDWXUHZHFDQQRWHASHFWJRYHUQPHQWVFRUSRUDWLRQVRURWKHUODUJHIDFHOHVVRUJDQLCDWLRQVWRJUDQWXVSULYDFBRXWRIWKHLUEHQHILFHQFHLWLVWRWKHLUDGYDQWDJHWRVSHDNRIXVDQGZHVKRXOGHASHFWWKDWWKHBZLOOVSHDNWRWUBWRSUHYHQWWKHLUVSHHFKLVWRILJKWDJDLQVWWKHUHDOLWLHVRILQIRUPDWLRQLQIRUPDWLRQGRHVQRWMXVWZDQWWREHIUHHLWORQJVWREHIUHHLQIRUPDWLRQHASDQGVWRILOOWKHDYDLODEOHVWRUDJHVSDFHLQIRUPDWLRQLVUXPRUVBRXQJHUVWURQJHUFRXVLQLQIRUPDWLRQLVIOHHWHURIIRRWKDVPRUHHBHVNQRZVPRUHDQGXQGHUVWDQGVOHVVWKDQUXPRUZHPXVWGHIHQGRXURZQSULYDFBLIZHHASHFWWRKDYHDQBZHPXVWFRPHWRJHWKHUDQGFUHDWHVBVWHPVZKLFKDOORZDQRQBPRXVWUDQVDFWLRQVWRWDNHSODFHSHRSOHKDYHEHHQGHIHQGLQJWKHLURZQSULYDFBIRUFHQWXULHVZLWKZKLVSHUVGDUNQHVVHQYHORSHVFORVHGGRRUVVHFUHWKDQGVKDNHVDQGFRXULHUVWKHWHFKQRORJLHVRIWKHSDVWGLGQRWDOORZIRUVWURQJSULYDFBEXWHOHFWURQLFWHFKQRORJLHVGRZHWKHFBSKHUSXQNVDUHGHGLFDWHGWREXLOGLQJDQRQBPRXVVBVWHPVZHDUHGHIHQGLQJRXUSULYDFBZLWKFUBSWRJUDSKBZLWKDQRQBPRXVPDLOIRUZDUGLQJVBVWHPVZLWKGLJLWDOVLJQDWXUHVDQGZLWKHOHFWURQLFPRQHBFBSKHUSXQNVZULWHFRGHZHNQRZWKDWVRPHRQHKDVWRZULWHVRIWZDUHWRGHIHQGSULYDFBDQGVLQFHZHFDQWJHWSULYDFBXQOHVVZHDOOGRZHUHJRLQJWRZULWHLWZHSXEOLVKRXUFRGHVRWKDWRXUIHOORZFBSKHUSXQNVPDBSUDFWLFHDQGSODBZLWKLWRXUFRGHLVIUHHIRUDOOWRXVHZRUOGZLGHZHGRQWPXFKFDUHLIBRXGRQWDSSURYHRIWKHVRIWZDUHZHZULWHZHNQRZWKDWVRIWZDUHFDQWEHGHVWURBHGDQGWKDWDZLGHOBGLVSHUVHGVBVWHPFDQWEHVKXWGRZQFBSKHUSXQNVGHSORUHUHJXODWLRQVRQFUBSWRJUDSKBIRUHQFUBSWLRQLVIXQGDPHQWDOOBDSULYDWHDFWWKHDFWRIHQFUBSWLRQLQIDFWUHPRYHVLQIRUPDWLRQIURPWKHSXEOLFUHDOPHYHQODZVDJDLQVWFUBSWRJUDSKBUHDFKRQOBVRIDUDVDQDWLRQVERUGHUDQGWKHDUPRILWVYLROHQFHFUBSWRJUDSKBZLOOLQHOXFWDEOBVSUHDGRYHUWKHZKROHJOREHDQGZLWKLWWKHDQRQBPRXVWUDQVDFWLRQVVBVWHPVWKDWLWPDNHVSRVVLEOHIRUSULYDFBWREHZLGHVSUHDGLWPXVWEHSDUWRIDVRFLDOFRQWUDFWSHRSOHPXVWFRPHDQGWRJHWKHUGHSORBWKHVHVBVWHPVIRUWKHFRPPRQJRRGSULYDFBRQOBHAWHQGVVRIDUDVWKHFRRSHUDWLRQRIRQHVIHOORZVLQVRFLHWBZHWKHFBSKHUSXQNVVHHNBRXUTXHVWLRQVDQGBRXUFRQFHUQVDQGKRSHZHPDBHQJDJHBRXVRWKDWZHGRQRWGHFHLYHRXUVHOYHVZHZLOOQRWKRZHYHUEHPRYHGRXWRIRXUFRXUVHEHFDXVHVRPHPDBGLVDJUHHZLWKRXUJRDOVWKHFBSKHUSXQNVDUHDFWLYHOBHQJDJHGLQPDNLQJWKHQHWZRUNVVDIHUIRUSULYDFBOHWXVSURFHHGWRJHWKHUDSDFH'for i in range(26): tmp = [chr((ord(char) - ord('A') + i)%26 + ord('A')) for char in string] print(''.join(tmp)) 将所有的字母循环左移3位解码后的结果： 12# Privacy is necessary for an open society in the electronic age. And so on.PRIVACYISNECESSARYFORANOPENSOCIETYINTHEELECTRONICAGEPRIVACYISNOTSECRECYAPRIVATEMATTERISSOMETHINGONEDOESNTWANTTHEWHOLEWORLDTOKNOWBUTASECRETMATTERISSOMETHINGONEDOESNTWANTANYBODYTOKNOWPRIVACYISTHEPOWERTOSELECTIVELYREVEALONESELFTOTHEWORLDIFTWOPARTIESHAVESOMESORTOFDEALINGSTHENEACHHASAMEMORYOFTHEIRINTERACTIONEACHPARTYCANSPEAKABOUTTHEIROWNMEMORYOFTHISHOWCOULDANYONEPREVENTITONECOULDPASSLAWSAGAINSTITBUTTHEFREEDOMOFSPEECHEVENMORETHANPRIVACYISFUNDAMENTALTOANOPENSOCIETYWESEEKNOTTORESTRICTANYSPEECHATALLIFMANYPARTIESSPEAKTOGETHERINTHESAMEFORUMEACHCANSPEAKTOALLTHEOTHERSANDAGGREGATETOGETHERKNOWLEDGEABOUTINDIVIDUALSANDOTHERPARTIESTHEPOWEROFELECTRONICCOMMUNICATIONSHASENABLEDSUCHGROUPSPEECHANDITWILLNOTGOAWAYMERELYBECAUSEWEMIGHTWANTITTOSINCEWEDESIREPRIVACYWEMUSTENSURETHATEACHPARTYTOATRANSACTIONHAVEKNOWLEDGEONLYOFTHATWHICHISDIRECTLYNECESSARYFORTHATTRANSACTIONSINCEANYINFORMATIONCANBESPOKENOFWEMUSTENSURETHATWEREVEALASLITTLEASPOSSIBLEINMOSTCASESPERSONALIDENTITYISNOTSALIENTWHENIPURCHASEAMAGAZINEATASTOREANDHANDCASHTOTHECLERKTHEREISNONEEDTOKNOWWHOIAMWHENIASKMYELECTRONICMAILPROVIDERTOSENDANDRECEIVEMESSAGESMYPROVIDERNEEDNOTKNOWTOWHOMIAMSPEAKINGORWHATIAMSAYINGORWHATOTHERSARESAYINGTOMEMYPROVIDERONLYNEEDKNOWHOWTOGETTHEMESSAGETHEREANDHOWMUCHIOWETHEMINFEESWHENMYIDENTITYISREVEALEDBYTHEUNDERLYINGMECHANISMOFTHETRANSACTIONIHAVENOPRIVACYICANNOTHERESELECTIVELYREVEALMYSELFIMUSTALWAYSREVEALMYSELFTHEREFOREPRIVACYINANOPENSOCIETYREQUIRESANONYMOUSTRANSACTIONSYSTEMSUNTILNOWCASHHASBEENTHEPRIMARYSUCHSYSTEMANANONYMOUSTRANSACTIONSYSTEMISNOTASECRETTRANSACTIONSYSTEMANANONYMOUSSYSTEMEMPOWERSINDIVIDUALSTOREVEALTHEIRIDENTITYWHENDESIREDANDONLYWHENDESIREDTHISISTHEESSENCEOFPRIVACYPRIVACYINANOPENSOCIETYALSOREQUIRESCRYPTOGRAPHYIFISAYSOMETHINGIWANTITHEARDONLYBYTHOSEFORWHOMIINTENDITIFTHECONTENTOFMYSPEECHISAVAILABLETOTHEWORLDIHAVENOPRIVACYTOENCRYPTISTOINDICATETHEDESIREFORPRIVACYANDTOENCRYPTWITHWEAKCRYPTOGRAPHYISTOINDICATENOTTOOMUCHDESIREFORPRIVACYFURTHERMORETOREVEALONESIDENTITYWITHASSURANCEWHENTHEDEFAULTISANONYMITYREQUIRESTHECRYPTOGRAPHICSIGNATUREWECANNOTEXPECTGOVERNMENTSCORPORATIONSOROTHERLARGEFACELESSORGANIZATIONSTOGRANTUSPRIVACYOUTOFTHEIRBENEFICENCEITISTOTHEIRADVANTAGETOSPEAKOFUSANDWESHOULDEXPECTTHATTHEYWILLSPEAKTOTRYTOPREVENTTHEIRSPEECHISTOFIGHTAGAINSTTHEREALITIESOFINFORMATIONINFORMATIONDOESNOTJUSTWANTTOBEFREEITLONGSTOBEFREEINFORMATIONEXPANDSTOFILLTHEAVAILABLESTORAGESPACEINFORMATIONISRUMORSYOUNGERSTRONGERCOUSININFORMATIONISFLEETEROFFOOTHASMOREEYESKNOWSMOREANDUNDERSTANDSLESSTHANRUMORWEMUSTDEFENDOUROWNPRIVACYIFWEEXPECTTOHAVEANYWEMUSTCOMETOGETHERANDCREATESYSTEMSWHICHALLOWANONYMOUSTRANSACTIONSTOTAKEPLACEPEOPLEHAVEBEENDEFENDINGTHEIROWNPRIVACYFORCENTURIESWITHWHISPERSDARKNESSENVELOPESCLOSEDDOORSSECRETHANDSHAKESANDCOURIERSTHETECHNOLOGIESOFTHEPASTDIDNOTALLOWFORSTRONGPRIVACYBUTELECTRONICTECHNOLOGIESDOWETHECYPHERPUNKSAREDEDICATEDTOBUILDINGANONYMOUSSYSTEMSWEAREDEFENDINGOURPRIVACYWITHCRYPTOGRAPHYWITHANONYMOUSMAILFORWARDINGSYSTEMSWITHDIGITALSIGNATURESANDWITHELECTRONICMONEYCYPHERPUNKSWRITECODEWEKNOWTHATSOMEONEHASTOWRITESOFTWARETODEFENDPRIVACYANDSINCEWECANTGETPRIVACYUNLESSWEALLDOWEREGOINGTOWRITEITWEPUBLISHOURCODESOTHATOURFELLOWCYPHERPUNKSMAYPRACTICEANDPLAYWITHITOURCODEISFREEFORALLTOUSEWORLDWIDEWEDONTMUCHCAREIFYOUDONTAPPROVEOFTHESOFTWAREWEWRITEWEKNOWTHATSOFTWARECANTBEDESTROYEDANDTHATAWIDELYDISPERSEDSYSTEMCANTBESHUTDOWNCYPHERPUNKSDEPLOREREGULATIONSONCRYPTOGRAPHYFORENCRYPTIONISFUNDAMENTALLYAPRIVATEACTTHEACTOFENCRYPTIONINFACTREMOVESINFORMATIONFROMTHEPUBLICREALMEVENLAWSAGAINSTCRYPTOGRAPHYREACHONLYSOFARASANATIONSBORDERANDTHEARMOFITSVIOLENCECRYPTOGRAPHYWILLINELUCTABLYSPREADOVERTHEWHOLEGLOBEANDWITHITTHEANONYMOUSTRANSACTIONSSYSTEMSTHATITMAKESPOSSIBLEFORPRIVACYTOBEWIDESPREADITMUSTBEPARTOFASOCIALCONTRACTPEOPLEMUSTCOMEANDTOGETHERDEPLOYTHESESYSTEMSFORTHECOMMONGOODPRIVACYONLYEXTENDSSOFARASTHECOOPERATIONOFONESFELLOWSINSOCIETYWETHECYPHERPUNKSSEEKYOURQUESTIONSANDYOURCONCERNSANDHOPEWEMAYENGAGEYOUSOTHATWEDONOTDECEIVEOURSELVESWEWILLNOTHOWEVERBEMOVEDOUTOFOURCOURSEBECAUSESOMEMAYDISAGREEWITHOURGOALSTHECYPHERPUNKSAREACTIVELYENGAGEDINMAKINGTHENETWORKSSAFERFORPRIVACYLETUSPROCEEDTOGETHERAPACE 可以看到是一篇关于Privacy的文章。接下来就需要把所有的英语单词分开，也就是做英文分词，这个工作非常的繁琐，可以用一些技巧。 分词在中文自然语言处理领域，中文分词往往是第一步骤。因为英文有空格将单词隔开，因此一般不需要进行分词。但是，在某些应用中，也需要英文分词，比如：英文手写识别。这是因为在手写时，单词之间的空格由于过小或者连笔等原因，不能被识别出来，这时就需要对英文进行分词。还有就是有人故意删除了空格🐶。 github上有一个第三方的Python库wordninja，可以快速解决分词问题。不过不能判断句子的结束。 分词结果如下（贴心的转成了小写）： 1privacy is necessary for an open society in the electronic age privacy is not secrecy a private matter is something one doesnt want the whole world to know but a secret matter is something one doesnt want anybody to know privacy is the power to selectively reveal oneself to the world if two parties have some sort of dealings then each has a memory of their interaction each party can speak about their own memory of this how could anyone prevent it one could pass laws against it but the freedom of speech even more than privacy is fundamental to an open society we seek not to restrict any speech at all if many parties speak together in the same forum each can speak to all the others and aggregate together knowledge about individuals and other parties the power of electronic communications has enabled such group speech and it will not go away merely because we might want it to since we desire privacy we must ensure that each party to a transaction have knowledge only of that which is directly necessary for that transaction since any information can bespoken of we must ensure that were veal as little as possible in most cases personal identity is not salient when i purchase a magazine at astore and hand cash to the clerk there is no need to know who iam when i ask my electronic mail provider to send and receive messages my provider need not know to whom iam speaking or what iam saying or what others are saying tome my provider only need knowhow to get the message there and how much i owe them in fees when my identity is revealed by the underlying mechanism of the transaction i have no privacy i cannot here selectively reveal myself i must always reveal myself therefore privacy in an open society requires anonymous transaction systems until now cash has been the primary such system an anonymous transaction system is not a secret transaction system an anonymous system empowers individuals to reveal their identity when desired and only when desired this is the essence of privacy privacy in an open society also requires cryptography if i say something i want it heard only by those for who mi intend it if the content of my speech is available to the world i have no privacy to encrypt is to indicate the desire for privacy and to encrypt with weak cryptography is to indicate not too much desire for privacy furthermore to reveal ones identity with assurance when the default is anonymity requires the cryptographic signature we cannot expect governments corporations or other large faceless organizations to grant us privacy out of their beneficence it is to their advantage to speak of us and we should expect that they will speak to try to prevent their speech is to fight against the realities of information information does not just want to be free it longs to be free information expands to fill the available storage space information is rumors younger stronger cousin information is fleeter of foot has more eyes knows more and understands less than rumor we must defend our own privacy if we expect to have any we must come together and create systems which allow anonymous transactions to take place people have been defending their own privacy for centuries with whispers darkness envelopes closed doors secret handshakes and couriers the technologies of the past did not allow for strong privacy but electronic technologies do we the cypher punks are dedicated to building anonymous systems we are defending our privacy with cryptography with anonymous mail forwarding systems with digital signatures and with electronic money cypher punks write code we know that someone has to write software to defend privacy and since we cant get privacy unless we all do were going to write it we publish our code so that our fellow cypher punks may practice and play with it our code is free for all to use worldwide we dont much care if you dont approve of the software we write we know that software cant be destroyed and that a widely dispersed system cant be shutdown cypher punks deplore regulations on cryptography for encryption is fundamentally a private act the act of encryption in fact removes information from the public realm even laws against cryptography reach only s of aras a nations border and the arm of its violence cryptography will ineluctably spread over the whole globe and with it the anonymous transactions systems that it makes possible for privacy to be widespread it must be part of a social contract people must come and together deploy these systems for the common good privacy only extends s of aras the cooperation of ones fellows in society we the cypher punks seek your questions and your concerns and hope we may engage you so that we do not deceive ourselves we will not however be moved out of our course because some may disagree with our goals the cypher punks are actively engaged in making the networks safer for privacy let us proceed together apace 可见分词的效果非常好，几乎没有什么问题（至少我没看出来） 虽然没有句号，但是基本上也可以通读了，想做阅读理解的同学可以自己读一下。不想读的同学直接丢到翻译里就行啦。 END 2021/5/23 update 看了一下评论区，有人说是密码朋克宣言的一部分，查了一下确实如此。 这是原文： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103 A Cypherpunk's Manifesto by Eric HughesPrivacy is necessary for an open society in the electronic age.Privacy is not secrecy. A private matter is something one doesn'twant the whole world to know, but a secret matter is something onedoesn't want anybody to know. Privacy is the power to selectivelyreveal oneself to the world. If two parties have some sort of dealings, then each has a memory oftheir interaction. Each party can speak about their own memory ofthis; how could anyone prevent it? One could pass laws against it,but the freedom of speech, even more than privacy, is fundamental toan open society; we seek not to restrict any speech at all. If manyparties speak together in the same forum, each can speak to all theothers and aggregate together knowledge about individuals and otherparties. The power of electronic communications has enabled suchgroup speech, and it will not go away merely because we might want itto.Since we desire privacy, we must ensure that each party to atransaction have knowledge only of that which is directly necessaryfor that transaction. Since any information can be spoken of, wemust ensure that we reveal as little as possible. In most casespersonal identity is not salient. When I purchase a magazine at astore and hand cash to the clerk, there is no need to know who I am. When I ask my electronic mail provider to send and receive messages,my provider need not know to whom I am speaking or what I am sayingor what others are saying to me; my provider only need know how toget the message there and how much I owe them in fees. When myidentity is revealed by the underlying mechanism of the transaction,I have no privacy. I cannot here selectively reveal myself; I must_always_ reveal myself.Therefore, privacy in an open society requires anonymous transactionsystems. Until now, cash has been the primary such system. Ananonymous transaction system is not a secret transaction system. Ananonymous system empowers individuals to reveal their identity whendesired and only when desired; this is the essence of privacy.Privacy in an open society also requires cryptography. If I saysomething, I want it heard only by those for whom I intend it. If the content of my speech is available to the world, I have noprivacy. To encrypt is to indicate the desire for privacy, and toencrypt with weak cryptography is to indicate not too much desire forprivacy. Furthermore, to reveal one's identity with assurance whenthe default is anonymity requires the cryptographic signature.We cannot expect governments, corporations, or other large, facelessorganizations to grant us privacy out of their beneficence. It is totheir advantage to speak of us, and we should expect that they willspeak. To try to prevent their speech is to fight against therealities of information. Information does not just want to be free,it longs to be free. Information expands to fill the availablestorage space. Information is Rumor's younger, stronger cousin;Information is fleeter of foot, has more eyes, knows more, andunderstands less than Rumor.We must defend our own privacy if we expect to have any. We mustcome together and create systems which allow anonymous transactionsto take place. People have been defending their own privacy forcenturies with whispers, darkness, envelopes, closed doors, secrethandshakes, and couriers. The technologies of the past did not allowfor strong privacy, but electronic technologies do.We the Cypherpunks are dedicated to building anonymous systems. Weare defending our privacy with cryptography, with anonymous mailforwarding systems, with digital signatures, and with electronicmoney.Cypherpunks write code. We know that someone has to write softwareto defend privacy, and since we can't get privacy unless we all do,we're going to write it. We publish our code so that our fellowCypherpunks may practice and play with it. Our code is free for allto use, worldwide. We don't much care if you don't approve of thesoftware we write. We know that software can't be destroyed and thata widely dispersed system can't be shut down. Cypherpunks deplore regulations on cryptography, for encryption isfundamentally a private act. The act of encryption, in fact, removesinformation from the public realm. Even laws against cryptographyreach only so far as a nation's border and the arm of its violence.Cryptography will ineluctably spread over the whole globe, and withit the anonymous transactions systems that it makes possible. For privacy to be widespread it must be part of a social contract.People must come and together deploy these systems for the commongood. Privacy only extends so far as the cooperation of one'sfellows in society. We the Cypherpunks seek your questions and yourconcerns and hope we may engage you so that we do not deceiveourselves. We will not, however, be moved out of our course becausesome may disagree with our goals.The Cypherpunks are actively engaged in making the networks safer forprivacy. Let us proceed together apace.Onward.Eric Hughes&lt;hughes@soda.berkeley.edu&gt;9 March 1993 Cover is created by logoly","link":"/2021/05/22/%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"},{"title":"LeetCode 2081. Sum of k-Mirror Numbers","text":"昨天闲来无事做了一个LeetCode的周赛，看到大佬不到二十分钟就AK了，真是Orz 本篇记录一下第四题的答案。 比赛链接 k 镜像数字的和题目链接 可以考虑快速找到所有十进制下的回文数，然后判断在k进制下是否是回文数。 快速查找回文数的方法，可以用构造法： 考虑数字 99，它的下一个回文数应该是 101。 考虑数字 1234，它的下一个回文数应该是 1331。 考虑数字 999，它的下一个回文数应该是 1001。 考虑数字 191，它的下一个回文数应该是 202。 将数字的前一半（如果是奇数位，包括中间位）定义为left，然后将left+1，如果产生进位，那么我们需要直接找100…001格式的下一个数字。否则，我们只需要将left对称就可以得到下一个回文数的后半部分了（需要考虑数字的位数） Number Left Left+1 Right NextParlindrome 99 9 10 1 101 999 99 100 1 1001 1234 12 13 31 1331 191 19 20 2 202 实现上述逻辑： 123456789def nextParlindrome(s): left = s[:(len(s)+1)//2] carry = len(str(int(left) + 1)) != len(left) odd = int(len(s) % 2 == 1) left = str(int(left) + 1) if carry: # 特判 99..99 格式的数字 return &quot;1&quot; + &quot;0&quot;*(len(s)-1) + &quot;1&quot; else: return left + (left[:-1][::-1] if odd else left[::-1]) 可以看出，这个复杂度是只与数字的长度相关的，因此复杂度为 $O(len(s))$","link":"/2021/11/25/LeetCode-2081-Sum-of-k-Mirror-Numbers/"}],"tags":[{"name":"旅游","slug":"旅游","link":"/tags/%E6%97%85%E6%B8%B8/"},{"name":"数据结构","slug":"数据结构","link":"/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"动态规划","slug":"动态规划","link":"/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"点分治","slug":"点分治","link":"/tags/%E7%82%B9%E5%88%86%E6%B2%BB/"},{"name":"图论","slug":"图论","link":"/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"树状数组","slug":"树状数组","link":"/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"},{"name":"欧拉定理","slug":"欧拉定理","link":"/tags/%E6%AC%A7%E6%8B%89%E5%AE%9A%E7%90%86/"},{"name":"欧拉函数","slug":"欧拉函数","link":"/tags/%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0/"},{"name":"数论","slug":"数论","link":"/tags/%E6%95%B0%E8%AE%BA/"},{"name":"中国剩余定理","slug":"中国剩余定理","link":"/tags/%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86/"},{"name":"二维偏序","slug":"二维偏序","link":"/tags/%E4%BA%8C%E7%BB%B4%E5%81%8F%E5%BA%8F/"},{"name":"单调队列","slug":"单调队列","link":"/tags/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/"},{"name":"树形动规","slug":"树形动规","link":"/tags/%E6%A0%91%E5%BD%A2%E5%8A%A8%E8%A7%84/"},{"name":"LCA","slug":"LCA","link":"/tags/LCA/"},{"name":"拉格朗日插值法","slug":"拉格朗日插值法","link":"/tags/%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E6%8F%92%E5%80%BC%E6%B3%95/"},{"name":"考研","slug":"考研","link":"/tags/%E8%80%83%E7%A0%94/"},{"name":"MySQL","slug":"MySQL","link":"/tags/MySQL/"},{"name":"Python","slug":"Python","link":"/tags/Python/"},{"name":"拉格朗日乘数法","slug":"拉格朗日乘数法","link":"/tags/%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E4%B9%98%E6%95%B0%E6%B3%95/"},{"name":"IDA*","slug":"IDA","link":"/tags/IDA/"},{"name":"启发式搜索","slug":"启发式搜索","link":"/tags/%E5%90%AF%E5%8F%91%E5%BC%8F%E6%90%9C%E7%B4%A2/"},{"name":"搜索","slug":"搜索","link":"/tags/%E6%90%9C%E7%B4%A2/"},{"name":"SSL","slug":"SSL","link":"/tags/SSL/"},{"name":"Nginx","slug":"Nginx","link":"/tags/Nginx/"},{"name":"HTTPS","slug":"HTTPS","link":"/tags/HTTPS/"},{"name":"爬虫","slug":"爬虫","link":"/tags/%E7%88%AC%E8%99%AB/"},{"name":"知乎","slug":"知乎","link":"/tags/%E7%9F%A5%E4%B9%8E/"},{"name":"基环树","slug":"基环树","link":"/tags/%E5%9F%BA%E7%8E%AF%E6%A0%91/"},{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"Machine Learning","slug":"Machine-Learning","link":"/tags/Machine-Learning/"},{"name":"Math","slug":"Math","link":"/tags/Math/"},{"name":"几何","slug":"几何","link":"/tags/%E5%87%A0%E4%BD%95/"},{"name":"线段树","slug":"线段树","link":"/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"},{"name":"红楼梦","slug":"红楼梦","link":"/tags/%E7%BA%A2%E6%A5%BC%E6%A2%A6/"},{"name":"sklearn","slug":"sklearn","link":"/tags/sklearn/"},{"name":"Web","slug":"Web","link":"/tags/Web/"},{"name":"HTTP","slug":"HTTP","link":"/tags/HTTP/"},{"name":"并发","slug":"并发","link":"/tags/%E5%B9%B6%E5%8F%91/"},{"name":"模式设计","slug":"模式设计","link":"/tags/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"},{"name":"Go","slug":"Go","link":"/tags/Go/"},{"name":"word2vec","slug":"word2vec","link":"/tags/word2vec/"},{"name":"解谜","slug":"解谜","link":"/tags/%E8%A7%A3%E8%B0%9C/"},{"name":"LeetCode-Hard","slug":"LeetCode-Hard","link":"/tags/LeetCode-Hard/"}],"categories":[{"name":"竞赛","slug":"竞赛","link":"/categories/%E7%AB%9E%E8%B5%9B/"},{"name":"ICPC","slug":"竞赛/ICPC","link":"/categories/%E7%AB%9E%E8%B5%9B/ICPC/"},{"name":"CCPC","slug":"竞赛/CCPC","link":"/categories/%E7%AB%9E%E8%B5%9B/CCPC/"},{"name":"ECNU","slug":"ECNU","link":"/categories/ECNU/"},{"name":"网络","slug":"网络","link":"/categories/%E7%BD%91%E7%BB%9C/"},{"name":"NLP","slug":"NLP","link":"/categories/NLP/"},{"name":"随笔","slug":"随笔","link":"/categories/%E9%9A%8F%E7%AC%94/"},{"name":"LeetCode","slug":"LeetCode","link":"/categories/LeetCode/"}]}